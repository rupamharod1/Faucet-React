{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.watchTransactionBySubscription = void 0;\n\nconst web3_utils_1 = require(\"web3-utils\");\n\nconst schemas_js_1 = require(\"../schemas.js\");\n\nconst watch_transaction_by_pooling_js_1 = require(\"./watch_transaction_by_pooling.js\");\n/**\n * This function watches a Transaction by subscribing to new heads.\n * It is used by `watchTransactionForConfirmations`, in case the provider supports subscription.\n */\n\n\nconst watchTransactionBySubscription = _ref => {\n  let {\n    web3Context,\n    transactionReceipt,\n    transactionPromiEvent,\n    returnFormat\n  } = _ref;\n  // The following variable will stay true except if the data arrived,\n  //\tor if watching started after an error had occurred.\n  let needToWatchLater = true;\n  let lastCaughtBlockHash;\n  setImmediate(() => {\n    var _a;\n\n    (_a = web3Context.subscriptionManager) === null || _a === void 0 ? void 0 : _a.subscribe('newHeads').then(subscription => {\n      subscription.on('data', newBlockHeader => __awaiter(void 0, void 0, void 0, function* () {\n        var _a;\n\n        needToWatchLater = false;\n\n        if (!(newBlockHeader === null || newBlockHeader === void 0 ? void 0 : newBlockHeader.number) || // For some cases, the on-data event is fired couple times for the same block!\n        // This needs investigation but seems to be because of multiple `subscription.on('data'...)` even this should not cause that.\n        lastCaughtBlockHash === (newBlockHeader === null || newBlockHeader === void 0 ? void 0 : newBlockHeader.parentHash)) {\n          return;\n        }\n\n        lastCaughtBlockHash = newBlockHeader === null || newBlockHeader === void 0 ? void 0 : newBlockHeader.parentHash;\n        const confirmations = BigInt(newBlockHeader.number) - BigInt(transactionReceipt.blockNumber) + BigInt(1);\n        transactionPromiEvent.emit('confirmation', {\n          confirmations: (0, web3_utils_1.format)({\n            format: 'uint'\n          }, confirmations, returnFormat),\n          receipt: (0, web3_utils_1.format)(schemas_js_1.transactionReceiptSchema, transactionReceipt, returnFormat),\n          latestBlockHash: (0, web3_utils_1.format)({\n            format: 'bytes32'\n          }, newBlockHeader.parentHash, returnFormat)\n        });\n\n        if (confirmations >= web3Context.transactionConfirmationBlocks) {\n          yield (_a = web3Context.subscriptionManager) === null || _a === void 0 ? void 0 : _a.removeSubscription(subscription);\n        }\n      }));\n      subscription.on('error', () => __awaiter(void 0, void 0, void 0, function* () {\n        var _b;\n\n        yield (_b = web3Context.subscriptionManager) === null || _b === void 0 ? void 0 : _b.removeSubscription(subscription);\n        needToWatchLater = false;\n        (0, watch_transaction_by_pooling_js_1.watchTransactionByPolling)({\n          web3Context,\n          transactionReceipt,\n          transactionPromiEvent,\n          returnFormat\n        });\n      }));\n    }).catch(() => {\n      needToWatchLater = false;\n      (0, watch_transaction_by_pooling_js_1.watchTransactionByPolling)({\n        web3Context,\n        transactionReceipt,\n        transactionPromiEvent,\n        returnFormat\n      });\n    });\n  }); // Fallback to polling if tx receipt didn't arrived in \"blockHeaderTimeout\" [10 seconds]\n\n  setTimeout(() => {\n    if (needToWatchLater) {\n      (0, watch_transaction_by_pooling_js_1.watchTransactionByPolling)({\n        web3Context,\n        transactionReceipt,\n        transactionPromiEvent,\n        returnFormat\n      });\n    }\n  }, web3Context.blockHeaderTimeout * 1000);\n};\n\nexports.watchTransactionBySubscription = watchTransactionBySubscription;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiBA;;AAIA;;AACA;AAEA;;;;;;AAIO,MAAMA,8BAA8B,GAAG,QAQH;EAAA,IALzC;IACDC,WADC;IAEDC,kBAFC;IAGDC,qBAHC;IAIDC;EAJC,CAKyC;EAC1C;EACA;EACA,IAAIC,gBAAgB,GAAG,IAAvB;EACA,IAAIC,mBAAJ;EACAC,YAAY,CAAC,MAAK;;;IACjB,iBAAW,CAACC,mBAAZ,MAA+B,IAA/B,IAA+BC,aAA/B,GAA+B,MAA/B,GAA+BA,GAC5BC,SAD4B,CAClB,UADkB,EAE7BC,IAF6B,CAEvBC,YAAD,IAAuC;MAC5CA,YAAY,CAACC,EAAb,CAAgB,MAAhB,EAA+BC,cAAP,IAA4CC;;;QACnEV,gBAAgB,GAAG,KAAnB;;QACA,IACC,EAACS,cAAc,SAAd,kBAAc,WAAd,GAAc,MAAd,iBAAc,CAAEE,MAAjB,KACA;QACA;QACAV,mBAAmB,MAAKQ,cAAc,SAAd,kBAAc,WAAd,GAAc,MAAd,iBAAc,CAAEG,UAArB,CAJpB,EAKE;UACD;QACA;;QACDX,mBAAmB,GAAGQ,cAAc,SAAd,kBAAc,WAAd,GAAc,MAAd,iBAAc,CAAEG,UAAtC;QAEA,MAAMC,aAAa,GAClBC,MAAM,CAACL,cAAc,CAACE,MAAhB,CAAN,GACAG,MAAM,CAACjB,kBAAkB,CAACkB,WAApB,CADN,GAEAD,MAAM,CAAC,CAAD,CAHP;QAKAhB,qBAAqB,CAACkB,IAAtB,CAA2B,cAA3B,EAA2C;UAC1CH,aAAa,EAAE,yBACd;YAAEI,MAAM,EAAE;UAAV,CADc,EAEdJ,aAFc,EAGdd,YAHc,CAD2B;UAM1CmB,OAAO,EAAE,yBAAOC,qCAAP,EAAiCtB,kBAAjC,EAAqDE,YAArD,CANiC;UAO1CqB,eAAe,EAAE,yBAChB;YAAEH,MAAM,EAAE;UAAV,CADgB,EAEhBR,cAAc,CAACG,UAFC,EAGhBb,YAHgB;QAPyB,CAA3C;;QAaA,IAAIc,aAAa,IAAIjB,WAAW,CAACyB,6BAAjC,EAAgE;UAC/D,MAAM,iBAAW,CAAClB,mBAAZ,MAA+B,IAA/B,IAA+BC,aAA/B,GAA+B,MAA/B,GAA+BA,GAAEkB,kBAAF,CAAqBf,YAArB,CAArC;QACA;MACD,CAjCmE,CAApE;MAkCAA,YAAY,CAACC,EAAb,CAAgB,OAAhB,EAAyB,MAAWE;;;QACnC,MAAM,iBAAW,CAACP,mBAAZ,MAA+B,IAA/B,IAA+BoB,aAA/B,GAA+B,MAA/B,GAA+BA,GAAED,kBAAF,CAAqBf,YAArB,CAArC;QAEAP,gBAAgB,GAAG,KAAnB;QACA,iEAA0B;UACzBJ,WADyB;UAEzBC,kBAFyB;UAGzBC,qBAHyB;UAIzBC;QAJyB,CAA1B;MAMA,CAVmC,CAApC;IAWA,CAhD6B,EAiD7ByB,KAjD6B,CAiDvB,MAAK;MACXxB,gBAAgB,GAAG,KAAnB;MACA,iEAA0B;QACzBJ,WADyB;QAEzBC,kBAFyB;QAGzBC,qBAHyB;QAIzBC;MAJyB,CAA1B;IAMA,CAzD6B,CAA/B;EA0DA,CA3DW,CAAZ,CAL0C,CAkE1C;;EACA0B,UAAU,CAAC,MAAK;IACf,IAAIzB,gBAAJ,EAAsB;MACrB,iEAA0B;QACzBJ,WADyB;QAEzBC,kBAFyB;QAGzBC,qBAHyB;QAIzBC;MAJyB,CAA1B;IAMA;EACD,CATS,EASPH,WAAW,CAAC8B,kBAAZ,GAAiC,IAT1B,CAAV;AAUA,CArFM;;AAAMC,yCAA8BhC,8BAA9B","names":["watchTransactionBySubscription","web3Context","transactionReceipt","transactionPromiEvent","returnFormat","needToWatchLater","lastCaughtBlockHash","setImmediate","subscriptionManager","_a","subscribe","then","subscription","on","newBlockHeader","__awaiter","number","parentHash","confirmations","BigInt","blockNumber","emit","format","receipt","schemas_js_1","latestBlockHash","transactionConfirmationBlocks","removeSubscription","_b","catch","setTimeout","blockHeaderTimeout","exports"],"sources":["/home/rupam/Desktop/Faucet-React/node_modules/web3-eth/src/utils/watch_transaction_by_subscription.ts"],"sourcesContent":["/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { Bytes, Numbers, BlockHeaderOutput, TransactionReceipt } from 'web3-types';\nimport { format } from 'web3-utils';\n\nimport { DataFormat } from 'web3-types';\nimport { NewHeadsSubscription } from '../web3_subscriptions.js';\nimport { transactionReceiptSchema } from '../schemas.js';\nimport { WaitProps, watchTransactionByPolling } from './watch_transaction_by_pooling.js';\n\n/**\n * This function watches a Transaction by subscribing to new heads.\n * It is used by `watchTransactionForConfirmations`, in case the provider supports subscription.\n */\nexport const watchTransactionBySubscription = <\n\tReturnFormat extends DataFormat,\n\tResolveType = TransactionReceipt,\n>({\n\tweb3Context,\n\ttransactionReceipt,\n\ttransactionPromiEvent,\n\treturnFormat,\n}: WaitProps<ReturnFormat, ResolveType>) => {\n\t// The following variable will stay true except if the data arrived,\n\t//\tor if watching started after an error had occurred.\n\tlet needToWatchLater = true;\n\tlet lastCaughtBlockHash: string;\n\tsetImmediate(() => {\n\t\tweb3Context.subscriptionManager\n\t\t\t?.subscribe('newHeads')\n\t\t\t.then((subscription: NewHeadsSubscription) => {\n\t\t\t\tsubscription.on('data', async (newBlockHeader: BlockHeaderOutput) => {\n\t\t\t\t\tneedToWatchLater = false;\n\t\t\t\t\tif (\n\t\t\t\t\t\t!newBlockHeader?.number ||\n\t\t\t\t\t\t// For some cases, the on-data event is fired couple times for the same block!\n\t\t\t\t\t\t// This needs investigation but seems to be because of multiple `subscription.on('data'...)` even this should not cause that.\n\t\t\t\t\t\tlastCaughtBlockHash === newBlockHeader?.parentHash\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tlastCaughtBlockHash = newBlockHeader?.parentHash as string;\n\n\t\t\t\t\tconst confirmations =\n\t\t\t\t\t\tBigInt(newBlockHeader.number) -\n\t\t\t\t\t\tBigInt(transactionReceipt.blockNumber) +\n\t\t\t\t\t\tBigInt(1);\n\n\t\t\t\t\ttransactionPromiEvent.emit('confirmation', {\n\t\t\t\t\t\tconfirmations: format(\n\t\t\t\t\t\t\t{ format: 'uint' },\n\t\t\t\t\t\t\tconfirmations as Numbers,\n\t\t\t\t\t\t\treturnFormat,\n\t\t\t\t\t\t),\n\t\t\t\t\t\treceipt: format(transactionReceiptSchema, transactionReceipt, returnFormat),\n\t\t\t\t\t\tlatestBlockHash: format(\n\t\t\t\t\t\t\t{ format: 'bytes32' },\n\t\t\t\t\t\t\tnewBlockHeader.parentHash as Bytes,\n\t\t\t\t\t\t\treturnFormat,\n\t\t\t\t\t\t),\n\t\t\t\t\t});\n\t\t\t\t\tif (confirmations >= web3Context.transactionConfirmationBlocks) {\n\t\t\t\t\t\tawait web3Context.subscriptionManager?.removeSubscription(subscription);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tsubscription.on('error', async () => {\n\t\t\t\t\tawait web3Context.subscriptionManager?.removeSubscription(subscription);\n\n\t\t\t\t\tneedToWatchLater = false;\n\t\t\t\t\twatchTransactionByPolling({\n\t\t\t\t\t\tweb3Context,\n\t\t\t\t\t\ttransactionReceipt,\n\t\t\t\t\t\ttransactionPromiEvent,\n\t\t\t\t\t\treturnFormat,\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t})\n\t\t\t.catch(() => {\n\t\t\t\tneedToWatchLater = false;\n\t\t\t\twatchTransactionByPolling({\n\t\t\t\t\tweb3Context,\n\t\t\t\t\ttransactionReceipt,\n\t\t\t\t\ttransactionPromiEvent,\n\t\t\t\t\treturnFormat,\n\t\t\t\t});\n\t\t\t});\n\t});\n\n\t// Fallback to polling if tx receipt didn't arrived in \"blockHeaderTimeout\" [10 seconds]\n\tsetTimeout(() => {\n\t\tif (needToWatchLater) {\n\t\t\twatchTransactionByPolling({\n\t\t\t\tweb3Context,\n\t\t\t\ttransactionReceipt,\n\t\t\t\ttransactionPromiEvent,\n\t\t\t\treturnFormat,\n\t\t\t});\n\t\t}\n\t}, web3Context.blockHeaderTimeout * 1000);\n};\n"]},"metadata":{},"sourceType":"script"}