{"ast":null,"code":"/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { keccak256 } from 'ethereum-cryptography/keccak.js';\nimport { utf8ToBytes } from 'ethereum-cryptography/utils.js';\nimport { InvalidAddressError, InvalidBooleanError, InvalidBytesError, InvalidLargeValueError, InvalidSizeError, InvalidStringError, InvalidUnsignedIntegerError } from 'web3-errors';\nimport { isAddress, isNullish, isHexStrict } from 'web3-validator';\nimport { bytesToUint8Array, bytesToHex, hexToBytes, toBigInt, toHex, toNumber, utf8ToHex } from './converters.js';\nimport { leftPad, rightPad, toTwosComplement } from './string_manipulation.js';\nconst SHA3_EMPTY_BYTES = '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';\n/**\n * computes the Keccak-256 hash of the input and returns a hexstring\n * @param data - the input to hash\n * @returns - the Keccak-256 hash of the input\n *\n * @example\n * ```ts\n * console.log(web3.utils.sha3('web3.js'));\n * > 0x63667efb1961039c9bb0d6ea7a5abdd223a3aca7daa5044ad894226e1f83919a\n *\n * console.log(web3.utils.sha3(''));\n * > undefined\n * ```\n */\n\nexport const sha3 = data => {\n  let updatedData;\n\n  if (typeof data === 'string') {\n    if (data.startsWith('0x') && isHexStrict(data)) {\n      updatedData = hexToBytes(data);\n    } else {\n      updatedData = utf8ToBytes(data);\n    }\n  } else {\n    updatedData = data;\n  }\n\n  const hash = bytesToHex(keccak256(updatedData)); // EIP-1052 if hash is equal to c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470, keccak was given empty data\n\n  return hash === SHA3_EMPTY_BYTES ? undefined : hash;\n};\n/**\n * Will calculate the sha3 of the input but does return the hash value instead of null if for example a empty string is passed.\n * @param data - the input to hash\n * @returns - the Keccak-256 hash of the input\n *\n * @example\n * ```ts\n * conosle.log(web3.utils.sha3Raw('web3.js'));\n * > 0x63667efb1961039c9bb0d6ea7a5abdd223a3aca7daa5044ad894226e1f83919a\n *\n * console.log(web3.utils.sha3Raw(''));\n * > 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\n * ```\n */\n\nexport const sha3Raw = data => {\n  const hash = sha3(data);\n\n  if (isNullish(hash)) {\n    return SHA3_EMPTY_BYTES;\n  }\n\n  return hash;\n};\n/**\n * A wrapper for ethereum-cryptography/keccak256 to allow hashing a `string` and a `bigint` in addition to `UInt8Array`\n * @param data - the input to hash\n * @returns - the Keccak-256 hash of the input\n *\n * @example\n * ```ts\n * console.log(web3.utils.keccak256Wrapper('web3.js'));\n * > 0x63667efb1961039c9bb0d6ea7a5abdd223a3aca7daa5044ad894226e1f83919a\n *\n * console.log(web3.utils.keccak256Wrapper(1));\n * > 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6\n *\n * console.log(web3.utils.keccak256Wrapper(0xaf12fd));\n * > 0x358640fd4719fa923525d74ab5ae80a594301aba5543e3492b052bf4598b794c\n * ```\n */\n\nexport const keccak256Wrapper = data => {\n  let processedData;\n\n  if (typeof data === 'bigint' || typeof data === 'number') {\n    processedData = utf8ToBytes(data.toString());\n  } else if (Array.isArray(data)) {\n    processedData = new Uint8Array(data);\n  } else if (typeof data === 'string' && !isHexStrict(data)) {\n    processedData = utf8ToBytes(data);\n  } else {\n    processedData = bytesToUint8Array(data);\n  }\n\n  return bytesToHex(keccak256(processedData));\n};\nexport { keccak256Wrapper as keccak256 };\n/**\n * returns type and value\n * @param arg - the input to return the type and value\n * @returns - the type and value of the input\n */\n\nconst getType = arg => {\n  if (Array.isArray(arg)) {\n    throw new Error('Autodetection of array types is not supported.');\n  }\n\n  let type;\n  let value; // if type is given\n\n  if (typeof arg === 'object' && ('t' in arg || 'type' in arg) && ('v' in arg || 'value' in arg)) {\n    type = 't' in arg ? arg.t : arg.type;\n    value = 'v' in arg ? arg.v : arg.value;\n    type = type.toLowerCase() === 'bigint' ? 'int' : type;\n  } else if (typeof arg === 'bigint') {\n    return ['int', arg];\n  } // otherwise try to guess the type\n  else {\n    type = toHex(arg, true);\n    value = toHex(arg);\n\n    if (!type.startsWith('int') && !type.startsWith('uint')) {\n      type = 'bytes';\n    }\n  }\n\n  if ((type.startsWith('int') || type.startsWith('uint')) && typeof value === 'string' && !/^(-)?0x/i.test(value)) {\n    value = toBigInt(value);\n  }\n\n  return [type, value];\n};\n/**\n * returns the type with size if uint or int\n * @param name - the input to return the type with size\n * @returns - the type with size of the input\n */\n\n\nconst elementaryName = name => {\n  if (name.startsWith('int[')) {\n    return `int256${name.slice(3)}`;\n  }\n\n  if (name === 'int') {\n    return 'int256';\n  }\n\n  if (name.startsWith('uint[')) {\n    return `uint256'${name.slice(4)}`;\n  }\n\n  if (name === 'uint') {\n    return 'uint256';\n  }\n\n  return name;\n};\n/**\n * returns the size of the value of type 'byte'\n */\n\n\nconst parseTypeN = (value, typeLength) => {\n  const typesize = /^(\\d+).*$/.exec(value.slice(typeLength));\n  return typesize ? parseInt(typesize[1], 10) : 0;\n};\n/**\n * returns the bit length of the value\n * @param value - the input to return the bit length\n * @returns - the bit length of the input\n */\n\n\nconst bitLength = value => {\n  const updatedVal = value.toString(2);\n  return updatedVal.length;\n};\n/**\n * Pads the value based on size and type\n * returns a string of the padded value\n * @param type - the input to pad\n * @returns = the padded value\n */\n\n\nconst solidityPack = (type, val) => {\n  const value = val.toString();\n\n  if (type === 'string') {\n    if (typeof val === 'string') return utf8ToHex(val);\n    throw new InvalidStringError(val);\n  }\n\n  if (type === 'bool' || type === 'boolean') {\n    if (typeof val === 'boolean') return val ? '01' : '00';\n    throw new InvalidBooleanError(val);\n  }\n\n  if (type === 'address') {\n    if (!isAddress(value)) {\n      throw new InvalidAddressError(value);\n    }\n\n    return value;\n  }\n\n  const name = elementaryName(type);\n\n  if (type.startsWith('uint')) {\n    const size = parseTypeN(name, 'uint'.length);\n\n    if (size % 8 || size < 8 || size > 256) {\n      throw new InvalidSizeError(value);\n    }\n\n    const num = toNumber(value);\n\n    if (bitLength(num) > size) {\n      throw new InvalidLargeValueError(value);\n    }\n\n    if (num < BigInt(0)) {\n      throw new InvalidUnsignedIntegerError(value);\n    }\n\n    return size ? leftPad(num.toString(16), size / 8 * 2) : num.toString(16);\n  }\n\n  if (type.startsWith('int')) {\n    const size = parseTypeN(name, 'int'.length);\n\n    if (size % 8 || size < 8 || size > 256) {\n      throw new InvalidSizeError(type);\n    }\n\n    const num = toNumber(value);\n\n    if (bitLength(num) > size) {\n      throw new InvalidLargeValueError(value);\n    }\n\n    if (num < BigInt(0)) {\n      return toTwosComplement(num.toString(), size / 8 * 2);\n    }\n\n    return size ? leftPad(num.toString(16), size / 4) : num.toString(16);\n  }\n\n  if (name === 'bytes') {\n    if (value.replace(/^0x/i, '').length % 2 !== 0) {\n      throw new InvalidBytesError(value);\n    }\n\n    return value;\n  }\n\n  if (type.startsWith('bytes')) {\n    if (value.replace(/^0x/i, '').length % 2 !== 0) {\n      throw new InvalidBytesError(value);\n    }\n\n    const size = parseTypeN(type, 'bytes'.length);\n\n    if (!size || size < 1 || size > 64 || size < value.replace(/^0x/i, '').length / 2) {\n      throw new InvalidBytesError(value);\n    }\n\n    return rightPad(value, size * 2);\n  }\n\n  return '';\n};\n/**\n * returns a string of the tightly packed value given based on the type\n * @param arg - the input to return the tightly packed value\n * @returns - the tightly packed value\n */\n\n\nexport const processSolidityEncodePackedArgs = arg => {\n  const [type, val] = getType(arg); // array case\n\n  if (Array.isArray(val)) {\n    // go through each element of the array and use map function to create new hexarg list\n    const hexArg = val.map(v => solidityPack(type, v).replace('0x', ''));\n    return hexArg.join('');\n  }\n\n  const hexArg = solidityPack(type, val);\n  return hexArg.replace('0x', '');\n};\n/**\n * Encode packed arguments to a hexstring\n */\n\nexport const encodePacked = function () {\n  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n    values[_key] = arguments[_key];\n  }\n\n  const args = Array.prototype.slice.call(values);\n  const hexArgs = args.map(processSolidityEncodePackedArgs);\n  return `0x${hexArgs.join('').toLowerCase()}`;\n};\n/**\n * Will tightly pack values given in the same way solidity would then hash.\n * returns a hash string, or null if input is empty\n * @param values - the input to return the tightly packed values\n * @returns - the keccack246 of the tightly packed values\n *\n * @example\n * ```ts\n *  console.log([{ type: 'string', value: '31323334' }]);\n * console.log(web3.utils.soliditySha3({ type: \"string\", value: \"31323334\" }));\n * > 0xf15f8da2ad27e486d632dc37d24912f634398918d6f9913a0a0ff84e388be62b\n * ```\n */\n\nexport const soliditySha3 = function () {\n  return sha3(encodePacked(...arguments));\n};\n/**\n * Will tightly pack values given in the same way solidity would then hash.\n * returns a hash string, if input is empty will return `0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470`\n * @param values - the input to return the tightly packed values\n * @returns - the keccack246 of the tightly packed values\n *\n * @example\n * ```ts\n * console.log(web3.utils.soliditySha3Raw({ type: \"string\", value: \"helloworld\" }))\n * > 0xfa26db7ca85ead399216e7c6316bc50ed24393c3122b582735e7f3b0f91b93f0\n * ```\n */\n\nexport const soliditySha3Raw = function () {\n  return sha3Raw(encodePacked(...arguments));\n};\n/**\n * Get slot number for storage long string in contract. Basically for getStorage method\n * returns slotNumber where will data placed\n * @param mainSlotNumber - the slot number where will be stored hash of long string\n * @returns - the slot number where will be stored long string\n */\n\nexport const getStorageSlotNumForLongString = mainSlotNumber => sha3(`0x${(typeof mainSlotNumber === 'number' ? mainSlotNumber.toString() : mainSlotNumber).padStart(64, '0')}`);","map":{"version":3,"mappings":"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","names":["keccak256","utf8ToBytes","InvalidAddressError","InvalidBooleanError","InvalidBytesError","InvalidLargeValueError","InvalidSizeError","InvalidStringError","InvalidUnsignedIntegerError","isAddress","isNullish","isHexStrict","bytesToUint8Array","bytesToHex","hexToBytes","toBigInt","toHex","toNumber","utf8ToHex","leftPad","rightPad","toTwosComplement","SHA3_EMPTY_BYTES","sha3","data","updatedData","startsWith","hash","undefined","sha3Raw","keccak256Wrapper","processedData","toString","Array","isArray","Uint8Array","getType","arg","Error","type","value","t","v","toLowerCase","test","elementaryName","name","slice","parseTypeN","typeLength","typesize","exec","parseInt","bitLength","updatedVal","length","solidityPack","val","size","num","BigInt","replace","processSolidityEncodePackedArgs","hexArg","map","join","encodePacked","values","args","prototype","call","hexArgs","soliditySha3","soliditySha3Raw","getStorageSlotNumForLongString","mainSlotNumber","padStart"],"sources":["/home/rupam/Desktop/Faucet-React/node_modules/web3-utils/src/hash.ts"],"sourcesContent":["﻿/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport { keccak256 } from 'ethereum-cryptography/keccak.js';\nimport { utf8ToBytes } from 'ethereum-cryptography/utils.js';\nimport {\n\tInvalidAddressError,\n\tInvalidBooleanError,\n\tInvalidBytesError,\n\tInvalidLargeValueError,\n\tInvalidSizeError,\n\tInvalidStringError,\n\tInvalidUnsignedIntegerError,\n} from 'web3-errors';\nimport {\n\tBytes,\n\tEncodingTypes,\n\tNumbers,\n\tSha3Input,\n\tTypedObject,\n\tTypedObjectAbbreviated,\n} from 'web3-types';\nimport { isAddress, isNullish, isHexStrict } from 'web3-validator';\nimport {\n\tbytesToUint8Array,\n\tbytesToHex,\n\thexToBytes,\n\ttoBigInt,\n\ttoHex,\n\ttoNumber,\n\tutf8ToHex,\n} from './converters.js';\nimport { leftPad, rightPad, toTwosComplement } from './string_manipulation.js';\n\nconst SHA3_EMPTY_BYTES = '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';\n\n/**\n * computes the Keccak-256 hash of the input and returns a hexstring\n * @param data - the input to hash\n * @returns - the Keccak-256 hash of the input\n *\n * @example\n * ```ts\n * console.log(web3.utils.sha3('web3.js'));\n * > 0x63667efb1961039c9bb0d6ea7a5abdd223a3aca7daa5044ad894226e1f83919a\n *\n * console.log(web3.utils.sha3(''));\n * > undefined\n * ```\n */\nexport const sha3 = (data: Bytes): string | undefined => {\n\tlet updatedData: Uint8Array;\n\n\tif (typeof data === 'string') {\n\t\tif (data.startsWith('0x') && isHexStrict(data)) {\n\t\t\tupdatedData = hexToBytes(data);\n\t\t} else {\n\t\t\tupdatedData = utf8ToBytes(data);\n\t\t}\n\t} else {\n\t\tupdatedData = data;\n\t}\n\tconst hash = bytesToHex(keccak256(updatedData));\n\n\t// EIP-1052 if hash is equal to c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470, keccak was given empty data\n\treturn hash === SHA3_EMPTY_BYTES ? undefined : hash;\n};\n\n/**\n * Will calculate the sha3 of the input but does return the hash value instead of null if for example a empty string is passed.\n * @param data - the input to hash\n * @returns - the Keccak-256 hash of the input\n *\n * @example\n * ```ts\n * conosle.log(web3.utils.sha3Raw('web3.js'));\n * > 0x63667efb1961039c9bb0d6ea7a5abdd223a3aca7daa5044ad894226e1f83919a\n *\n * console.log(web3.utils.sha3Raw(''));\n * > 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\n * ```\n */\nexport const sha3Raw = (data: Bytes): string => {\n\tconst hash = sha3(data);\n\tif (isNullish(hash)) {\n\t\treturn SHA3_EMPTY_BYTES;\n\t}\n\n\treturn hash;\n};\n\n/**\n * A wrapper for ethereum-cryptography/keccak256 to allow hashing a `string` and a `bigint` in addition to `UInt8Array`\n * @param data - the input to hash\n * @returns - the Keccak-256 hash of the input\n *\n * @example\n * ```ts\n * console.log(web3.utils.keccak256Wrapper('web3.js'));\n * > 0x63667efb1961039c9bb0d6ea7a5abdd223a3aca7daa5044ad894226e1f83919a\n *\n * console.log(web3.utils.keccak256Wrapper(1));\n * > 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6\n *\n * console.log(web3.utils.keccak256Wrapper(0xaf12fd));\n * > 0x358640fd4719fa923525d74ab5ae80a594301aba5543e3492b052bf4598b794c\n * ```\n */\nexport const keccak256Wrapper = (\n\tdata: Bytes | Numbers | string | ReadonlyArray<number>,\n): string => {\n\tlet processedData;\n\tif (typeof data === 'bigint' || typeof data === 'number') {\n\t\tprocessedData = utf8ToBytes(data.toString());\n\t} else if (Array.isArray(data)) {\n\t\tprocessedData = new Uint8Array(data);\n\t} else if (typeof data === 'string' && !isHexStrict(data)) {\n\t\tprocessedData = utf8ToBytes(data);\n\t} else {\n\t\tprocessedData = bytesToUint8Array(data as Bytes);\n\t}\n\treturn bytesToHex(keccak256(processedData));\n};\n\nexport { keccak256Wrapper as keccak256 };\n\n/**\n * returns type and value\n * @param arg - the input to return the type and value\n * @returns - the type and value of the input\n */\nconst getType = (arg: Sha3Input): [string, EncodingTypes] => {\n\tif (Array.isArray(arg)) {\n\t\tthrow new Error('Autodetection of array types is not supported.');\n\t}\n\n\tlet type;\n\tlet value;\n\t// if type is given\n\tif (\n\t\ttypeof arg === 'object' &&\n\t\t('t' in arg || 'type' in arg) &&\n\t\t('v' in arg || 'value' in arg)\n\t) {\n\t\ttype = 't' in arg ? arg.t : arg.type;\n\t\tvalue = 'v' in arg ? arg.v : arg.value;\n\n\t\ttype = type.toLowerCase() === 'bigint' ? 'int' : type;\n\t} else if (typeof arg === 'bigint') {\n\t\treturn ['int', arg];\n\t}\n\t// otherwise try to guess the type\n\telse {\n\t\ttype = toHex(arg, true);\n\t\tvalue = toHex(arg);\n\n\t\tif (!type.startsWith('int') && !type.startsWith('uint')) {\n\t\t\ttype = 'bytes';\n\t\t}\n\t}\n\n\tif (\n\t\t(type.startsWith('int') || type.startsWith('uint')) &&\n\t\ttypeof value === 'string' &&\n\t\t!/^(-)?0x/i.test(value)\n\t) {\n\t\tvalue = toBigInt(value);\n\t}\n\treturn [type, value];\n};\n\n/**\n * returns the type with size if uint or int\n * @param name - the input to return the type with size\n * @returns - the type with size of the input\n */\nconst elementaryName = (name: string): string => {\n\tif (name.startsWith('int[')) {\n\t\treturn `int256${name.slice(3)}`;\n\t}\n\tif (name === 'int') {\n\t\treturn 'int256';\n\t}\n\tif (name.startsWith('uint[')) {\n\t\treturn `uint256'${name.slice(4)}`;\n\t}\n\tif (name === 'uint') {\n\t\treturn 'uint256';\n\t}\n\treturn name;\n};\n\n/**\n * returns the size of the value of type 'byte'\n */\nconst parseTypeN = (value: string, typeLength: number): number => {\n\tconst typesize = /^(\\d+).*$/.exec(value.slice(typeLength));\n\treturn typesize ? parseInt(typesize[1], 10) : 0;\n};\n\n/**\n * returns the bit length of the value\n * @param value - the input to return the bit length\n * @returns - the bit length of the input\n */\nconst bitLength = (value: bigint | number): number => {\n\tconst updatedVal = value.toString(2);\n\treturn updatedVal.length;\n};\n\n/**\n * Pads the value based on size and type\n * returns a string of the padded value\n * @param type - the input to pad\n * @returns = the padded value\n */\nconst solidityPack = (type: string, val: EncodingTypes): string => {\n\tconst value = val.toString();\n\tif (type === 'string') {\n\t\tif (typeof val === 'string') return utf8ToHex(val);\n\t\tthrow new InvalidStringError(val);\n\t}\n\tif (type === 'bool' || type === 'boolean') {\n\t\tif (typeof val === 'boolean') return val ? '01' : '00';\n\t\tthrow new InvalidBooleanError(val);\n\t}\n\n\tif (type === 'address') {\n\t\tif (!isAddress(value)) {\n\t\t\tthrow new InvalidAddressError(value);\n\t\t}\n\t\treturn value;\n\t}\n\tconst name = elementaryName(type);\n\tif (type.startsWith('uint')) {\n\t\tconst size = parseTypeN(name, 'uint'.length);\n\n\t\tif (size % 8 || size < 8 || size > 256) {\n\t\t\tthrow new InvalidSizeError(value);\n\t\t}\n\t\tconst num = toNumber(value);\n\t\tif (bitLength(num) > size) {\n\t\t\tthrow new InvalidLargeValueError(value);\n\t\t}\n\t\tif (num < BigInt(0)) {\n\t\t\tthrow new InvalidUnsignedIntegerError(value);\n\t\t}\n\n\t\treturn size ? leftPad(num.toString(16), (size / 8) * 2) : num.toString(16);\n\t}\n\n\tif (type.startsWith('int')) {\n\t\tconst size = parseTypeN(name, 'int'.length);\n\t\tif (size % 8 || size < 8 || size > 256) {\n\t\t\tthrow new InvalidSizeError(type);\n\t\t}\n\n\t\tconst num = toNumber(value);\n\t\tif (bitLength(num) > size) {\n\t\t\tthrow new InvalidLargeValueError(value);\n\t\t}\n\t\tif (num < BigInt(0)) {\n\t\t\treturn toTwosComplement(num.toString(), (size / 8) * 2);\n\t\t}\n\t\treturn size ? leftPad(num.toString(16), size / 4) : num.toString(16);\n\t}\n\n\tif (name === 'bytes') {\n\t\tif (value.replace(/^0x/i, '').length % 2 !== 0) {\n\t\t\tthrow new InvalidBytesError(value);\n\t\t}\n\t\treturn value;\n\t}\n\n\tif (type.startsWith('bytes')) {\n\t\tif (value.replace(/^0x/i, '').length % 2 !== 0) {\n\t\t\tthrow new InvalidBytesError(value);\n\t\t}\n\n\t\tconst size = parseTypeN(type, 'bytes'.length);\n\n\t\tif (!size || size < 1 || size > 64 || size < value.replace(/^0x/i, '').length / 2) {\n\t\t\tthrow new InvalidBytesError(value);\n\t\t}\n\n\t\treturn rightPad(value, size * 2);\n\t}\n\treturn '';\n};\n\n/**\n * returns a string of the tightly packed value given based on the type\n * @param arg - the input to return the tightly packed value\n * @returns - the tightly packed value\n */\nexport const processSolidityEncodePackedArgs = (arg: Sha3Input): string => {\n\tconst [type, val] = getType(arg);\n\n\t// array case\n\tif (Array.isArray(val)) {\n\t\t// go through each element of the array and use map function to create new hexarg list\n\t\tconst hexArg = val.map((v: Numbers | boolean) => solidityPack(type, v).replace('0x', ''));\n\t\treturn hexArg.join('');\n\t}\n\n\tconst hexArg = solidityPack(type, val);\n\treturn hexArg.replace('0x', '');\n};\n\n/**\n * Encode packed arguments to a hexstring\n */\nexport const encodePacked = (...values: Sha3Input[]): string => {\n\tconst args = Array.prototype.slice.call(values);\n\tconst hexArgs = args.map(processSolidityEncodePackedArgs);\n\treturn `0x${hexArgs.join('').toLowerCase()}`;\n};\n\n/**\n * Will tightly pack values given in the same way solidity would then hash.\n * returns a hash string, or null if input is empty\n * @param values - the input to return the tightly packed values\n * @returns - the keccack246 of the tightly packed values\n *\n * @example\n * ```ts\n *  console.log([{ type: 'string', value: '31323334' }]);\n * console.log(web3.utils.soliditySha3({ type: \"string\", value: \"31323334\" }));\n * > 0xf15f8da2ad27e486d632dc37d24912f634398918d6f9913a0a0ff84e388be62b\n * ```\n */\nexport const soliditySha3 = (...values: Sha3Input[]): string | undefined =>\n\tsha3(encodePacked(...values));\n\n/**\n * Will tightly pack values given in the same way solidity would then hash.\n * returns a hash string, if input is empty will return `0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470`\n * @param values - the input to return the tightly packed values\n * @returns - the keccack246 of the tightly packed values\n *\n * @example\n * ```ts\n * console.log(web3.utils.soliditySha3Raw({ type: \"string\", value: \"helloworld\" }))\n * > 0xfa26db7ca85ead399216e7c6316bc50ed24393c3122b582735e7f3b0f91b93f0\n * ```\n */\nexport const soliditySha3Raw = (...values: TypedObject[] | TypedObjectAbbreviated[]): string =>\n\tsha3Raw(encodePacked(...values));\n\n/**\n * Get slot number for storage long string in contract. Basically for getStorage method\n * returns slotNumber where will data placed\n * @param mainSlotNumber - the slot number where will be stored hash of long string\n * @returns - the slot number where will be stored long string\n */\nexport const getStorageSlotNumForLongString = (mainSlotNumber: number | string) =>\n\tsha3(\n\t\t`0x${(typeof mainSlotNumber === 'number'\n\t\t\t? mainSlotNumber.toString()\n\t\t\t: mainSlotNumber\n\t\t).padStart(64, '0')}`,\n\t);\n"]},"metadata":{},"sourceType":"module"}