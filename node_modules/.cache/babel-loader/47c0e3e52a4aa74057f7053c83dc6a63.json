{"ast":null,"code":"import { mod } from './modular.js';\nimport { bytesToNumberBE, concatBytes, utf8ToBytes, validateObject } from './utils.js';\n\nfunction validateDST(dst) {\n  if (dst instanceof Uint8Array) return dst;\n  if (typeof dst === 'string') return utf8ToBytes(dst);\n  throw new Error('DST must be Uint8Array or string');\n} // Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\n\n\nconst os2ip = bytesToNumberBE; // Integer to Octet Stream (numberToBytesBE)\n\nfunction i2osp(value, length) {\n  if (value < 0 || value >= 1 << 8 * length) {\n    throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n  }\n\n  const res = Array.from({\n    length\n  }).fill(0);\n\n  for (let i = length - 1; i >= 0; i--) {\n    res[i] = value & 0xff;\n    value >>>= 8;\n  }\n\n  return new Uint8Array(res);\n}\n\nfunction strxor(a, b) {\n  const arr = new Uint8Array(a.length);\n\n  for (let i = 0; i < a.length; i++) {\n    arr[i] = a[i] ^ b[i];\n  }\n\n  return arr;\n}\n\nfunction isBytes(item) {\n  if (!(item instanceof Uint8Array)) throw new Error('Uint8Array expected');\n}\n\nfunction isNum(item) {\n  if (!Number.isSafeInteger(item)) throw new Error('number expected');\n} // Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-11#section-5.4.1\n\n\nexport function expand_message_xmd(msg, DST, lenInBytes, H) {\n  isBytes(msg);\n  isBytes(DST);\n  isNum(lenInBytes); // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-5.3.3\n\n  if (DST.length > 255) DST = H(concatBytes(utf8ToBytes('H2C-OVERSIZE-DST-'), DST));\n  const {\n    outputLen: b_in_bytes,\n    blockLen: r_in_bytes\n  } = H;\n  const ell = Math.ceil(lenInBytes / b_in_bytes);\n  if (ell > 255) throw new Error('Invalid xmd length');\n  const DST_prime = concatBytes(DST, i2osp(DST.length, 1));\n  const Z_pad = i2osp(0, r_in_bytes);\n  const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n\n  const b = new Array(ell);\n  const b_0 = H(concatBytes(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n  b[0] = H(concatBytes(b_0, i2osp(1, 1), DST_prime));\n\n  for (let i = 1; i <= ell; i++) {\n    const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n    b[i] = H(concatBytes(...args));\n  }\n\n  const pseudo_random_bytes = concatBytes(...b);\n  return pseudo_random_bytes.slice(0, lenInBytes);\n}\nexport function expand_message_xof(msg, DST, lenInBytes, k, H) {\n  isBytes(msg);\n  isBytes(DST);\n  isNum(lenInBytes); // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-5.3.3\n  // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n\n  if (DST.length > 255) {\n    const dkLen = Math.ceil(2 * k / 8);\n    DST = H.create({\n      dkLen\n    }).update(utf8ToBytes('H2C-OVERSIZE-DST-')).update(DST).digest();\n  }\n\n  if (lenInBytes > 65535 || DST.length > 255) throw new Error('expand_message_xof: invalid lenInBytes');\n  return H.create({\n    dkLen: lenInBytes\n  }).update(msg).update(i2osp(lenInBytes, 2)) // 2. DST_prime = DST || I2OSP(len(DST), 1)\n  .update(DST).update(i2osp(DST.length, 1)).digest();\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-11#section-5.3\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\n\nexport function hash_to_field(msg, count, options) {\n  validateObject(options, {\n    DST: 'string',\n    p: 'bigint',\n    m: 'isSafeInteger',\n    k: 'isSafeInteger',\n    hash: 'hash'\n  });\n  const {\n    p,\n    k,\n    m,\n    hash,\n    expand,\n    DST: _DST\n  } = options;\n  isBytes(msg);\n  isNum(count);\n  const DST = validateDST(_DST);\n  const log2p = p.toString(2).length;\n  const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n\n  const len_in_bytes = count * m * L;\n  let prb; // pseudo_random_bytes\n\n  if (expand === 'xmd') {\n    prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n  } else if (expand === 'xof') {\n    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n  } else if (expand === '_internal_pass') {\n    // for internal tests only\n    prb = msg;\n  } else {\n    throw new Error('expand must be \"xmd\" or \"xof\"');\n  }\n\n  const u = new Array(count);\n\n  for (let i = 0; i < count; i++) {\n    const e = new Array(m);\n\n    for (let j = 0; j < m; j++) {\n      const elm_offset = L * (j + i * m);\n      const tv = prb.subarray(elm_offset, elm_offset + L);\n      e[j] = mod(os2ip(tv), p);\n    }\n\n    u[i] = e;\n  }\n\n  return u;\n}\nexport function isogenyMap(field, map) {\n  // Make same order as in spec\n  const COEFF = map.map(i => Array.from(i).reverse());\n  return (x, y) => {\n    const [xNum, xDen, yNum, yDen] = COEFF.map(val => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n    x = field.div(xNum, xDen); // xNum / xDen\n\n    y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n\n    return {\n      x,\n      y\n    };\n  };\n}\nexport function createHasher(Point, mapToCurve, def) {\n  if (typeof mapToCurve !== 'function') throw new Error('mapToCurve() must be defined');\n  return {\n    // Encodes byte string to elliptic curve\n    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3\n    hashToCurve(msg, options) {\n      const u = hash_to_field(msg, 2, { ...def,\n        DST: def.DST,\n        ...options\n      });\n      const u0 = Point.fromAffine(mapToCurve(u[0]));\n      const u1 = Point.fromAffine(mapToCurve(u[1]));\n      const P = u0.add(u1).clearCofactor();\n      P.assertValidity();\n      return P;\n    },\n\n    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3\n    encodeToCurve(msg, options) {\n      const u = hash_to_field(msg, 1, { ...def,\n        DST: def.encodeDST,\n        ...options\n      });\n      const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n      P.assertValidity();\n      return P;\n    }\n\n  };\n}","map":{"version":3,"mappings":"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","names":["mod","bytesToNumberBE","concatBytes","utf8ToBytes","validateObject","validateDST","dst","Uint8Array","Error","os2ip","i2osp","value","length","res","Array","from","fill","i","strxor","a","b","arr","isBytes","item","isNum","Number","isSafeInteger","expand_message_xmd","msg","DST","lenInBytes","H","outputLen","b_in_bytes","blockLen","r_in_bytes","ell","Math","ceil","DST_prime","Z_pad","l_i_b_str","b_0","args","pseudo_random_bytes","slice","expand_message_xof","k","dkLen","create","update","digest","hash_to_field","count","options","p","m","hash","expand","_DST","log2p","toString","L","len_in_bytes","prb","u","e","j","elm_offset","tv","subarray","isogenyMap","field","map","COEFF","reverse","x","y","xNum","xDen","yNum","yDen","val","reduce","acc","add","mul","div","createHasher","Point","mapToCurve","def","hashToCurve","u0","fromAffine","u1","P","clearCofactor","assertValidity","encodeToCurve","encodeDST"],"sources":["/home/rupam/Desktop/Faucet-React/node_modules/@noble/curves/src/abstract/hash-to-curve.ts"],"sourcesContent":["/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport type { Group, GroupConstructor, AffinePoint } from './curve.js';\nimport { mod, IField } from './modular.js';\nimport { bytesToNumberBE, CHash, concatBytes, utf8ToBytes, validateObject } from './utils.js';\n\n/**\n * * `DST` is a domain separation tag, defined in section 2.2.5\n * * `p` characteristic of F, where F is a finite field of characteristic p and order q = p^m\n * * `m` is extension degree (1 for prime fields)\n * * `k` is the target security target in bits (e.g. 128), from section 5.1\n * * `expand` is `xmd` (SHA2, SHA3, BLAKE) or `xof` (SHAKE, BLAKE-XOF)\n * * `hash` conforming to `utils.CHash` interface, with `outputLen` / `blockLen` props\n */\ntype UnicodeOrBytes = string | Uint8Array;\nexport type Opts = {\n  DST: UnicodeOrBytes;\n  p: bigint;\n  m: number;\n  k: number;\n  expand: 'xmd' | 'xof';\n  hash: CHash;\n};\n\nfunction validateDST(dst: UnicodeOrBytes): Uint8Array {\n  if (dst instanceof Uint8Array) return dst;\n  if (typeof dst === 'string') return utf8ToBytes(dst);\n  throw new Error('DST must be Uint8Array or string');\n}\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = bytesToNumberBE;\n\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value: number, length: number): Uint8Array {\n  if (value < 0 || value >= 1 << (8 * length)) {\n    throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n  }\n  const res = Array.from({ length }).fill(0) as number[];\n  for (let i = length - 1; i >= 0; i--) {\n    res[i] = value & 0xff;\n    value >>>= 8;\n  }\n  return new Uint8Array(res);\n}\n\nfunction strxor(a: Uint8Array, b: Uint8Array): Uint8Array {\n  const arr = new Uint8Array(a.length);\n  for (let i = 0; i < a.length; i++) {\n    arr[i] = a[i] ^ b[i];\n  }\n  return arr;\n}\n\nfunction isBytes(item: unknown): void {\n  if (!(item instanceof Uint8Array)) throw new Error('Uint8Array expected');\n}\nfunction isNum(item: unknown): void {\n  if (!Number.isSafeInteger(item)) throw new Error('number expected');\n}\n\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-11#section-5.4.1\nexport function expand_message_xmd(\n  msg: Uint8Array,\n  DST: Uint8Array,\n  lenInBytes: number,\n  H: CHash\n): Uint8Array {\n  isBytes(msg);\n  isBytes(DST);\n  isNum(lenInBytes);\n  // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-5.3.3\n  if (DST.length > 255) DST = H(concatBytes(utf8ToBytes('H2C-OVERSIZE-DST-'), DST));\n  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n  const ell = Math.ceil(lenInBytes / b_in_bytes);\n  if (ell > 255) throw new Error('Invalid xmd length');\n  const DST_prime = concatBytes(DST, i2osp(DST.length, 1));\n  const Z_pad = i2osp(0, r_in_bytes);\n  const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n  const b = new Array<Uint8Array>(ell);\n  const b_0 = H(concatBytes(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n  b[0] = H(concatBytes(b_0, i2osp(1, 1), DST_prime));\n  for (let i = 1; i <= ell; i++) {\n    const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n    b[i] = H(concatBytes(...args));\n  }\n  const pseudo_random_bytes = concatBytes(...b);\n  return pseudo_random_bytes.slice(0, lenInBytes);\n}\n\nexport function expand_message_xof(\n  msg: Uint8Array,\n  DST: Uint8Array,\n  lenInBytes: number,\n  k: number,\n  H: CHash\n): Uint8Array {\n  isBytes(msg);\n  isBytes(DST);\n  isNum(lenInBytes);\n  // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-5.3.3\n  // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n  if (DST.length > 255) {\n    const dkLen = Math.ceil((2 * k) / 8);\n    DST = H.create({ dkLen }).update(utf8ToBytes('H2C-OVERSIZE-DST-')).update(DST).digest();\n  }\n  if (lenInBytes > 65535 || DST.length > 255)\n    throw new Error('expand_message_xof: invalid lenInBytes');\n  return (\n    H.create({ dkLen: lenInBytes })\n      .update(msg)\n      .update(i2osp(lenInBytes, 2))\n      // 2. DST_prime = DST || I2OSP(len(DST), 1)\n      .update(DST)\n      .update(i2osp(DST.length, 1))\n      .digest()\n  );\n}\n\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-11#section-5.3\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nexport function hash_to_field(msg: Uint8Array, count: number, options: Opts): bigint[][] {\n  validateObject(options, {\n    DST: 'string',\n    p: 'bigint',\n    m: 'isSafeInteger',\n    k: 'isSafeInteger',\n    hash: 'hash',\n  });\n  const { p, k, m, hash, expand, DST: _DST } = options;\n  isBytes(msg);\n  isNum(count);\n  const DST = validateDST(_DST);\n  const log2p = p.toString(2).length;\n  const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n  const len_in_bytes = count * m * L;\n  let prb; // pseudo_random_bytes\n  if (expand === 'xmd') {\n    prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n  } else if (expand === 'xof') {\n    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n  } else if (expand === '_internal_pass') {\n    // for internal tests only\n    prb = msg;\n  } else {\n    throw new Error('expand must be \"xmd\" or \"xof\"');\n  }\n  const u = new Array(count);\n  for (let i = 0; i < count; i++) {\n    const e = new Array(m);\n    for (let j = 0; j < m; j++) {\n      const elm_offset = L * (j + i * m);\n      const tv = prb.subarray(elm_offset, elm_offset + L);\n      e[j] = mod(os2ip(tv), p);\n    }\n    u[i] = e;\n  }\n  return u;\n}\n\nexport function isogenyMap<T, F extends IField<T>>(field: F, map: [T[], T[], T[], T[]]) {\n  // Make same order as in spec\n  const COEFF = map.map((i) => Array.from(i).reverse());\n  return (x: T, y: T) => {\n    const [xNum, xDen, yNum, yDen] = COEFF.map((val) =>\n      val.reduce((acc, i) => field.add(field.mul(acc, x), i))\n    );\n    x = field.div(xNum, xDen); // xNum / xDen\n    y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n    return { x, y };\n  };\n}\n\nexport interface H2CPoint<T> extends Group<H2CPoint<T>> {\n  add(rhs: H2CPoint<T>): H2CPoint<T>;\n  toAffine(iz?: bigint): AffinePoint<T>;\n  clearCofactor(): H2CPoint<T>;\n  assertValidity(): void;\n}\n\nexport interface H2CPointConstructor<T> extends GroupConstructor<H2CPoint<T>> {\n  fromAffine(ap: AffinePoint<T>): H2CPoint<T>;\n}\n\nexport type MapToCurve<T> = (scalar: bigint[]) => AffinePoint<T>;\n\n// Separated from initialization opts, so users won't accidentally change per-curve parameters\n// (changing DST is ok!)\nexport type htfBasicOpts = { DST: UnicodeOrBytes };\n\nexport function createHasher<T>(\n  Point: H2CPointConstructor<T>,\n  mapToCurve: MapToCurve<T>,\n  def: Opts & { encodeDST?: UnicodeOrBytes }\n) {\n  if (typeof mapToCurve !== 'function') throw new Error('mapToCurve() must be defined');\n  return {\n    // Encodes byte string to elliptic curve\n    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3\n    hashToCurve(msg: Uint8Array, options?: htfBasicOpts) {\n      const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options } as Opts);\n      const u0 = Point.fromAffine(mapToCurve(u[0]));\n      const u1 = Point.fromAffine(mapToCurve(u[1]));\n      const P = u0.add(u1).clearCofactor();\n      P.assertValidity();\n      return P;\n    },\n\n    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3\n    encodeToCurve(msg: Uint8Array, options?: htfBasicOpts) {\n      const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options } as Opts);\n      const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n      P.assertValidity();\n      return P;\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"module"}