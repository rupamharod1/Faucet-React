{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ecRecover = exports.sign = exports.signTransaction = exports.sendTransaction = exports.importRawKey = exports.lockAccount = exports.unlockAccount = exports.newAccount = exports.getAccounts = void 0;\n\nconst web3_utils_1 = require(\"web3-utils\");\n\nconst web3_eth_1 = require(\"web3-eth\");\n\nconst web3_types_1 = require(\"web3-types\");\n\nconst web3_validator_1 = require(\"web3-validator\");\n\nconst web3_rpc_methods_1 = require(\"web3-rpc-methods\");\n\nconst getAccounts = requestManager => __awaiter(void 0, void 0, void 0, function* () {\n  const result = yield web3_rpc_methods_1.personalRpcMethods.getAccounts(requestManager);\n  return result.map(web3_utils_1.toChecksumAddress);\n});\n\nexports.getAccounts = getAccounts;\n\nconst newAccount = (requestManager, password) => __awaiter(void 0, void 0, void 0, function* () {\n  web3_validator_1.validator.validate(['string'], [password]);\n  const result = yield web3_rpc_methods_1.personalRpcMethods.newAccount(requestManager, password);\n  return (0, web3_utils_1.toChecksumAddress)(result);\n});\n\nexports.newAccount = newAccount;\n\nconst unlockAccount = (requestManager, address, password, unlockDuration) => __awaiter(void 0, void 0, void 0, function* () {\n  web3_validator_1.validator.validate(['address', 'string', 'uint'], [address, password, unlockDuration]);\n  return web3_rpc_methods_1.personalRpcMethods.unlockAccount(requestManager, address, password, unlockDuration);\n});\n\nexports.unlockAccount = unlockAccount;\n\nconst lockAccount = (requestManager, address) => __awaiter(void 0, void 0, void 0, function* () {\n  web3_validator_1.validator.validate(['address'], [address]);\n  return web3_rpc_methods_1.personalRpcMethods.lockAccount(requestManager, address);\n});\n\nexports.lockAccount = lockAccount;\n\nconst importRawKey = (requestManager, keyData, passphrase) => __awaiter(void 0, void 0, void 0, function* () {\n  web3_validator_1.validator.validate(['string', 'string'], [keyData, passphrase]);\n  return web3_rpc_methods_1.personalRpcMethods.importRawKey(requestManager, keyData, passphrase);\n});\n\nexports.importRawKey = importRawKey;\n\nconst sendTransaction = (requestManager, tx, passphrase) => __awaiter(void 0, void 0, void 0, function* () {\n  const formattedTx = (0, web3_eth_1.formatTransaction)(tx, web3_types_1.ETH_DATA_FORMAT);\n  return web3_rpc_methods_1.personalRpcMethods.sendTransaction(requestManager, formattedTx, passphrase);\n});\n\nexports.sendTransaction = sendTransaction;\n\nconst signTransaction = (requestManager, tx, passphrase) => __awaiter(void 0, void 0, void 0, function* () {\n  const formattedTx = (0, web3_eth_1.formatTransaction)(tx, web3_types_1.ETH_DATA_FORMAT);\n  return web3_rpc_methods_1.personalRpcMethods.signTransaction(requestManager, formattedTx, passphrase);\n});\n\nexports.signTransaction = signTransaction;\n\nconst sign = (requestManager, data, address, passphrase) => __awaiter(void 0, void 0, void 0, function* () {\n  web3_validator_1.validator.validate(['string', 'address', 'string'], [data, address, passphrase]);\n  const dataToSign = (0, web3_validator_1.isHexStrict)(data) ? data : (0, web3_utils_1.utf8ToHex)(data);\n  return web3_rpc_methods_1.personalRpcMethods.sign(requestManager, dataToSign, address, passphrase);\n});\n\nexports.sign = sign;\n\nconst ecRecover = (requestManager, signedData, signature) => __awaiter(void 0, void 0, void 0, function* () {\n  web3_validator_1.validator.validate(['string', 'string'], [signedData, signature]);\n  const signedDataString = (0, web3_validator_1.isHexStrict)(signedData) ? signedData : (0, web3_utils_1.utf8ToHex)(signedData);\n  return web3_rpc_methods_1.personalRpcMethods.ecRecover(requestManager, signedDataString, signature);\n});\n\nexports.ecRecover = ecRecover;","map":{"version":3,"mappings":"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","names":["getAccounts","requestManager","__awaiter","result","web3_rpc_methods_1","map","web3_utils_1","exports","newAccount","password","web3_validator_1","validate","unlockAccount","address","unlockDuration","lockAccount","importRawKey","keyData","passphrase","sendTransaction","tx","formattedTx","web3_types_1","signTransaction","sign","data","dataToSign","ecRecover","signedData","signature","signedDataString"],"sources":["/home/rupam/Desktop/Faucet-React/node_modules/web3-eth-personal/src/rpc_method_wrappers.ts"],"sourcesContent":["/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { Web3RequestManager } from 'web3-core';\nimport { toChecksumAddress, utf8ToHex } from 'web3-utils';\nimport { formatTransaction } from 'web3-eth';\nimport { Address, EthPersonalAPI, ETH_DATA_FORMAT, HexString, Transaction } from 'web3-types';\nimport { validator, isHexStrict } from 'web3-validator';\nimport { personalRpcMethods } from 'web3-rpc-methods';\n\nexport const getAccounts = async (requestManager: Web3RequestManager<EthPersonalAPI>) => {\n\tconst result = await personalRpcMethods.getAccounts(requestManager);\n\n\treturn result.map(toChecksumAddress);\n};\n\nexport const newAccount = async (\n\trequestManager: Web3RequestManager<EthPersonalAPI>,\n\tpassword: string,\n) => {\n\tvalidator.validate(['string'], [password]);\n\n\tconst result = await personalRpcMethods.newAccount(requestManager, password);\n\n\treturn toChecksumAddress(result);\n};\n\nexport const unlockAccount = async (\n\trequestManager: Web3RequestManager<EthPersonalAPI>,\n\taddress: Address,\n\tpassword: string,\n\tunlockDuration: number,\n) => {\n\tvalidator.validate(['address', 'string', 'uint'], [address, password, unlockDuration]);\n\n\treturn personalRpcMethods.unlockAccount(requestManager, address, password, unlockDuration);\n};\n\nexport const lockAccount = async (\n\trequestManager: Web3RequestManager<EthPersonalAPI>,\n\taddress: Address,\n) => {\n\tvalidator.validate(['address'], [address]);\n\n\treturn personalRpcMethods.lockAccount(requestManager, address);\n};\n\nexport const importRawKey = async (\n\trequestManager: Web3RequestManager<EthPersonalAPI>,\n\tkeyData: HexString,\n\tpassphrase: string,\n) => {\n\tvalidator.validate(['string', 'string'], [keyData, passphrase]);\n\n\treturn personalRpcMethods.importRawKey(requestManager, keyData, passphrase);\n};\n\nexport const sendTransaction = async (\n\trequestManager: Web3RequestManager<EthPersonalAPI>,\n\ttx: Transaction,\n\tpassphrase: string,\n) => {\n\tconst formattedTx = formatTransaction(tx, ETH_DATA_FORMAT);\n\n\treturn personalRpcMethods.sendTransaction(requestManager, formattedTx, passphrase);\n};\n\nexport const signTransaction = async (\n\trequestManager: Web3RequestManager<EthPersonalAPI>,\n\ttx: Transaction,\n\tpassphrase: string,\n) => {\n\tconst formattedTx = formatTransaction(tx, ETH_DATA_FORMAT);\n\n\treturn personalRpcMethods.signTransaction(requestManager, formattedTx, passphrase);\n};\n\nexport const sign = async (\n\trequestManager: Web3RequestManager<EthPersonalAPI>,\n\tdata: HexString,\n\taddress: Address,\n\tpassphrase: string,\n) => {\n\tvalidator.validate(['string', 'address', 'string'], [data, address, passphrase]);\n\n\tconst dataToSign = isHexStrict(data) ? data : utf8ToHex(data);\n\n\treturn personalRpcMethods.sign(requestManager, dataToSign, address, passphrase);\n};\n\nexport const ecRecover = async (\n\trequestManager: Web3RequestManager<EthPersonalAPI>,\n\tsignedData: HexString,\n\tsignature: string,\n) => {\n\tvalidator.validate(['string', 'string'], [signedData, signature]);\n\n\tconst signedDataString = isHexStrict(signedData) ? signedData : utf8ToHex(signedData);\n\n\treturn personalRpcMethods.ecRecover(requestManager, signedDataString, signature);\n};\n"]},"metadata":{},"sourceType":"script"}