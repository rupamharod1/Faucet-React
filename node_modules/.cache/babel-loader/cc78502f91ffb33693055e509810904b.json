{"ast":null,"code":"\"use strict\";\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toBool = exports.toChecksumAddress = exports.toWei = exports.fromWei = exports.toBigInt = exports.toNumber = exports.toHex = exports.toAscii = exports.hexToAscii = exports.fromAscii = exports.asciiToHex = exports.hexToString = exports.utf8ToBytes = exports.toUtf8 = exports.hexToUtf8 = exports.stringToHex = exports.fromUtf8 = exports.utf8ToHex = exports.hexToNumberString = exports.fromDecimal = exports.numberToHex = exports.toDecimal = exports.hexToNumber = exports.hexToBytes = exports.bytesToHex = exports.bytesToUint8Array = exports.ethUnitMap = void 0;\n\nconst keccak_js_1 = require(\"ethereum-cryptography/keccak.js\");\n\nconst utils_js_1 = require(\"ethereum-cryptography/utils.js\");\n\nconst web3_validator_1 = require(\"web3-validator\");\n\nconst web3_errors_1 = require(\"web3-errors\"); // Ref: https://ethdocs.org/en/latest/ether.html\n// Note: this could be simplified using ** operator, but babel does not handle it well (https://github.com/babel/babel/issues/13109)\n\n/** @internal */\n\n\nexports.ethUnitMap = {\n  noether: BigInt(0),\n  wei: BigInt(1),\n  kwei: BigInt(1000),\n  Kwei: BigInt(1000),\n  babbage: BigInt(1000),\n  femtoether: BigInt(1000),\n  mwei: BigInt(1000000),\n  Mwei: BigInt(1000000),\n  lovelace: BigInt(1000000),\n  picoether: BigInt(1000000),\n  gwei: BigInt(1000000000),\n  Gwei: BigInt(1000000000),\n  shannon: BigInt(1000000000),\n  nanoether: BigInt(1000000000),\n  nano: BigInt(1000000000),\n  szabo: BigInt(1000000000000),\n  microether: BigInt(1000000000000),\n  micro: BigInt(1000000000000),\n  finney: BigInt(1000000000000000),\n  milliether: BigInt(1000000000000000),\n  milli: BigInt(1000000000000000),\n  ether: BigInt('1000000000000000000'),\n  kether: BigInt('1000000000000000000000'),\n  grand: BigInt('1000000000000000000000'),\n  mether: BigInt('1000000000000000000000000'),\n  gether: BigInt('1000000000000000000000000000'),\n  tether: BigInt('1000000000000000000000000000000')\n};\n/**\n * Convert a value from bytes to Uint8Array\n * @param data - Data to be converted\n * @returns - The Uint8Array representation of the input data\n *\n * @example\n * ```ts\n * console.log(web3.utils.bytesToUint8Array(\"0xab\")));\n * > Uint8Array(1) [ 171 ]\n * ```\n */\n\nconst bytesToUint8Array = data => {\n  web3_validator_1.validator.validate(['bytes'], [data]);\n\n  if (data instanceof Uint8Array) {\n    return data;\n  }\n\n  if (Array.isArray(data)) {\n    return new Uint8Array(data);\n  }\n\n  if (typeof data === 'string') {\n    return web3_validator_1.utils.hexToUint8Array(data);\n  }\n\n  throw new web3_errors_1.InvalidBytesError(data);\n};\n\nexports.bytesToUint8Array = bytesToUint8Array;\n/**\n * @internal\n */\n\nconst {\n  uint8ArrayToHexString\n} = web3_validator_1.utils;\n/**\n * Convert a byte array to a hex string\n * @param bytes - Byte array to be converted\n * @returns - The hex string representation of the input byte array\n *\n * @example\n * ```ts\n * console.log(web3.utils.bytesToHex(new Uint8Array([72, 12])));\n * > \"0x480c\"\n *\n */\n\nconst bytesToHex = bytes => uint8ArrayToHexString((0, exports.bytesToUint8Array)(bytes));\n\nexports.bytesToHex = bytesToHex;\n/**\n * Convert a hex string to a byte array\n * @param hex - Hex string to be converted\n * @returns - The byte array representation of the input hex string\n *\n * @example\n * ```ts\n * console.log(web3.utils.hexToBytes('0x74657374'));\n * > Uint8Array(4) [ 116, 101, 115, 116 ]\n * ```\n */\n\nconst hexToBytes = bytes => {\n  if (typeof bytes === 'string' && bytes.slice(0, 2).toLowerCase() !== '0x') {\n    return (0, exports.bytesToUint8Array)(`0x${bytes}`);\n  }\n\n  return (0, exports.bytesToUint8Array)(bytes);\n};\n\nexports.hexToBytes = hexToBytes;\n/**\n * Converts value to it's number representation\n * @param value - Hex string to be converted\n * @returns - The number representation of the input value\n *\n * @example\n * ```ts\n * conoslle.log(web3.utils.hexToNumber('0xa'));\n * > 10\n * ```\n */\n\nconst hexToNumber = value => {\n  web3_validator_1.validator.validate(['hex'], [value]); // To avoid duplicate code and circular dependency we will\n  // use `hexToNumber` implementation from `web3-validator`\n\n  return web3_validator_1.utils.hexToNumber(value);\n};\n\nexports.hexToNumber = hexToNumber;\n/**\n * Converts value to it's number representation @alias `hexToNumber`\n */\n\nexports.toDecimal = exports.hexToNumber;\n/**\n * Converts value to it's hex representation\n * @param value - Value to be converted\n * @param hexstrict - Add padding to converted value if odd, to make it hexstrict\n * @returns - The hex representation of the input value\n *\n * @example\n * ```ts\n * console.log(web3.utils.numberToHex(10));\n * > \"0xa\"\n * ```\n */\n\nconst numberToHex = (value, hexstrict) => {\n  if (typeof value !== 'bigint') web3_validator_1.validator.validate(['int'], [value]); // To avoid duplicate code and circular dependency we will\n  // use `numberToHex` implementation from `web3-validator`\n\n  let updatedValue = web3_validator_1.utils.numberToHex(value);\n\n  if (hexstrict) {\n    if (!updatedValue.startsWith('-') && updatedValue.length % 2 === 1) {\n      // To avoid duplicate a circular dependancy we will not be using the padLeft method\n      updatedValue = '0x0'.concat(updatedValue.slice(2));\n    } else if (updatedValue.length % 2 === 0 && updatedValue.startsWith('-')) updatedValue = '-0x0'.concat(updatedValue.slice(3));\n  }\n\n  return updatedValue;\n};\n\nexports.numberToHex = numberToHex;\n/**\n * Converts value to it's hex representation @alias `numberToHex`\n *\n */\n\nexports.fromDecimal = exports.numberToHex;\n/**\n * Converts value to it's decimal representation in string\n * @param value - Hex string to be converted\n * @returns - The decimal representation of the input value\n *\n * @example\n * ```ts\n * console.log(web3.utils.hexToNumberString('0xa'));\n * > \"10\"\n * ```\n */\n\nconst hexToNumberString = data => (0, exports.hexToNumber)(data).toString();\n\nexports.hexToNumberString = hexToNumberString;\n/**\n * Should be called to get hex representation (prefixed by 0x) of utf8 string\n * @param str - Utf8 string to be converted\n * @returns - The hex representation of the input string\n *\n * @example\n * ```ts\n * console.log(utf8ToHex('web3.js'));\n * > \"0x776562332e6a73\"\n *\n */\n\nconst utf8ToHex = str => {\n  web3_validator_1.validator.validate(['string'], [str]); // To be compatible with 1.x trim null character\n  // eslint-disable-next-line no-control-regex\n\n  let strWithoutNullCharacter = str.replace(/^(?:\\u0000)/, ''); // eslint-disable-next-line no-control-regex\n\n  strWithoutNullCharacter = strWithoutNullCharacter.replace(/(?:\\u0000)$/, '');\n  return (0, exports.bytesToHex)(new TextEncoder().encode(strWithoutNullCharacter));\n};\n\nexports.utf8ToHex = utf8ToHex;\n/**\n * @alias utf8ToHex\n */\n\nexports.fromUtf8 = exports.utf8ToHex;\n/**\n * @alias utf8ToHex\n */\n\nexports.stringToHex = exports.utf8ToHex;\n/**\n * Should be called to get utf8 from it's hex representation\n * @param str - Hex string to be converted\n * @returns - Utf8 string\n *\n * @example\n * ```ts\n * console.log(web3.utils.hexToUtf8('0x48656c6c6f20576f726c64'));\n * > Hello World\n * ```\n */\n\nconst hexToUtf8 = str => (0, utils_js_1.bytesToUtf8)((0, exports.hexToBytes)(str));\n\nexports.hexToUtf8 = hexToUtf8;\n/**\n * @alias hexToUtf8\n */\n\nconst toUtf8 = input => {\n  if (typeof input === 'string') {\n    return (0, exports.hexToUtf8)(input);\n  }\n\n  web3_validator_1.validator.validate(['bytes'], [input]);\n  return (0, utils_js_1.bytesToUtf8)(input);\n};\n\nexports.toUtf8 = toUtf8;\nexports.utf8ToBytes = utils_js_1.utf8ToBytes;\n/**\n * @alias hexToUtf8\n */\n\nexports.hexToString = exports.hexToUtf8;\n/**\n * Should be called to get hex representation (prefixed by 0x) of ascii string\n * @param str - String to be converted to hex\n * @returns - Hex string\n *\n * @example\n * ```ts\n * console.log(web3.utils.asciiToHex('Hello World'));\n * > 0x48656c6c6f20576f726c64\n * ```\n */\n\nconst asciiToHex = str => {\n  web3_validator_1.validator.validate(['string'], [str]);\n  let hexString = '';\n\n  for (let i = 0; i < str.length; i += 1) {\n    const hexCharCode = str.charCodeAt(i).toString(16); // might need a leading 0\n\n    hexString += hexCharCode.length % 2 !== 0 ? `0${hexCharCode}` : hexCharCode;\n  }\n\n  return `0x${hexString}`;\n};\n\nexports.asciiToHex = asciiToHex;\n/**\n * @alias asciiToHex\n */\n\nexports.fromAscii = exports.asciiToHex;\n/**\n * Should be called to get ascii from it's hex representation\n * @param str - Hex string to be converted to ascii\n * @returns - Ascii string\n *\n * @example\n * ```ts\n * console.log(web3.utils.hexToAscii('0x48656c6c6f20576f726c64'));\n * > Hello World\n * ```\n */\n\nconst hexToAscii = str => {\n  const decoder = new TextDecoder('ascii');\n  return decoder.decode((0, exports.hexToBytes)(str));\n};\n\nexports.hexToAscii = hexToAscii;\n/**\n * @alias hexToAscii\n */\n\nexports.toAscii = exports.hexToAscii;\n/**\n * Auto converts any given value into it's hex representation.\n * @param value - Value to be converted to hex\n * @param returnType - If true, it will return the type of the value\n *\n * @example\n * ```ts\n * console.log(web3.utils.toHex(10));\n * > 0xa\n *\n * console.log(web3.utils.toHex('0x123', true));\n * > bytes\n *```\n */\n\nconst toHex = (value, returnType) => {\n  if (typeof value === 'string' && (0, web3_validator_1.isAddress)(value)) {\n    return returnType ? 'address' : `0x${value.toLowerCase().replace(/^0x/i, '')}`;\n  }\n\n  if (typeof value === 'boolean') {\n    // eslint-disable-next-line no-nested-ternary\n    return returnType ? 'bool' : value ? '0x01' : '0x00';\n  }\n\n  if (typeof value === 'number') {\n    // eslint-disable-next-line no-nested-ternary\n    return returnType ? value < 0 ? 'int256' : 'uint256' : (0, exports.numberToHex)(value);\n  }\n\n  if (typeof value === 'bigint') {\n    return returnType ? 'bigint' : (0, exports.numberToHex)(value);\n  }\n\n  if (typeof value === 'object' && !!value) {\n    return returnType ? 'string' : (0, exports.utf8ToHex)(JSON.stringify(value));\n  }\n\n  if (typeof value === 'string') {\n    if (value.startsWith('-0x') || value.startsWith('-0X')) {\n      return returnType ? 'int256' : (0, exports.numberToHex)(value);\n    }\n\n    if ((0, web3_validator_1.isHexStrict)(value)) {\n      return returnType ? 'bytes' : value;\n    }\n\n    if ((0, web3_validator_1.isHex)(value) && !(0, web3_validator_1.isInt)(value)) {\n      return returnType ? 'bytes' : `0x${value}`;\n    }\n\n    if (!Number.isFinite(value)) {\n      return returnType ? 'string' : (0, exports.utf8ToHex)(value);\n    }\n  }\n\n  throw new web3_errors_1.HexProcessingError(value);\n};\n\nexports.toHex = toHex;\n/**\n * Converts any given value into it's number representation, if possible, else into it's bigint representation.\n * @param value - The value to convert\n * @returns - Returns the value in number or bigint representation\n *\n * @example\n * ```ts\n * console.log(web3.utils.toNumber(1));\n * > 1\n * console.log(web3.utils.toNumber(Number.MAX_SAFE_INTEGER));\n * > 9007199254740991\n *\n * console.log(web3.utils.toNumber(BigInt(Number.MAX_SAFE_INTEGER)));\n * > 9007199254740991\n *\n * console.log(web3.utils.toNumber(BigInt(Number.MAX_SAFE_INTEGER) + BigInt(1)));\n * > 9007199254740992n\n *\n * ```\n */\n\nconst toNumber = value => {\n  if (typeof value === 'number') {\n    return value;\n  }\n\n  if (typeof value === 'bigint') {\n    return value >= Number.MIN_SAFE_INTEGER && value <= Number.MAX_SAFE_INTEGER ? Number(value) : value;\n  }\n\n  if (typeof value === 'string' && (0, web3_validator_1.isHexStrict)(value)) {\n    return (0, exports.hexToNumber)(value);\n  }\n\n  try {\n    return (0, exports.toNumber)(BigInt(value));\n  } catch (_a) {\n    throw new web3_errors_1.InvalidNumberError(value);\n  }\n};\n\nexports.toNumber = toNumber;\n/**\n * Auto converts any given value into it's bigint representation\n *\n * @param value - The value to convert\n * @returns - Returns the value in bigint representation\n\n * @example\n * ```ts\n * console.log(web3.utils.toBigInt(1));\n * > 1n\n * ```\n */\n\nconst toBigInt = value => {\n  if (typeof value === 'number') {\n    return BigInt(value);\n  }\n\n  if (typeof value === 'bigint') {\n    return value;\n  } // isHex passes for dec, too\n\n\n  if (typeof value === 'string' && (0, web3_validator_1.isHex)(value)) {\n    if (value.startsWith('-')) {\n      return -BigInt(value.substring(1));\n    }\n\n    return BigInt(value);\n  }\n\n  throw new web3_errors_1.InvalidNumberError(value);\n};\n\nexports.toBigInt = toBigInt;\n/**\n * Takes a number of wei and converts it to any other ether unit.\n * @param number - The value in wei\n * @param unit - The unit to convert to\n * @returns - Returns the converted value in the given unit\n *\n * @example\n * ```ts\n * console.log(web3.utils.fromWei(\"1\", \"ether\"));\n * > 0.000000000000000001\n *\n * console.log(web3.utils.fromWei(\"1\", \"shannon\"));\n * > 0.000000001\n * ```\n */\n\nconst fromWei = (number, unit) => {\n  const denomination = exports.ethUnitMap[unit];\n\n  if (!denomination) {\n    throw new web3_errors_1.InvalidUnitError(unit);\n  } // value in wei would always be integer\n  // 13456789, 1234\n\n\n  const value = String((0, exports.toNumber)(number)); // count number of zeros in denomination\n  // 1000000 -> 6\n\n  const numberOfZerosInDenomination = denomination.toString().length - 1;\n\n  if (numberOfZerosInDenomination <= 0) {\n    return value.toString();\n  } // pad the value with required zeros\n  // 13456789 -> 13456789, 1234 -> 001234\n\n\n  const zeroPaddedValue = value.padStart(numberOfZerosInDenomination, '0'); // get the integer part of value by counting number of zeros from start\n  // 13456789 -> '13'\n  // 001234 -> ''\n\n  const integer = zeroPaddedValue.slice(0, -numberOfZerosInDenomination); // get the fraction part of value by counting number of zeros backward\n  // 13456789 -> '456789'\n  // 001234 -> '001234'\n\n  const fraction = zeroPaddedValue.slice(-numberOfZerosInDenomination).replace(/\\.?0+$/, '');\n\n  if (integer === '') {\n    return `0.${fraction}`;\n  }\n\n  if (fraction === '') {\n    return integer;\n  }\n\n  return `${integer}.${fraction}`;\n};\n\nexports.fromWei = fromWei;\n/**\n * Takes a number of a unit and converts it to wei.\n *\n * @param number - The number to convert.\n * @param unit - {@link EtherUnits} The unit of the number passed.\n * @returns The number converted to wei.\n *\n * @example\n * ```ts\n * console.log(web3.utils.toWei(\"0.001\", \"ether\"));\n * > 1000000000000000 //(wei)\n * ```\n */\n// todo in 1.x unit defaults to 'ether'\n\nconst toWei = (number, unit) => {\n  web3_validator_1.validator.validate(['number'], [number]);\n  const denomination = exports.ethUnitMap[unit];\n\n  if (!denomination) {\n    throw new web3_errors_1.InvalidUnitError(unit);\n  } // if value is decimal e.g. 24.56 extract `integer` and `fraction` part\n  // to avoid `fraction` to be null use `concat` with empty string\n\n\n  const [integer, fraction] = String(typeof number === 'string' && !(0, web3_validator_1.isHexStrict)(number) ? number : (0, exports.toNumber)(number)).split('.').concat(''); // join the value removing `.` from\n  // 24.56 -> 2456\n\n  const value = BigInt(`${integer}${fraction}`); // multiply value with denomination\n  // 2456 * 1000000 -> 2456000000\n\n  const updatedValue = value * denomination; // count number of zeros in denomination\n\n  const numberOfZerosInDenomination = denomination.toString().length - 1; // check which either `fraction` or `denomination` have lower number of zeros\n\n  const decimals = Math.min(fraction.length, numberOfZerosInDenomination);\n\n  if (decimals === 0) {\n    return updatedValue.toString();\n  } // Add zeros to make length equal to required decimal points\n  // If string is larger than decimal points required then remove last zeros\n\n\n  return updatedValue.toString().padStart(decimals, '0').slice(0, -decimals);\n};\n\nexports.toWei = toWei;\n/**\n * Will convert an upper or lowercase Ethereum address to a checksum address.\n * @param address - An address string\n * @returns\tThe checksum address\n * @example\n * ```ts\n * web3.utils.toChecksumAddress('0xc1912fee45d61c87cc5ea59dae31190fffff232d');\n * > \"0xc1912fEE45d61C87Cc5EA59DaE31190FFFFf232d\"\n * ```\n */\n\nconst toChecksumAddress = address => {\n  if (!(0, web3_validator_1.isAddress)(address, false)) {\n    throw new web3_errors_1.InvalidAddressError(address);\n  }\n\n  const lowerCaseAddress = address.toLowerCase().replace(/^0x/i, '');\n  const hash = web3_validator_1.utils.uint8ArrayToHexString((0, keccak_js_1.keccak256)((0, exports.utf8ToBytes)(lowerCaseAddress)));\n  if ((0, web3_validator_1.isNullish)(hash) || hash === '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470') return ''; // // EIP-1052 if hash is equal to c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470, keccak was given empty data\n\n  let checksumAddress = '0x';\n  const addressHash = hash.replace(/^0x/i, '');\n\n  for (let i = 0; i < lowerCaseAddress.length; i += 1) {\n    // If ith character is 8 to f then make it uppercase\n    if (parseInt(addressHash[i], 16) > 7) {\n      checksumAddress += lowerCaseAddress[i].toUpperCase();\n    } else {\n      checksumAddress += lowerCaseAddress[i];\n    }\n  }\n\n  return checksumAddress;\n};\n\nexports.toChecksumAddress = toChecksumAddress;\n\nconst toBool = value => {\n  if (typeof value === 'boolean') {\n    return value;\n  }\n\n  if (typeof value === 'number' && (value === 0 || value === 1)) {\n    return Boolean(value);\n  }\n\n  if (typeof value === 'bigint' && (value === BigInt(0) || value === BigInt(1))) {\n    return Boolean(value);\n  }\n\n  if (typeof value === 'string' && !(0, web3_validator_1.isHexStrict)(value) && (value === '1' || value === '0' || value === 'false' || value === 'true')) {\n    if (value === 'true') {\n      return true;\n    }\n\n    if (value === 'false') {\n      return false;\n    }\n\n    return Boolean(Number(value));\n  }\n\n  if (typeof value === 'string' && (0, web3_validator_1.isHexStrict)(value) && (value === '0x1' || value === '0x0')) {\n    return Boolean((0, exports.toNumber)(value));\n  }\n\n  throw new web3_errors_1.InvalidBooleanError(value);\n};\n\nexports.toBool = toBool;","map":{"version":3,"mappings":"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","names":["exports","noether","BigInt","wei","kwei","Kwei","babbage","femtoether","mwei","Mwei","lovelace","picoether","gwei","Gwei","shannon","nanoether","nano","szabo","microether","micro","finney","milliether","milli","ether","kether","grand","mether","gether","tether","bytesToUint8Array","data","web3_validator_1","validate","Uint8Array","Array","isArray","hexToUint8Array","web3_errors_1","uint8ArrayToHexString","bytesToHex","bytes","hexToBytes","slice","toLowerCase","hexToNumber","value","numberToHex","hexstrict","updatedValue","startsWith","length","concat","hexToNumberString","toString","utf8ToHex","str","strWithoutNullCharacter","replace","TextEncoder","encode","hexToUtf8","toUtf8","input","utils_js_1","asciiToHex","hexString","i","hexCharCode","charCodeAt","hexToAscii","decoder","TextDecoder","decode","toHex","returnType","JSON","stringify","Number","isFinite","toNumber","MIN_SAFE_INTEGER","MAX_SAFE_INTEGER","toBigInt","substring","fromWei","number","unit","denomination","String","numberOfZerosInDenomination","zeroPaddedValue","padStart","integer","fraction","toWei","split","decimals","Math","min","toChecksumAddress","address","lowerCaseAddress","hash","checksumAddress","addressHash","parseInt","toUpperCase","toBool","Boolean"],"sources":["/home/rupam/Desktop/Faucet-React/node_modules/web3-utils/src/converters.ts"],"sourcesContent":["﻿/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport { keccak256 } from 'ethereum-cryptography/keccak.js';\nimport { bytesToUtf8, utf8ToBytes as ecUtf8ToBytes } from 'ethereum-cryptography/utils.js';\nimport { Address, Bytes, HexString, Numbers, ValueTypes } from 'web3-types';\nimport {\n\tisAddress,\n\tisHex,\n\tisHexStrict,\n\tisInt,\n\tisNullish,\n\tutils,\n\tutils as validatorUtils,\n\tvalidator,\n} from 'web3-validator';\n\nimport {\n\tHexProcessingError,\n\tInvalidAddressError,\n\tInvalidBooleanError,\n\tInvalidBytesError,\n\tInvalidNumberError,\n\tInvalidUnitError,\n} from 'web3-errors';\n\n// Ref: https://ethdocs.org/en/latest/ether.html\n// Note: this could be simplified using ** operator, but babel does not handle it well (https://github.com/babel/babel/issues/13109)\n/** @internal */\nexport const ethUnitMap = {\n\tnoether: BigInt(0),\n\twei: BigInt(1),\n\tkwei: BigInt(1000),\n\tKwei: BigInt(1000),\n\tbabbage: BigInt(1000),\n\tfemtoether: BigInt(1000),\n\tmwei: BigInt(1000000),\n\tMwei: BigInt(1000000),\n\tlovelace: BigInt(1000000),\n\tpicoether: BigInt(1000000),\n\tgwei: BigInt(1000000000),\n\tGwei: BigInt(1000000000),\n\tshannon: BigInt(1000000000),\n\tnanoether: BigInt(1000000000),\n\tnano: BigInt(1000000000),\n\tszabo: BigInt(1000000000000),\n\tmicroether: BigInt(1000000000000),\n\tmicro: BigInt(1000000000000),\n\tfinney: BigInt(1000000000000000),\n\tmilliether: BigInt(1000000000000000),\n\tmilli: BigInt(1000000000000000),\n\tether: BigInt('1000000000000000000'),\n\tkether: BigInt('1000000000000000000000'),\n\tgrand: BigInt('1000000000000000000000'),\n\tmether: BigInt('1000000000000000000000000'),\n\tgether: BigInt('1000000000000000000000000000'),\n\ttether: BigInt('1000000000000000000000000000000'),\n};\n\nexport type EtherUnits = keyof typeof ethUnitMap;\n/**\n * Convert a value from bytes to Uint8Array\n * @param data - Data to be converted\n * @returns - The Uint8Array representation of the input data\n *\n * @example\n * ```ts\n * console.log(web3.utils.bytesToUint8Array(\"0xab\")));\n * > Uint8Array(1) [ 171 ]\n * ```\n */\nexport const bytesToUint8Array = (data: Bytes): Uint8Array | never => {\n\tvalidator.validate(['bytes'], [data]);\n\n\tif (data instanceof Uint8Array) {\n\t\treturn data;\n\t}\n\n\tif (Array.isArray(data)) {\n\t\treturn new Uint8Array(data);\n\t}\n\n\tif (typeof data === 'string') {\n\t\treturn validatorUtils.hexToUint8Array(data);\n\t}\n\n\tthrow new InvalidBytesError(data);\n};\n\n/**\n * @internal\n */\nconst { uint8ArrayToHexString } = validatorUtils;\n\n/**\n * Convert a byte array to a hex string\n * @param bytes - Byte array to be converted\n * @returns - The hex string representation of the input byte array\n *\n * @example\n * ```ts\n * console.log(web3.utils.bytesToHex(new Uint8Array([72, 12])));\n * > \"0x480c\"\n *\n */\nexport const bytesToHex = (bytes: Bytes): HexString =>\n\tuint8ArrayToHexString(bytesToUint8Array(bytes));\n\n/**\n * Convert a hex string to a byte array\n * @param hex - Hex string to be converted\n * @returns - The byte array representation of the input hex string\n *\n * @example\n * ```ts\n * console.log(web3.utils.hexToBytes('0x74657374'));\n * > Uint8Array(4) [ 116, 101, 115, 116 ]\n * ```\n */\nexport const hexToBytes = (bytes: HexString): Uint8Array => {\n\tif (typeof bytes === 'string' && bytes.slice(0, 2).toLowerCase() !== '0x') {\n\t\treturn bytesToUint8Array(`0x${bytes}`);\n\t}\n\treturn bytesToUint8Array(bytes);\n};\n\n/**\n * Converts value to it's number representation\n * @param value - Hex string to be converted\n * @returns - The number representation of the input value\n *\n * @example\n * ```ts\n * conoslle.log(web3.utils.hexToNumber('0xa'));\n * > 10\n * ```\n */\nexport const hexToNumber = (value: HexString): bigint | number => {\n\tvalidator.validate(['hex'], [value]);\n\n\t// To avoid duplicate code and circular dependency we will\n\t// use `hexToNumber` implementation from `web3-validator`\n\treturn validatorUtils.hexToNumber(value);\n};\n\n/**\n * Converts value to it's number representation @alias `hexToNumber`\n */\nexport const toDecimal = hexToNumber;\n\n/**\n * Converts value to it's hex representation\n * @param value - Value to be converted\n * @param hexstrict - Add padding to converted value if odd, to make it hexstrict\n * @returns - The hex representation of the input value\n *\n * @example\n * ```ts\n * console.log(web3.utils.numberToHex(10));\n * > \"0xa\"\n * ```\n */\nexport const numberToHex = (value: Numbers, hexstrict?: boolean): HexString => {\n\tif (typeof value !== 'bigint') validator.validate(['int'], [value]);\n\t// To avoid duplicate code and circular dependency we will\n\t// use `numberToHex` implementation from `web3-validator`\n\tlet updatedValue = validatorUtils.numberToHex(value);\n\tif (hexstrict) {\n\t\tif (!updatedValue.startsWith('-') && updatedValue.length % 2 === 1) {\n\t\t\t// To avoid duplicate a circular dependancy we will not be using the padLeft method\n\t\t\tupdatedValue = '0x0'.concat(updatedValue.slice(2));\n\t\t} else if (updatedValue.length % 2 === 0 && updatedValue.startsWith('-'))\n\t\t\tupdatedValue = '-0x0'.concat(updatedValue.slice(3));\n\t}\n\treturn updatedValue;\n};\n/**\n * Converts value to it's hex representation @alias `numberToHex`\n *\n */\nexport const fromDecimal = numberToHex;\n\n/**\n * Converts value to it's decimal representation in string\n * @param value - Hex string to be converted\n * @returns - The decimal representation of the input value\n *\n * @example\n * ```ts\n * console.log(web3.utils.hexToNumberString('0xa'));\n * > \"10\"\n * ```\n */\nexport const hexToNumberString = (data: HexString): string => hexToNumber(data).toString();\n\n/**\n * Should be called to get hex representation (prefixed by 0x) of utf8 string\n * @param str - Utf8 string to be converted\n * @returns - The hex representation of the input string\n *\n * @example\n * ```ts\n * console.log(utf8ToHex('web3.js'));\n * > \"0x776562332e6a73\"\n *\n */\nexport const utf8ToHex = (str: string): HexString => {\n\tvalidator.validate(['string'], [str]);\n\n\t// To be compatible with 1.x trim null character\n\t// eslint-disable-next-line no-control-regex\n\tlet strWithoutNullCharacter = str.replace(/^(?:\\u0000)/, '');\n\t// eslint-disable-next-line no-control-regex\n\tstrWithoutNullCharacter = strWithoutNullCharacter.replace(/(?:\\u0000)$/, '');\n\n\treturn bytesToHex(new TextEncoder().encode(strWithoutNullCharacter));\n};\n\n/**\n * @alias utf8ToHex\n */\n\nexport const fromUtf8 = utf8ToHex;\n/**\n * @alias utf8ToHex\n */\nexport const stringToHex = utf8ToHex;\n\n/**\n * Should be called to get utf8 from it's hex representation\n * @param str - Hex string to be converted\n * @returns - Utf8 string\n *\n * @example\n * ```ts\n * console.log(web3.utils.hexToUtf8('0x48656c6c6f20576f726c64'));\n * > Hello World\n * ```\n */\nexport const hexToUtf8 = (str: HexString): string => bytesToUtf8(hexToBytes(str));\n\n/**\n * @alias hexToUtf8\n */\nexport const toUtf8 = (input: HexString | Uint8Array) => {\n\tif (typeof input === 'string') {\n\t\treturn hexToUtf8(input);\n\t}\n\tvalidator.validate(['bytes'], [input]);\n\treturn bytesToUtf8(input);\n};\n\nexport const utf8ToBytes = ecUtf8ToBytes;\n\n/**\n * @alias hexToUtf8\n */\nexport const hexToString = hexToUtf8;\n\n/**\n * Should be called to get hex representation (prefixed by 0x) of ascii string\n * @param str - String to be converted to hex\n * @returns - Hex string\n *\n * @example\n * ```ts\n * console.log(web3.utils.asciiToHex('Hello World'));\n * > 0x48656c6c6f20576f726c64\n * ```\n */\nexport const asciiToHex = (str: string): HexString => {\n\tvalidator.validate(['string'], [str]);\n\tlet hexString = '';\n\tfor (let i = 0; i < str.length; i += 1) {\n\t\tconst hexCharCode = str.charCodeAt(i).toString(16);\n\t\t// might need a leading 0\n\t\thexString += hexCharCode.length % 2 !== 0 ? `0${hexCharCode}` : hexCharCode;\n\t}\n\treturn `0x${hexString}`;\n};\n\n/**\n * @alias asciiToHex\n */\nexport const fromAscii = asciiToHex;\n\n/**\n * Should be called to get ascii from it's hex representation\n * @param str - Hex string to be converted to ascii\n * @returns - Ascii string\n *\n * @example\n * ```ts\n * console.log(web3.utils.hexToAscii('0x48656c6c6f20576f726c64'));\n * > Hello World\n * ```\n */\nexport const hexToAscii = (str: HexString): string => {\n\tconst decoder = new TextDecoder('ascii');\n\treturn decoder.decode(hexToBytes(str));\n};\n\n/**\n * @alias hexToAscii\n */\nexport const toAscii = hexToAscii;\n\n/**\n * Auto converts any given value into it's hex representation.\n * @param value - Value to be converted to hex\n * @param returnType - If true, it will return the type of the value\n *\n * @example\n * ```ts\n * console.log(web3.utils.toHex(10));\n * > 0xa\n *\n * console.log(web3.utils.toHex('0x123', true));\n * > bytes\n *```\n */\nexport const toHex = (\n\tvalue: Numbers | Bytes | Address | boolean | object,\n\treturnType?: boolean,\n): HexString | ValueTypes => {\n\tif (typeof value === 'string' && isAddress(value)) {\n\t\treturn returnType ? 'address' : `0x${value.toLowerCase().replace(/^0x/i, '')}`;\n\t}\n\n\tif (typeof value === 'boolean') {\n\t\t// eslint-disable-next-line no-nested-ternary\n\t\treturn returnType ? 'bool' : value ? '0x01' : '0x00';\n\t}\n\n\tif (typeof value === 'number') {\n\t\t// eslint-disable-next-line no-nested-ternary\n\t\treturn returnType ? (value < 0 ? 'int256' : 'uint256') : numberToHex(value);\n\t}\n\n\tif (typeof value === 'bigint') {\n\t\treturn returnType ? 'bigint' : numberToHex(value);\n\t}\n\n\tif (typeof value === 'object' && !!value) {\n\t\treturn returnType ? 'string' : utf8ToHex(JSON.stringify(value));\n\t}\n\n\tif (typeof value === 'string') {\n\t\tif (value.startsWith('-0x') || value.startsWith('-0X')) {\n\t\t\treturn returnType ? 'int256' : numberToHex(value);\n\t\t}\n\n\t\tif (isHexStrict(value)) {\n\t\t\treturn returnType ? 'bytes' : value;\n\t\t}\n\t\tif (isHex(value) && !isInt(value)) {\n\t\t\treturn returnType ? 'bytes' : `0x${value}`;\n\t\t}\n\n\t\tif (!Number.isFinite(value)) {\n\t\t\treturn returnType ? 'string' : utf8ToHex(value);\n\t\t}\n\t}\n\n\tthrow new HexProcessingError(value);\n};\n\n/**\n * Converts any given value into it's number representation, if possible, else into it's bigint representation.\n * @param value - The value to convert\n * @returns - Returns the value in number or bigint representation\n *\n * @example\n * ```ts\n * console.log(web3.utils.toNumber(1));\n * > 1\n * console.log(web3.utils.toNumber(Number.MAX_SAFE_INTEGER));\n * > 9007199254740991\n *\n * console.log(web3.utils.toNumber(BigInt(Number.MAX_SAFE_INTEGER)));\n * > 9007199254740991\n *\n * console.log(web3.utils.toNumber(BigInt(Number.MAX_SAFE_INTEGER) + BigInt(1)));\n * > 9007199254740992n\n *\n * ```\n */\nexport const toNumber = (value: Numbers): number | bigint => {\n\tif (typeof value === 'number') {\n\t\treturn value;\n\t}\n\n\tif (typeof value === 'bigint') {\n\t\treturn value >= Number.MIN_SAFE_INTEGER && value <= Number.MAX_SAFE_INTEGER\n\t\t\t? Number(value)\n\t\t\t: value;\n\t}\n\n\tif (typeof value === 'string' && isHexStrict(value)) {\n\t\treturn hexToNumber(value);\n\t}\n\n\ttry {\n\t\treturn toNumber(BigInt(value));\n\t} catch {\n\t\tthrow new InvalidNumberError(value);\n\t}\n};\n\n/**\n * Auto converts any given value into it's bigint representation\n *\n * @param value - The value to convert\n * @returns - Returns the value in bigint representation\n\n * @example\n * ```ts\n * console.log(web3.utils.toBigInt(1));\n * > 1n\n * ```\n */\nexport const toBigInt = (value: unknown): bigint => {\n\tif (typeof value === 'number') {\n\t\treturn BigInt(value);\n\t}\n\n\tif (typeof value === 'bigint') {\n\t\treturn value;\n\t}\n\n\t// isHex passes for dec, too\n\tif (typeof value === 'string' && isHex(value)) {\n\t\tif (value.startsWith('-')) {\n\t\t\treturn -BigInt(value.substring(1));\n\t\t}\n\t\treturn BigInt(value);\n\t}\n\n\tthrow new InvalidNumberError(value);\n};\n\n/**\n * Takes a number of wei and converts it to any other ether unit.\n * @param number - The value in wei\n * @param unit - The unit to convert to\n * @returns - Returns the converted value in the given unit\n *\n * @example\n * ```ts\n * console.log(web3.utils.fromWei(\"1\", \"ether\"));\n * > 0.000000000000000001\n *\n * console.log(web3.utils.fromWei(\"1\", \"shannon\"));\n * > 0.000000001\n * ```\n */\nexport const fromWei = (number: Numbers, unit: EtherUnits): string => {\n\tconst denomination = ethUnitMap[unit];\n\n\tif (!denomination) {\n\t\tthrow new InvalidUnitError(unit);\n\t}\n\n\t// value in wei would always be integer\n\t// 13456789, 1234\n\tconst value = String(toNumber(number));\n\n\t// count number of zeros in denomination\n\t// 1000000 -> 6\n\tconst numberOfZerosInDenomination = denomination.toString().length - 1;\n\n\tif (numberOfZerosInDenomination <= 0) {\n\t\treturn value.toString();\n\t}\n\n\t// pad the value with required zeros\n\t// 13456789 -> 13456789, 1234 -> 001234\n\tconst zeroPaddedValue = value.padStart(numberOfZerosInDenomination, '0');\n\n\t// get the integer part of value by counting number of zeros from start\n\t// 13456789 -> '13'\n\t// 001234 -> ''\n\tconst integer = zeroPaddedValue.slice(0, -numberOfZerosInDenomination);\n\n\t// get the fraction part of value by counting number of zeros backward\n\t// 13456789 -> '456789'\n\t// 001234 -> '001234'\n\tconst fraction = zeroPaddedValue.slice(-numberOfZerosInDenomination).replace(/\\.?0+$/, '');\n\n\tif (integer === '') {\n\t\treturn `0.${fraction}`;\n\t}\n\n\tif (fraction === '') {\n\t\treturn integer;\n\t}\n\n\treturn `${integer}.${fraction}`;\n};\n\n/**\n * Takes a number of a unit and converts it to wei.\n *\n * @param number - The number to convert.\n * @param unit - {@link EtherUnits} The unit of the number passed.\n * @returns The number converted to wei.\n *\n * @example\n * ```ts\n * console.log(web3.utils.toWei(\"0.001\", \"ether\"));\n * > 1000000000000000 //(wei)\n * ```\n */\n// todo in 1.x unit defaults to 'ether'\nexport const toWei = (number: Numbers, unit: EtherUnits): string => {\n\tvalidator.validate(['number'], [number]);\n\n\tconst denomination = ethUnitMap[unit];\n\n\tif (!denomination) {\n\t\tthrow new InvalidUnitError(unit);\n\t}\n\n\t// if value is decimal e.g. 24.56 extract `integer` and `fraction` part\n\t// to avoid `fraction` to be null use `concat` with empty string\n\tconst [integer, fraction] = String(\n\t\ttypeof number === 'string' && !isHexStrict(number) ? number : toNumber(number),\n\t)\n\t\t.split('.')\n\t\t.concat('');\n\n\t// join the value removing `.` from\n\t// 24.56 -> 2456\n\tconst value = BigInt(`${integer}${fraction}`);\n\n\t// multiply value with denomination\n\t// 2456 * 1000000 -> 2456000000\n\tconst updatedValue = value * denomination;\n\n\t// count number of zeros in denomination\n\tconst numberOfZerosInDenomination = denomination.toString().length - 1;\n\n\t// check which either `fraction` or `denomination` have lower number of zeros\n\tconst decimals = Math.min(fraction.length, numberOfZerosInDenomination);\n\n\tif (decimals === 0) {\n\t\treturn updatedValue.toString();\n\t}\n\n\t// Add zeros to make length equal to required decimal points\n\t// If string is larger than decimal points required then remove last zeros\n\treturn updatedValue.toString().padStart(decimals, '0').slice(0, -decimals);\n};\n\n/**\n * Will convert an upper or lowercase Ethereum address to a checksum address.\n * @param address - An address string\n * @returns\tThe checksum address\n * @example\n * ```ts\n * web3.utils.toChecksumAddress('0xc1912fee45d61c87cc5ea59dae31190fffff232d');\n * > \"0xc1912fEE45d61C87Cc5EA59DaE31190FFFFf232d\"\n * ```\n */\nexport const toChecksumAddress = (address: Address): string => {\n\tif (!isAddress(address, false)) {\n\t\tthrow new InvalidAddressError(address);\n\t}\n\n\tconst lowerCaseAddress = address.toLowerCase().replace(/^0x/i, '');\n\n\tconst hash = utils.uint8ArrayToHexString(keccak256(utf8ToBytes(lowerCaseAddress)));\n\n\tif (\n\t\tisNullish(hash) ||\n\t\thash === '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470'\n\t)\n\t\treturn ''; // // EIP-1052 if hash is equal to c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470, keccak was given empty data\n\n\tlet checksumAddress = '0x';\n\n\tconst addressHash = hash.replace(/^0x/i, '');\n\n\tfor (let i = 0; i < lowerCaseAddress.length; i += 1) {\n\t\t// If ith character is 8 to f then make it uppercase\n\t\tif (parseInt(addressHash[i], 16) > 7) {\n\t\t\tchecksumAddress += lowerCaseAddress[i].toUpperCase();\n\t\t} else {\n\t\t\tchecksumAddress += lowerCaseAddress[i];\n\t\t}\n\t}\n\treturn checksumAddress;\n};\n\nexport const toBool = (value: boolean | string | number | unknown): boolean => {\n\tif (typeof value === 'boolean') {\n\t\treturn value;\n\t}\n\n\tif (typeof value === 'number' && (value === 0 || value === 1)) {\n\t\treturn Boolean(value);\n\t}\n\n\tif (typeof value === 'bigint' && (value === BigInt(0) || value === BigInt(1))) {\n\t\treturn Boolean(value);\n\t}\n\n\tif (\n\t\ttypeof value === 'string' &&\n\t\t!isHexStrict(value) &&\n\t\t(value === '1' || value === '0' || value === 'false' || value === 'true')\n\t) {\n\t\tif (value === 'true') {\n\t\t\treturn true;\n\t\t}\n\t\tif (value === 'false') {\n\t\t\treturn false;\n\t\t}\n\t\treturn Boolean(Number(value));\n\t}\n\n\tif (typeof value === 'string' && isHexStrict(value) && (value === '0x1' || value === '0x0')) {\n\t\treturn Boolean(toNumber(value));\n\t}\n\n\tthrow new InvalidBooleanError(value);\n};\n"]},"metadata":{},"sourceType":"script"}