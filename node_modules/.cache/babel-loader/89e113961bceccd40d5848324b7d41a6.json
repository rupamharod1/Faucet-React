{"ast":null,"code":"import { InvalidResponseError } from 'web3-errors';\nexport class ChunkResponseParser {\n  constructor(eventEmitter, autoReconnect) {\n    this.eventEmitter = eventEmitter;\n    this.autoReconnect = autoReconnect;\n  }\n\n  clearQueues() {\n    if (typeof this._clearQueues === 'function') {\n      this._clearQueues();\n    }\n  }\n\n  onError(clearQueues) {\n    this._clearQueues = clearQueues;\n  }\n\n  parseResponse(data) {\n    const returnValues = []; // DE-CHUNKER\n\n    const dechunkedData = data.replace(/\\}[\\n\\r]?\\{/g, '}|--|{') // }{\n    .replace(/\\}\\][\\n\\r]?\\[\\{/g, '}]|--|[{') // }][{\n    .replace(/\\}[\\n\\r]?\\[\\{/g, '}|--|[{') // }[{\n    .replace(/\\}\\][\\n\\r]?\\{/g, '}]|--|{') // }]{\n    .split('|--|');\n    dechunkedData.forEach(_chunkData => {\n      // prepend the last chunk\n      let chunkData = _chunkData;\n\n      if (this.lastChunk) {\n        chunkData = this.lastChunk + chunkData;\n      }\n\n      let result;\n\n      try {\n        result = JSON.parse(chunkData);\n      } catch (e) {\n        this.lastChunk = chunkData; // start timeout to cancel all requests\n\n        if (this.lastChunkTimeout) {\n          clearTimeout(this.lastChunkTimeout);\n        }\n\n        this.lastChunkTimeout = setTimeout(() => {\n          if (this.autoReconnect) return;\n          this.clearQueues();\n          this.eventEmitter.emit('error', new InvalidResponseError({\n            id: 1,\n            jsonrpc: '2.0',\n            error: {\n              code: 2,\n              message: 'Chunk timeout'\n            }\n          }));\n        }, 1000 * 15);\n        return;\n      } // cancel timeout and set chunk to null\n\n\n      clearTimeout(this.lastChunkTimeout);\n      this.lastChunk = undefined;\n      if (result) returnValues.push(result);\n    });\n    return returnValues;\n  }\n\n}","map":{"version":3,"mappings":"AAiBA,SAASA,oBAAT,QAAqC,aAArC;AAIA,OAAM,MAAOC,mBAAP,CAA0B;EAO/BC,YAAmBC,YAAnB,EAA+CC,aAA/C,EAAqE;IACpE,KAAKD,YAAL,GAAoBA,YAApB;IACA,KAAKC,aAAL,GAAqBA,aAArB;EACA;;EACOC,WAAW;IAClB,IAAI,OAAO,KAAKC,YAAZ,KAA6B,UAAjC,EAA6C;MAC5C,KAAKA,YAAL;IACA;EACD;;EAEMC,OAAO,CAACF,WAAD,EAAyB;IACtC,KAAKC,YAAL,GAAoBD,WAApB;EACA;;EAEMG,aAAa,CAACC,IAAD,EAAa;IAChC,MAAMC,YAAY,GAAsB,EAAxC,CADgC,CAGhC;;IACA,MAAMC,aAAa,GAAGF,IAAI,CACxBG,OADoB,CACZ,cADY,EACI,QADJ,EACc;IADd,CAEpBA,OAFoB,CAEZ,kBAFY,EAEQ,UAFR,EAEoB;IAFpB,CAGpBA,OAHoB,CAGZ,gBAHY,EAGM,SAHN,EAGiB;IAHjB,CAIpBA,OAJoB,CAIZ,gBAJY,EAIM,SAJN,EAIiB;IAJjB,CAKpBC,KALoB,CAKd,MALc,CAAtB;IAOAF,aAAa,CAACG,OAAd,CAAsBC,UAAU,IAAG;MAClC;MACA,IAAIC,SAAS,GAAGD,UAAhB;;MACA,IAAI,KAAKE,SAAT,EAAoB;QACnBD,SAAS,GAAG,KAAKC,SAAL,GAAiBD,SAA7B;MACA;;MAED,IAAIE,MAAJ;;MAEA,IAAI;QACHA,MAAM,GAAGC,IAAI,CAACC,KAAL,CAAWJ,SAAX,CAAT;MACA,CAFD,CAEE,OAAOK,CAAP,EAAU;QACX,KAAKJ,SAAL,GAAiBD,SAAjB,CADW,CAGX;;QACA,IAAI,KAAKM,gBAAT,EAA2B;UAC1BC,YAAY,CAAC,KAAKD,gBAAN,CAAZ;QACA;;QAED,KAAKA,gBAAL,GAAwBE,UAAU,CAAC,MAAK;UACvC,IAAI,KAAKpB,aAAT,EAAwB;UACxB,KAAKC,WAAL;UACA,KAAKF,YAAL,CAAkBsB,IAAlB,CACC,OADD,EAEC,IAAIzB,oBAAJ,CAAyB;YACxB0B,EAAE,EAAE,CADoB;YAExBC,OAAO,EAAE,KAFe;YAGxBC,KAAK,EAAE;cAAEC,IAAI,EAAE,CAAR;cAAWC,OAAO,EAAE;YAApB;UAHiB,CAAzB,CAFD;QAQA,CAXiC,EAW/B,OAAO,EAXwB,CAAlC;QAYA;MACA,CAhCiC,CAkClC;;;MACAP,YAAY,CAAC,KAAKD,gBAAN,CAAZ;MACA,KAAKL,SAAL,GAAiBc,SAAjB;MAEA,IAAIb,MAAJ,EAAYR,YAAY,CAACsB,IAAb,CAAkBd,MAAlB;IACZ,CAvCD;IAyCA,OAAOR,YAAP;EACA;;AA1E8B","names":["InvalidResponseError","ChunkResponseParser","constructor","eventEmitter","autoReconnect","clearQueues","_clearQueues","onError","parseResponse","data","returnValues","dechunkedData","replace","split","forEach","_chunkData","chunkData","lastChunk","result","JSON","parse","e","lastChunkTimeout","clearTimeout","setTimeout","emit","id","jsonrpc","error","code","message","undefined","push"],"sources":["/home/rupam/Desktop/Faucet-React/node_modules/web3-utils/src/chunk_response_parser.ts"],"sourcesContent":["/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { JsonRpcResponse } from 'web3-types';\nimport { InvalidResponseError } from 'web3-errors';\nimport { EventEmitter } from 'events';\nimport { Timeout } from './promise_helpers.js';\n\nexport class ChunkResponseParser {\n\tprivate lastChunk: string | undefined;\n\tprivate lastChunkTimeout: Timeout | undefined;\n\tprivate _clearQueues: (() => void) | undefined;\n\tprivate readonly eventEmitter: EventEmitter;\n\tprivate readonly autoReconnect: boolean;\n\n\tpublic constructor(eventEmitter: EventEmitter, autoReconnect: boolean) {\n\t\tthis.eventEmitter = eventEmitter;\n\t\tthis.autoReconnect = autoReconnect;\n\t}\n\tprivate clearQueues(): void {\n\t\tif (typeof this._clearQueues === 'function') {\n\t\t\tthis._clearQueues();\n\t\t}\n\t}\n\n\tpublic onError(clearQueues?: () => void) {\n\t\tthis._clearQueues = clearQueues;\n\t}\n\n\tpublic parseResponse(data: string): JsonRpcResponse[] {\n\t\tconst returnValues: JsonRpcResponse[] = [];\n\n\t\t// DE-CHUNKER\n\t\tconst dechunkedData = data\n\t\t\t.replace(/\\}[\\n\\r]?\\{/g, '}|--|{') // }{\n\t\t\t.replace(/\\}\\][\\n\\r]?\\[\\{/g, '}]|--|[{') // }][{\n\t\t\t.replace(/\\}[\\n\\r]?\\[\\{/g, '}|--|[{') // }[{\n\t\t\t.replace(/\\}\\][\\n\\r]?\\{/g, '}]|--|{') // }]{\n\t\t\t.split('|--|');\n\n\t\tdechunkedData.forEach(_chunkData => {\n\t\t\t// prepend the last chunk\n\t\t\tlet chunkData = _chunkData;\n\t\t\tif (this.lastChunk) {\n\t\t\t\tchunkData = this.lastChunk + chunkData;\n\t\t\t}\n\n\t\t\tlet result;\n\n\t\t\ttry {\n\t\t\t\tresult = JSON.parse(chunkData) as unknown as JsonRpcResponse;\n\t\t\t} catch (e) {\n\t\t\t\tthis.lastChunk = chunkData;\n\n\t\t\t\t// start timeout to cancel all requests\n\t\t\t\tif (this.lastChunkTimeout) {\n\t\t\t\t\tclearTimeout(this.lastChunkTimeout);\n\t\t\t\t}\n\n\t\t\t\tthis.lastChunkTimeout = setTimeout(() => {\n\t\t\t\t\tif (this.autoReconnect) return;\n\t\t\t\t\tthis.clearQueues();\n\t\t\t\t\tthis.eventEmitter.emit(\n\t\t\t\t\t\t'error',\n\t\t\t\t\t\tnew InvalidResponseError({\n\t\t\t\t\t\t\tid: 1,\n\t\t\t\t\t\t\tjsonrpc: '2.0',\n\t\t\t\t\t\t\terror: { code: 2, message: 'Chunk timeout' },\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t}, 1000 * 15);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// cancel timeout and set chunk to null\n\t\t\tclearTimeout(this.lastChunkTimeout);\n\t\t\tthis.lastChunk = undefined;\n\n\t\t\tif (result) returnValues.push(result);\n\t\t});\n\n\t\treturn returnValues;\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}