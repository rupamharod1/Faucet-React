{"ast":null,"code":"/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * checks input if typeof data is valid string input\n */\nexport const isString = value => typeof value === 'string';\nexport const isHexStrict = hex => typeof hex === 'string' && /^((-)?0x[0-9a-f]+|(0x))$/i.test(hex);\n/**\n * Is the string a hex string.\n *\n * @param  value\n * @param  length\n * @returns  output the string is a hex string\n */\n\nexport function isHexString(value, length) {\n  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) return false;\n  if (typeof length !== 'undefined' && length > 0 && value.length !== 2 + 2 * length) return false;\n  return true;\n}\nexport const isHex = hex => typeof hex === 'number' || typeof hex === 'bigint' || typeof hex === 'string' && /^((-0x|0x|-)?[0-9a-f]+|(0x))$/i.test(hex);\nexport const isHexString8Bytes = function (value) {\n  let prefixed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  return prefixed ? isHexStrict(value) && value.length === 18 : isHex(value) && value.length === 16;\n};\nexport const isHexString32Bytes = function (value) {\n  let prefixed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  return prefixed ? isHexStrict(value) && value.length === 66 : isHex(value) && value.length === 64;\n};\n/**\n * Returns a `Boolean` on whether or not the a `String` starts with '0x'\n * @param str the string input value\n * @return a boolean if it is or is not hex prefixed\n * @throws if the str input is not a string\n */\n\nexport function isHexPrefixed(str) {\n  if (typeof str !== 'string') {\n    throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof str}`);\n  }\n\n  return str.startsWith('0x');\n}\n/**\n * Checks provided Uint8Array for leading zeroes and throws if found.\n *\n * Examples:\n *\n * Valid values: 0x1, 0x, 0x01, 0x1234\n * Invalid values: 0x0, 0x00, 0x001, 0x0001\n *\n * Note: This method is useful for validating that RLP encoded integers comply with the rule that all\n * integer values encoded to RLP must be in the most compact form and contain no leading zero bytes\n * @param values An object containing string keys and Uint8Array values\n * @throws if any provided value is found to have leading zero bytes\n */\n\nexport const validateNoLeadingZeroes = function (values) {\n  for (const [k, v] of Object.entries(values)) {\n    if (v !== undefined && v.length > 0 && v[0] === 0) {\n      throw new Error(`${k} cannot have leading zeroes, received: ${v.toString()}`);\n    }\n  }\n};","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;;;AAmBA;;;AAGA,OAAO,MAAMA,QAAQ,GAAIC,KAAD,IAA4B,OAAOA,KAAP,KAAiB,QAA9D;AAEP,OAAO,MAAMC,WAAW,GAAIC,GAAD,IAC1B,OAAOA,GAAP,KAAe,QAAf,IAA2B,4BAA4BC,IAA5B,CAAiCD,GAAjC,CADrB;AAGP;;;;;;;;AAOA,OAAM,SAAUE,WAAV,CAAsBJ,KAAtB,EAAqCK,MAArC,EAAoD;EACzD,IAAI,OAAOL,KAAP,KAAiB,QAAjB,IAA6B,CAACA,KAAK,CAACM,KAAN,CAAY,kBAAZ,CAAlC,EAAmE,OAAO,KAAP;EAEnE,IAAI,OAAOD,MAAP,KAAkB,WAAlB,IAAiCA,MAAM,GAAG,CAA1C,IAA+CL,KAAK,CAACK,MAAN,KAAiB,IAAI,IAAIA,MAA5E,EACC,OAAO,KAAP;EAED,OAAO,IAAP;AACA;AAED,OAAO,MAAME,KAAK,GAAIL,GAAD,IACpB,OAAOA,GAAP,KAAe,QAAf,IACA,OAAOA,GAAP,KAAe,QADf,IAEC,OAAOA,GAAP,KAAe,QAAf,IAA2B,iCAAiCC,IAAjC,CAAsCD,GAAtC,CAHtB;AAKP,OAAO,MAAMM,iBAAiB,GAAG,UAACR,KAAD;EAAA,IAAgBS,QAAhB,uEAA2B,IAA3B;EAAA,OAChCA,QAAQ,GAAGR,WAAW,CAACD,KAAD,CAAX,IAAsBA,KAAK,CAACK,MAAN,KAAiB,EAA1C,GAA+CE,KAAK,CAACP,KAAD,CAAL,IAAgBA,KAAK,CAACK,MAAN,KAAiB,EADxD;AAAA,CAA1B;AAGP,OAAO,MAAMK,kBAAkB,GAAG,UAACV,KAAD;EAAA,IAAgBS,QAAhB,uEAA2B,IAA3B;EAAA,OACjCA,QAAQ,GAAGR,WAAW,CAACD,KAAD,CAAX,IAAsBA,KAAK,CAACK,MAAN,KAAiB,EAA1C,GAA+CE,KAAK,CAACP,KAAD,CAAL,IAAgBA,KAAK,CAACK,MAAN,KAAiB,EADvD;AAAA,CAA3B;AAGP;;;;;;;AAMA,OAAM,SAAUM,aAAV,CAAwBC,GAAxB,EAAmC;EACxC,IAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;IAC5B,MAAM,IAAIC,KAAJ,CAAU,8DAA8D,OAAOD,GAAG,EAAlF,CAAN;EACA;;EAED,OAAOA,GAAG,CAACE,UAAJ,CAAe,IAAf,CAAP;AACA;AAED;;;;;;;;;;;;;;AAaA,OAAO,MAAMC,uBAAuB,GAAG,UAAUC,MAAV,EAEtC;EACA,KAAK,MAAM,CAACC,CAAD,EAAIC,CAAJ,CAAX,IAAqBC,MAAM,CAACC,OAAP,CAAeJ,MAAf,CAArB,EAA6C;IAC5C,IAAIE,CAAC,KAAKG,SAAN,IAAmBH,CAAC,CAACb,MAAF,GAAW,CAA9B,IAAmCa,CAAC,CAAC,CAAD,CAAD,KAAS,CAAhD,EAAmD;MAClD,MAAM,IAAIL,KAAJ,CAAU,GAAGI,CAAC,0CAA0CC,CAAC,CAACI,QAAF,EAAY,EAApE,CAAN;IACA;EACD;AACD,CARM","names":["isString","value","isHexStrict","hex","test","isHexString","length","match","isHex","isHexString8Bytes","prefixed","isHexString32Bytes","isHexPrefixed","str","Error","startsWith","validateNoLeadingZeroes","values","k","v","Object","entries","undefined","toString"],"sources":["/home/rupam/Desktop/Faucet-React/node_modules/web3-validator/src/validation/string.ts"],"sourcesContent":["ï»¿/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport { ValidInputTypes } from '../types.js';\n\n/**\n * checks input if typeof data is valid string input\n */\nexport const isString = (value: ValidInputTypes) => typeof value === 'string';\n\nexport const isHexStrict = (hex: ValidInputTypes) =>\n\ttypeof hex === 'string' && /^((-)?0x[0-9a-f]+|(0x))$/i.test(hex);\n\n/**\n * Is the string a hex string.\n *\n * @param  value\n * @param  length\n * @returns  output the string is a hex string\n */\nexport function isHexString(value: string, length?: number): boolean {\n\tif (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) return false;\n\n\tif (typeof length !== 'undefined' && length > 0 && value.length !== 2 + 2 * length)\n\t\treturn false;\n\n\treturn true;\n}\n\nexport const isHex = (hex: ValidInputTypes): boolean =>\n\ttypeof hex === 'number' ||\n\ttypeof hex === 'bigint' ||\n\t(typeof hex === 'string' && /^((-0x|0x|-)?[0-9a-f]+|(0x))$/i.test(hex));\n\nexport const isHexString8Bytes = (value: string, prefixed = true) =>\n\tprefixed ? isHexStrict(value) && value.length === 18 : isHex(value) && value.length === 16;\n\nexport const isHexString32Bytes = (value: string, prefixed = true) =>\n\tprefixed ? isHexStrict(value) && value.length === 66 : isHex(value) && value.length === 64;\n\n/**\n * Returns a `Boolean` on whether or not the a `String` starts with '0x'\n * @param str the string input value\n * @return a boolean if it is or is not hex prefixed\n * @throws if the str input is not a string\n */\nexport function isHexPrefixed(str: string): boolean {\n\tif (typeof str !== 'string') {\n\t\tthrow new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof str}`);\n\t}\n\n\treturn str.startsWith('0x');\n}\n\n/**\n * Checks provided Uint8Array for leading zeroes and throws if found.\n *\n * Examples:\n *\n * Valid values: 0x1, 0x, 0x01, 0x1234\n * Invalid values: 0x0, 0x00, 0x001, 0x0001\n *\n * Note: This method is useful for validating that RLP encoded integers comply with the rule that all\n * integer values encoded to RLP must be in the most compact form and contain no leading zero bytes\n * @param values An object containing string keys and Uint8Array values\n * @throws if any provided value is found to have leading zero bytes\n */\nexport const validateNoLeadingZeroes = function (values: {\n\t[key: string]: Uint8Array | undefined;\n}) {\n\tfor (const [k, v] of Object.entries(values)) {\n\t\tif (v !== undefined && v.length > 0 && v[0] === 0) {\n\t\t\tthrow new Error(`${k} cannot have leading zeroes, received: ${v.toString()}`);\n\t\t}\n\t}\n};\n"]},"metadata":{},"sourceType":"module"}