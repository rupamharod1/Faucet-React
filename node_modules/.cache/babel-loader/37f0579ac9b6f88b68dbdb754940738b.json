{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = void 0;\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\n\nconst _0n = BigInt(0);\n\nconst _1n = BigInt(1);\n\nconst _2n = BigInt(2);\n\nconst u8a = a => a instanceof Uint8Array;\n\nconst hexes = Array.from({\n  length: 256\n}, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\n\nfunction bytesToHex(bytes) {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected'); // pre-caching improves the speed 6x\n\n  let hex = '';\n\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n\n  return hex;\n}\n\nexports.bytesToHex = bytesToHex;\n\nfunction numberToHexUnpadded(num) {\n  const hex = num.toString(16);\n  return hex.length & 1 ? `0${hex}` : hex;\n}\n\nexports.numberToHexUnpadded = numberToHexUnpadded;\n\nfunction hexToNumber(hex) {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex); // Big Endian\n\n  return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n\nexports.hexToNumber = hexToNumber;\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\n\nfunction hexToBytes(hex) {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const len = hex.length;\n  if (len % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n  const array = new Uint8Array(len / 2);\n\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n\n  return array;\n}\n\nexports.hexToBytes = hexToBytes; // BE: Big Endian, LE: Little Endian\n\nfunction bytesToNumberBE(bytes) {\n  return hexToNumber(bytesToHex(bytes));\n}\n\nexports.bytesToNumberBE = bytesToNumberBE;\n\nfunction bytesToNumberLE(bytes) {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\n\nexports.bytesToNumberLE = bytesToNumberLE;\n\nfunction numberToBytesBE(n, len) {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\n\nexports.numberToBytesBE = numberToBytesBE;\n\nfunction numberToBytesLE(n, len) {\n  return numberToBytesBE(n, len).reverse();\n}\n\nexports.numberToBytesLE = numberToBytesLE; // Unpadded, rarely used\n\nfunction numberToVarBytesBE(n) {\n  return hexToBytes(numberToHexUnpadded(n));\n}\n\nexports.numberToVarBytesBE = numberToVarBytesBE;\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\n\nfunction ensureBytes(title, hex, expectedLength) {\n  let res;\n\n  if (typeof hex === 'string') {\n    try {\n      res = hexToBytes(hex);\n    } catch (e) {\n      throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n    }\n  } else if (u8a(hex)) {\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n  } else {\n    throw new Error(`${title} must be hex string or Uint8Array`);\n  }\n\n  const len = res.length;\n  if (typeof expectedLength === 'number' && len !== expectedLength) throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n  return res;\n}\n\nexports.ensureBytes = ensureBytes;\n/**\n * Copies several Uint8Arrays into one.\n */\n\nfunction concatBytes() {\n  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {\n    arrays[_key] = arguments[_key];\n  }\n\n  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n  let pad = 0; // walk through each item, ensure they have proper type\n\n  arrays.forEach(a => {\n    if (!u8a(a)) throw new Error('Uint8Array expected');\n    r.set(a, pad);\n    pad += a.length;\n  });\n  return r;\n}\n\nexports.concatBytes = concatBytes;\n\nfunction equalBytes(b1, b2) {\n  // We don't care about timing attacks here\n  if (b1.length !== b2.length) return false;\n\n  for (let i = 0; i < b1.length; i++) if (b1[i] !== b2[i]) return false;\n\n  return true;\n}\n\nexports.equalBytes = equalBytes;\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\n\nfunction utf8ToBytes(str) {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\nexports.utf8ToBytes = utf8ToBytes; // Bit operations\n\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\n\nfunction bitLen(n) {\n  let len;\n\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n\n  return len;\n}\n\nexports.bitLen = bitLen;\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\n\nfunction bitGet(n, pos) {\n  return n >> BigInt(pos) & _1n;\n}\n\nexports.bitGet = bitGet;\n/**\n * Sets single bit at position.\n */\n\nconst bitSet = (n, pos, value) => {\n  return n | (value ? _1n : _0n) << BigInt(pos);\n};\n\nexports.bitSet = bitSet;\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\n\nconst bitMask = n => (_2n << BigInt(n - 1)) - _1n;\n\nexports.bitMask = bitMask; // DRBG\n\nconst u8n = data => new Uint8Array(data); // creates Uint8Array\n\n\nconst u8fr = arr => Uint8Array.from(arr); // another shortcut\n\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\n\n\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function'); // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n\n  let i = 0; // Iterations counter, will throw when over 1000\n\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n\n  const h = function () {\n    for (var _len2 = arguments.length, b = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      b[_key2] = arguments[_key2];\n    }\n\n    return hmacFn(k, v, ...b);\n  }; // hmac(k)(v, ...values)\n\n\n  const reseed = function () {\n    let seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : u8n();\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n\n    v = h(); // v = hmac(k || v)\n\n    if (seed.length === 0) return;\n    k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n\n    v = h(); // v = hmac(k || v)\n  };\n\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n    let len = 0;\n    const out = [];\n\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n\n    return concatBytes(...out);\n  };\n\n  const genUntil = (seed, pred) => {\n    reset();\n    reseed(seed); // Steps D-G\n\n    let res = undefined; // Step H: grind until k is in [1..n-1]\n\n    while (!(res = pred(gen()))) reseed();\n\n    reset();\n    return res;\n  };\n\n  return genUntil;\n}\n\nexports.createHmacDrbg = createHmacDrbg; // Validating curves and fields\n\nconst validatorFns = {\n  bigint: val => typeof val === 'bigint',\n  function: val => typeof val === 'function',\n  boolean: val => typeof val === 'boolean',\n  string: val => typeof val === 'string',\n  isSafeInteger: val => Number.isSafeInteger(val),\n  array: val => Array.isArray(val),\n  field: (val, object) => object.Fp.isValid(val),\n  hash: val => typeof val === 'function' && Number.isSafeInteger(val.outputLen)\n}; // type Record<K extends string | number | symbol, T> = { [P in K]: T; }\n\nfunction validateObject(object, validators) {\n  let optValidators = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  const checkField = (fieldName, type, isOptional) => {\n    const checkVal = validatorFns[type];\n    if (typeof checkVal !== 'function') throw new Error(`Invalid validator \"${type}\", expected function`);\n    const val = object[fieldName];\n    if (isOptional && val === undefined) return;\n\n    if (!checkVal(val, object)) {\n      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n    }\n  };\n\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type, false);\n\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type, true);\n\n  return object;\n}\n\nexports.validateObject = validateObject; // validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });","map":{"version":3,"mappings":"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","names":["_0n","BigInt","_1n","_2n","u8a","a","Uint8Array","hexes","Array","from","length","v","i","toString","padStart","bytesToHex","bytes","Error","hex","exports","numberToHexUnpadded","num","hexToNumber","hexToBytes","len","array","j","hexByte","slice","byte","Number","parseInt","isNaN","bytesToNumberBE","bytesToNumberLE","reverse","numberToBytesBE","n","numberToBytesLE","numberToVarBytesBE","ensureBytes","title","expectedLength","res","e","concatBytes","arrays","r","reduce","sum","pad","forEach","set","equalBytes","b1","b2","utf8ToBytes","str","TextEncoder","encode","bitLen","bitGet","pos","bitSet","value","bitMask","u8n","data","u8fr","arr","createHmacDrbg","hashLen","qByteLen","hmacFn","k","reset","fill","h","b","reseed","seed","gen","out","sl","push","genUntil","pred","undefined","validatorFns","bigint","val","function","boolean","string","isSafeInteger","isArray","field","object","Fp","isValid","hash","outputLen","validateObject","validators","optValidators","checkField","fieldName","type","isOptional","checkVal","String","Object","entries"],"sources":["/home/rupam/Desktop/Faucet-React/node_modules/@noble/curves/src/abstract/utils.ts"],"sourcesContent":["/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst u8a = (a: any): a is Uint8Array => a instanceof Uint8Array;\nexport type Hex = Uint8Array | string; // hex strings are accepted for simplicity\nexport type PrivKey = Hex | bigint; // bigints are accepted to ease learning curve\nexport type CHash = {\n  (message: Uint8Array | string): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create(opts?: { dkLen?: number }): any; // For shake\n};\nexport type FHash = (message: Uint8Array | string) => Uint8Array;\n\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\nexport function numberToHexUnpadded(num: number | bigint): string {\n  const hex = num.toString(16);\n  return hex.length & 1 ? `0${hex}` : hex;\n}\n\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // Big Endian\n  return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const len = hex.length;\n  if (len % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n  const array = new Uint8Array(len / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\n\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex(bytes));\n}\nexport function bytesToNumberLE(bytes: Uint8Array): bigint {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\n\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n: number | bigint, len: number): Uint8Array {\n  return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n: number | bigint): Uint8Array {\n  return hexToBytes(numberToHexUnpadded(n));\n}\n\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title: string, hex: Hex, expectedLength?: number): Uint8Array {\n  let res: Uint8Array;\n  if (typeof hex === 'string') {\n    try {\n      res = hexToBytes(hex);\n    } catch (e) {\n      throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n    }\n  } else if (u8a(hex)) {\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n  } else {\n    throw new Error(`${title} must be hex string or Uint8Array`);\n  }\n  const len = res.length;\n  if (typeof expectedLength === 'number' && len !== expectedLength)\n    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n  return res;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n  let pad = 0; // walk through each item, ensure they have proper type\n  arrays.forEach((a) => {\n    if (!u8a(a)) throw new Error('Uint8Array expected');\n    r.set(a, pad);\n    pad += a.length;\n  });\n  return r;\n}\n\nexport function equalBytes(b1: Uint8Array, b2: Uint8Array) {\n  // We don't care about timing attacks here\n  if (b1.length !== b2.length) return false;\n  for (let i = 0; i < b1.length; i++) if (b1[i] !== b2[i]) return false;\n  return true;\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n// Bit operations\n\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nexport function bitLen(n: bigint) {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\n\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n: bigint, pos: number) {\n  return (n >> BigInt(pos)) & _1n;\n}\n\n/**\n * Sets single bit at position.\n */\nexport const bitSet = (n: bigint, pos: number, value: boolean) => {\n  return n | ((value ? _1n : _0n) << BigInt(pos));\n};\n\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n: number) => (_2n << BigInt(n - 1)) - _1n;\n\n// DRBG\n\nconst u8n = (data?: any) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr: any) => Uint8Array.from(arr); // another shortcut\ntype Pred<T> = (v: Uint8Array) => T | undefined;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg<T>(\n  hashLen: number,\n  qByteLen: number,\n  hmacFn: (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array\n): (seed: Uint8Array, predicate: Pred<T>) => T {\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = (...b: Uint8Array[]) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n  const reseed = (seed = u8n()) => {\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n    let len = 0;\n    const out: Uint8Array[] = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return concatBytes(...out);\n  };\n  const genUntil = (seed: Uint8Array, pred: Pred<T>): T => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res: T | undefined = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\n\n// Validating curves and fields\n\nconst validatorFns = {\n  bigint: (val: any) => typeof val === 'bigint',\n  function: (val: any) => typeof val === 'function',\n  boolean: (val: any) => typeof val === 'boolean',\n  string: (val: any) => typeof val === 'string',\n  isSafeInteger: (val: any) => Number.isSafeInteger(val),\n  array: (val: any) => Array.isArray(val),\n  field: (val: any, object: any) => (object as any).Fp.isValid(val),\n  hash: (val: any) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n} as const;\ntype Validator = keyof typeof validatorFns;\ntype ValMap<T extends Record<string, any>> = { [K in keyof T]?: Validator };\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\n\nexport function validateObject<T extends Record<string, any>>(\n  object: T,\n  validators: ValMap<T>,\n  optValidators: ValMap<T> = {}\n) {\n  const checkField = (fieldName: keyof T, type: Validator, isOptional: boolean) => {\n    const checkVal = validatorFns[type];\n    if (typeof checkVal !== 'function')\n      throw new Error(`Invalid validator \"${type}\", expected function`);\n\n    const val = object[fieldName as keyof typeof object];\n    if (isOptional && val === undefined) return;\n    if (!checkVal(val, object)) {\n      throw new Error(\n        `Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`\n      );\n    }\n  };\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type!, false);\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type!, true);\n  return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n"]},"metadata":{},"sourceType":"script"}