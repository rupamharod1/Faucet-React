{"ast":null,"code":"/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\nconst u8a = a => a instanceof Uint8Array; // Cast array to different type\n\n\nexport const u8 = arr => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = arr => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4)); // Cast array to view\n\nexport const createView = arr => new DataView(arr.buffer, arr.byteOffset, arr.byteLength); // The rotate right (circular right shift) operation for uint32\n\nexport const rotr = (word, shift) => word << 32 - shift | word >>> shift; // big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\n\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE) throw new Error('Non little-endian hardware is not supported');\nconst hexes = Array.from({\n  length: 256\n}, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\n\nexport function bytesToHex(bytes) {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected'); // pre-caching improves the speed 6x\n\n  let hex = '';\n\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n\n  return hex;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\n\nexport function hexToBytes(hex) {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const len = hex.length;\n  if (len % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n  const array = new Uint8Array(len / 2);\n\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n\n  return array;\n} // There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\n\nexport const nextTick = async () => {}; // Returns control to thread each 'tick' ms to avoid blocking\n\nexport async function asyncLoop(iters, tick, cb) {\n  let ts = Date.now();\n\n  for (let i = 0; i < iters; i++) {\n    cb(i); // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\n\nexport function utf8ToBytes(str) {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\n\nexport function toBytes(data) {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  if (!u8a(data)) throw new Error(`expected Uint8Array, got ${typeof data}`);\n  return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\n\nexport function concatBytes() {\n  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {\n    arrays[_key] = arguments[_key];\n  }\n\n  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n  let pad = 0; // walk through each item, ensure they have proper type\n\n  arrays.forEach(a => {\n    if (!u8a(a)) throw new Error('Uint8Array expected');\n    r.set(a, pad);\n    pad += a.length;\n  });\n  return r;\n} // For runtime check if class implements interface\n\nexport class Hash {\n  // Safe version that clones internal state\n  clone() {\n    return this._cloneInto();\n  }\n\n} // Check if object doens't have custom constructor (like Uint8Array/Array)\n\nconst isPlainObject = obj => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\n\nexport function checkOpts(defaults, opts) {\n  if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts))) throw new Error('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged;\n}\nexport function wrapConstructor(hashCons) {\n  const hashC = msg => hashCons().update(toBytes(msg)).digest();\n\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n\n  hashC.create = () => hashCons();\n\n  return hashC;\n}\nexport function wrapConstructorWithOpts(hashCons) {\n  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n\n  const tmp = hashCons({});\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n\n  hashC.create = opts => hashCons(opts);\n\n  return hashC;\n}\nexport function wrapXOFConstructorWithOpts(hashCons) {\n  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n\n  const tmp = hashCons({});\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n\n  hashC.create = opts => hashCons(opts);\n\n  return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\n\nexport function randomBytes() {\n  let bytesLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;\n\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n\n  throw new Error('crypto.getRandomValues must be defined');\n}","map":{"version":3,"mappings":"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","names":["crypto","u8a","a","Uint8Array","u8","arr","buffer","byteOffset","byteLength","u32","Uint32Array","Math","floor","createView","DataView","rotr","word","shift","isLE","Error","hexes","Array","from","length","v","i","toString","padStart","bytesToHex","bytes","hex","hexToBytes","len","array","j","hexByte","slice","byte","Number","parseInt","isNaN","nextTick","asyncLoop","iters","tick","cb","ts","Date","now","diff","utf8ToBytes","str","TextEncoder","encode","toBytes","data","concatBytes","arrays","r","reduce","sum","pad","forEach","set","Hash","clone","_cloneInto","isPlainObject","obj","Object","prototype","call","constructor","checkOpts","defaults","opts","undefined","merged","assign","wrapConstructor","hashCons","hashC","msg","update","digest","tmp","outputLen","blockLen","create","wrapConstructorWithOpts","wrapXOFConstructorWithOpts","randomBytes","bytesLength","getRandomValues"],"sources":["/home/rupam/Desktop/Faucet-React/node_modules/@noble/hashes/src/utils.ts"],"sourcesContent":["/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\nconst u8a = (a: any): a is Uint8Array => a instanceof Uint8Array;\n// Cast array to different type\nexport const u8 = (arr: TypedArray) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexport const u32 = (arr: TypedArray) =>\n  new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n\n// Cast array to view\nexport const createView = (arr: TypedArray) =>\n  new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n\n// The rotate right (circular right shift) operation for uint32\nexport const rotr = (word: number, shift: number) => (word << (32 - shift)) | (word >>> shift);\n\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nexport const isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE) throw new Error('Non little-endian hardware is not supported');\n\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  if (!u8a(bytes)) throw new Error('Uint8Array expected');\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const len = hex.length;\n  if (len % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n  const array = new Uint8Array(len / 2);\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n  return array;\n}\n\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nexport const nextTick = async () => {};\n\n// Returns control to thread each 'tick' ms to avoid blocking\nexport async function asyncLoop(iters: number, tick: number, cb: (i: number) => void) {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  if (!u8a(data)) throw new Error(`expected Uint8Array, got ${typeof data}`);\n  return data;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n  let pad = 0; // walk through each item, ensure they have proper type\n  arrays.forEach((a) => {\n    if (!u8a(a)) throw new Error('Uint8Array expected');\n    r.set(a, pad);\n    pad += a.length;\n  });\n  return r;\n}\n\n// For runtime check if class implements interface\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj: any) =>\n  Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))\n    throw new Error('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\nexport type CHash = ReturnType<typeof wrapConstructor>;\n\nexport function wrapConstructor<T extends Hash<T>>(hashCons: () => Hash<T>) {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function wrapConstructorWithOpts<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function wrapXOFConstructorWithOpts<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n) {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n"]},"metadata":{},"sourceType":"module"}