{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Address = void 0;\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst keccak_js_1 = require(\"ethereum-cryptography/keccak.js\");\n\nconst web3_utils_1 = require(\"web3-utils\");\n\nconst constants_js_1 = require(\"./constants.js\");\n\nconst utils_js_1 = require(\"../common/utils.js\");\n\nclass Address {\n  constructor(buf) {\n    if (buf.length !== 20) {\n      throw new Error('Invalid address length');\n    }\n\n    this.buf = buf;\n  }\n  /**\n   * Returns the zero address.\n   */\n\n\n  static zero() {\n    return new Address((0, utils_js_1.zeros)(20));\n  }\n  /**\n   * Is address equal to another.\n   */\n\n\n  equals(address) {\n    return (0, web3_utils_1.uint8ArrayEquals)(this.buf, address.buf);\n  }\n  /**\n   * Is address zero.\n   */\n\n\n  isZero() {\n    return this.equals(Address.zero());\n  }\n  /**\n   * Returns hex encoding of address.\n   */\n\n\n  toString() {\n    return (0, web3_utils_1.bytesToHex)(this.buf);\n  }\n  /**\n   * Returns Uint8Array representation of address.\n   */\n\n\n  toArray() {\n    return this.buf;\n  }\n  /**\n   * Returns the ethereum address of a given public key.\n   * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n   * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n   * @param sanitize Accept public keys in other formats\n   */\n\n\n  static publicToAddress(_pubKey) {\n    let sanitize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let pubKey = _pubKey;\n    (0, utils_js_1.assertIsUint8Array)(pubKey);\n\n    if (sanitize && pubKey.length !== 64) {\n      pubKey = constants_js_1.secp256k1.ProjectivePoint.fromHex(pubKey).toRawBytes(false).slice(1);\n    }\n\n    if (pubKey.length !== 64) {\n      throw new Error('Expected pubKey to be of length 64');\n    } // Only take the lower 160bits of the hash\n\n\n    return (0, keccak_js_1.keccak256)(pubKey).slice(-20);\n  }\n\n}\n\nexports.Address = Address;","map":{"version":3,"mappings":";;;;;;AAAA;;;;;;;;;;;;;;;;;AAgBA;;AACA;;AACA;;AACA;;AAEA,MAAaA,OAAb,CAAoB;EAGnBC,YAAmBC,GAAnB,EAAkC;IACjC,IAAIA,GAAG,CAACC,MAAJ,KAAe,EAAnB,EAAuB;MACtB,MAAM,IAAIC,KAAJ,CAAU,wBAAV,CAAN;IACA;;IACD,KAAKF,GAAL,GAAWA,GAAX;EACA;EAED;;;;;EAGkB,OAAJG,IAAI;IACjB,OAAO,IAAIL,OAAJ,CAAY,sBAAM,EAAN,CAAZ,CAAP;EACA;EAED;;;;;EAGOM,MAAM,CAACC,OAAD,EAAiB;IAC7B,OAAO,mCAAiB,KAAKL,GAAtB,EAA2BK,OAAO,CAACL,GAAnC,CAAP;EACA;EAED;;;;;EAGOM,MAAM;IACZ,OAAO,KAAKF,MAAL,CAAYN,OAAO,CAACK,IAAR,EAAZ,CAAP;EACA;EAED;;;;;EAGOI,QAAQ;IACd,OAAO,6BAAW,KAAKP,GAAhB,CAAP;EACA;EAED;;;;;EAGOQ,OAAO;IACb,OAAO,KAAKR,GAAZ;EACA;EAED;;;;;;;;EAM6B,OAAfS,eAAe,CAACC,OAAD,EAAsC;IAAA,IAAhBC,QAAgB,uEAAL,KAAK;IAClE,IAAIC,MAAM,GAAGF,OAAb;IACA,mCAAmBE,MAAnB;;IACA,IAAID,QAAQ,IAAIC,MAAM,CAACX,MAAP,KAAkB,EAAlC,EAAsC;MACrCW,MAAM,GAAGC,yBAAUC,eAAV,CAA0BC,OAA1B,CAAkCH,MAAlC,EAA0CI,UAA1C,CAAqD,KAArD,EAA4DC,KAA5D,CAAkE,CAAlE,CAAT;IACA;;IACD,IAAIL,MAAM,CAACX,MAAP,KAAkB,EAAtB,EAA0B;MACzB,MAAM,IAAIC,KAAJ,CAAU,oCAAV,CAAN;IACA,CARiE,CASlE;;;IACA,OAAO,2BAAUU,MAAV,EAAkBK,KAAlB,CAAwB,CAAC,EAAzB,CAAP;EACA;;AA9DkB;;AAApBC","names":["Address","constructor","buf","length","Error","zero","equals","address","isZero","toString","toArray","publicToAddress","_pubKey","sanitize","pubKey","constants_js_1","ProjectivePoint","fromHex","toRawBytes","slice","exports"],"sources":["/home/rupam/Desktop/Faucet-React/node_modules/web3-eth-accounts/src/tx/address.ts"],"sourcesContent":["/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { keccak256 } from 'ethereum-cryptography/keccak.js';\nimport { bytesToHex, uint8ArrayEquals } from 'web3-utils';\nimport { secp256k1 } from './constants.js';\nimport { assertIsUint8Array, zeros } from '../common/utils.js';\n\nexport class Address {\n\tpublic readonly buf: Uint8Array;\n\n\tpublic constructor(buf: Uint8Array) {\n\t\tif (buf.length !== 20) {\n\t\t\tthrow new Error('Invalid address length');\n\t\t}\n\t\tthis.buf = buf;\n\t}\n\n\t/**\n\t * Returns the zero address.\n\t */\n\tpublic static zero(): Address {\n\t\treturn new Address(zeros(20));\n\t}\n\n\t/**\n\t * Is address equal to another.\n\t */\n\tpublic equals(address: Address): boolean {\n\t\treturn uint8ArrayEquals(this.buf, address.buf);\n\t}\n\n\t/**\n\t * Is address zero.\n\t */\n\tpublic isZero(): boolean {\n\t\treturn this.equals(Address.zero());\n\t}\n\n\t/**\n\t * Returns hex encoding of address.\n\t */\n\tpublic toString(): string {\n\t\treturn bytesToHex(this.buf);\n\t}\n\n\t/**\n\t * Returns Uint8Array representation of address.\n\t */\n\tpublic toArray(): Uint8Array {\n\t\treturn this.buf;\n\t}\n\n\t/**\n\t * Returns the ethereum address of a given public key.\n\t * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n\t * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n\t * @param sanitize Accept public keys in other formats\n\t */\n\tpublic static publicToAddress(_pubKey: Uint8Array, sanitize = false): Uint8Array {\n\t\tlet pubKey = _pubKey;\n\t\tassertIsUint8Array(pubKey);\n\t\tif (sanitize && pubKey.length !== 64) {\n\t\t\tpubKey = secp256k1.ProjectivePoint.fromHex(pubKey).toRawBytes(false).slice(1);\n\t\t}\n\t\tif (pubKey.length !== 64) {\n\t\t\tthrow new Error('Expected pubKey to be of length 64');\n\t\t}\n\t\t// Only take the lower 160bits of the hash\n\t\treturn keccak256(pubKey).slice(-20);\n\t}\n}\n"]},"metadata":{},"sourceType":"script"}