{"ast":null,"code":"/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\nimport { bitMask, numberToBytesBE, numberToBytesLE, bytesToNumberBE, bytesToNumberLE, ensureBytes, validateObject } from './utils.js'; // prettier-ignore\n\nconst _0n = BigInt(0),\n      _1n = BigInt(1),\n      _2n = BigInt(2),\n      _3n = BigInt(3); // prettier-ignore\n\n\nconst _4n = BigInt(4),\n      _5n = BigInt(5),\n      _8n = BigInt(8); // prettier-ignore\n\n\nconst _9n = BigInt(9),\n      _16n = BigInt(16); // Calculates a modulo b\n\n\nexport function mod(a, b) {\n  const result = a % b;\n  return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\n\nexport function pow(num, power, modulo) {\n  if (modulo <= _0n || power < _0n) throw new Error('Expected power/modulo > 0');\n  if (modulo === _1n) return _0n;\n  let res = _1n;\n\n  while (power > _0n) {\n    if (power & _1n) res = res * num % modulo;\n    num = num * num % modulo;\n    power >>= _1n;\n  }\n\n  return res;\n} // Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\n\nexport function pow2(x, power, modulo) {\n  let res = x;\n\n  while (power-- > _0n) {\n    res *= res;\n    res %= modulo;\n  }\n\n  return res;\n} // Inverses number over modulo\n\nexport function invert(number, modulo) {\n  if (number === _0n || modulo <= _0n) {\n    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n  } // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n  // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n\n\n  let a = mod(number, modulo);\n  let b = modulo; // prettier-ignore\n\n  let x = _0n,\n      y = _1n,\n      u = _1n,\n      v = _0n;\n\n  while (a !== _0n) {\n    // JIT applies optimization if those two lines follow each other\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q; // prettier-ignore\n\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n} // Tonelli-Shanks algorithm\n// Paper 1: https://eprint.iacr.org/2012/685.pdf (page 12)\n// Paper 2: Square Roots from 1; 24, 51, 10 to Dan Shanks\n\nexport function tonelliShanks(P) {\n  // Legendre constant: used to calculate Legendre symbol (a | p),\n  // which denotes the value of a^((p-1)/2) (mod p).\n  // (a | p) ≡ 1    if a is a square (mod p)\n  // (a | p) ≡ -1   if a is not a square (mod p)\n  // (a | p) ≡ 0    if a ≡ 0 (mod p)\n  const legendreC = (P - _1n) / _2n;\n  let Q, S, Z; // Step 1: By factoring out powers of 2 from p - 1,\n  // find q and s such that p - 1 = q*(2^s) with q odd\n\n  for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++); // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n\n\n  for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++); // Fast-path\n\n\n  if (S === 1) {\n    const p1div4 = (P + _1n) / _4n;\n    return function tonelliFast(Fp, n) {\n      const root = Fp.pow(n, p1div4);\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  } // Slow-path\n\n\n  const Q1div2 = (Q + _1n) / _2n;\n  return function tonelliSlow(Fp, n) {\n    // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n    if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error('Cannot find square root');\n    let r = S; // TODO: will fail at Fp2/etc\n\n    let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n\n    let x = Fp.pow(n, Q1div2); // first guess at the square root\n\n    let b = Fp.pow(n, Q); // first guess at the fudge factor\n\n    while (!Fp.eql(b, Fp.ONE)) {\n      if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n      // Find m such b^(2^m)==1\n\n      let m = 1;\n\n      for (let t2 = Fp.sqr(b); m < r; m++) {\n        if (Fp.eql(t2, Fp.ONE)) break;\n        t2 = Fp.sqr(t2); // t2 *= t2\n      } // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n\n\n      const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n\n      g = Fp.sqr(ge); // g = ge * ge\n\n      x = Fp.mul(x, ge); // x *= ge\n\n      b = Fp.mul(b, g); // b *= g\n\n      r = m;\n    }\n\n    return x;\n  };\n}\nexport function FpSqrt(P) {\n  // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n  // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n  // P ≡ 3 (mod 4)\n  // √n = n^((P+1)/4)\n  if (P % _4n === _3n) {\n    // Not all roots possible!\n    // const ORDER =\n    //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n    // const NUM = 72057594037927816n;\n    const p1div4 = (P + _1n) / _4n;\n    return function sqrt3mod4(Fp, n) {\n      const root = Fp.pow(n, p1div4); // Throw if root**2 != n\n\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  } // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n\n\n  if (P % _8n === _5n) {\n    const c1 = (P - _5n) / _8n;\n    return function sqrt5mod8(Fp, n) {\n      const n2 = Fp.mul(n, _2n);\n      const v = Fp.pow(n2, c1);\n      const nv = Fp.mul(n, v);\n      const i = Fp.mul(Fp.mul(nv, _2n), v);\n      const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  } // P ≡ 9 (mod 16)\n\n\n  if (P % _16n === _9n) {// NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n    // Means we cannot use sqrt for constants at all!\n    //\n    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    // sqrt = (x) => {\n    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n    // }\n  } // Other cases: Tonelli-Shanks algorithm\n\n\n  return tonelliShanks(P);\n} // Little-endian check for first LE bit (last BE bit);\n\nexport const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n; // prettier-ignore\n\nconst FIELD_FIELDS = ['create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr', 'eql', 'add', 'sub', 'mul', 'pow', 'div', 'addN', 'subN', 'mulN', 'sqrN'];\nexport function validateField(field) {\n  const initial = {\n    ORDER: 'bigint',\n    MASK: 'bigint',\n    BYTES: 'isSafeInteger',\n    BITS: 'isSafeInteger'\n  };\n  const opts = FIELD_FIELDS.reduce((map, val) => {\n    map[val] = 'function';\n    return map;\n  }, initial);\n  return validateObject(field, opts);\n} // Generic field functions\n\nexport function FpPow(f, num, power) {\n  // Should have same speed as pow for bigints\n  // TODO: benchmark!\n  if (power < _0n) throw new Error('Expected power > 0');\n  if (power === _0n) return f.ONE;\n  if (power === _1n) return num;\n  let p = f.ONE;\n  let d = num;\n\n  while (power > _0n) {\n    if (power & _1n) p = f.mul(p, d);\n    d = f.sqr(d);\n    power >>= _1n;\n  }\n\n  return p;\n} // 0 is non-invertible: non-batched version will throw on 0\n\nexport function FpInvertBatch(f, nums) {\n  const tmp = new Array(nums.length); // Walk from first to last, multiply them by each other MOD p\n\n  const lastMultiplied = nums.reduce((acc, num, i) => {\n    if (f.is0(num)) return acc;\n    tmp[i] = acc;\n    return f.mul(acc, num);\n  }, f.ONE); // Invert last element\n\n  const inverted = f.inv(lastMultiplied); // Walk from last to first, multiply them by inverted each other MOD p\n\n  nums.reduceRight((acc, num, i) => {\n    if (f.is0(num)) return acc;\n    tmp[i] = f.mul(acc, tmp[i]);\n    return f.mul(acc, num);\n  }, inverted);\n  return tmp;\n}\nexport function FpDiv(f, lhs, rhs) {\n  return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n} // This function returns True whenever the value x is a square in the field F.\n\nexport function FpIsSquare(f) {\n  const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n\n  return x => {\n    const p = f.pow(x, legendreConst);\n    return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n  };\n} // CURVE.n lengths\n\nexport function nLength(n, nBitLength) {\n  // Bit size, byte size of CURVE.n\n  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n\n  const nByteLength = Math.ceil(_nBitLength / 8);\n  return {\n    nBitLength: _nBitLength,\n    nByteLength\n  };\n}\n/**\n * Initializes a galois field over prime. Non-primes are not supported for now.\n * Do not init in loop: slow. Very fragile: always run a benchmark on change.\n * Major performance gains:\n * a) non-normalized operations like mulN instead of mul\n * b) `Object.freeze`\n * c) Same object shape: never add or remove keys\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\n\nexport function Field(ORDER, bitLen) {\n  let isLE = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let redef = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  if (ORDER <= _0n) throw new Error(`Expected Fp ORDER > 0, got ${ORDER}`);\n  const {\n    nBitLength: BITS,\n    nByteLength: BYTES\n  } = nLength(ORDER, bitLen);\n  if (BYTES > 2048) throw new Error('Field lengths over 2048 bytes are not supported');\n  const sqrtP = FpSqrt(ORDER);\n  const f = Object.freeze({\n    ORDER,\n    BITS,\n    BYTES,\n    MASK: bitMask(BITS),\n    ZERO: _0n,\n    ONE: _1n,\n    create: num => mod(num, ORDER),\n    isValid: num => {\n      if (typeof num !== 'bigint') throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n      return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n    },\n    is0: num => num === _0n,\n    isOdd: num => (num & _1n) === _1n,\n    neg: num => mod(-num, ORDER),\n    eql: (lhs, rhs) => lhs === rhs,\n    sqr: num => mod(num * num, ORDER),\n    add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n    pow: (num, power) => FpPow(f, num, power),\n    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n    // Same as above, but doesn't normalize\n    sqrN: num => num * num,\n    addN: (lhs, rhs) => lhs + rhs,\n    subN: (lhs, rhs) => lhs - rhs,\n    mulN: (lhs, rhs) => lhs * rhs,\n    inv: num => invert(num, ORDER),\n    sqrt: redef.sqrt || (n => sqrtP(f, n)),\n    invertBatch: lst => FpInvertBatch(f, lst),\n    // TODO: do we really need constant cmov?\n    // We don't have const-time bigints anyway, so probably will be not very useful\n    cmov: (a, b, c) => c ? b : a,\n    toBytes: num => isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),\n    fromBytes: bytes => {\n      if (bytes.length !== BYTES) throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n      return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n    }\n  });\n  return Object.freeze(f);\n}\nexport function FpSqrtOdd(Fp, elm) {\n  if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nexport function FpSqrtEven(Fp, elm) {\n  if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * FIPS 186 B.4.1-compliant \"constant-time\" private key generation utility.\n * Can take (n+8) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 40 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. curveFn.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\n\nexport function hashToPrivateScalar(hash, groupOrder) {\n  let isLE = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  hash = ensureBytes('privateHash', hash);\n  const hashLen = hash.length;\n  const minLen = nLength(groupOrder).nByteLength + 8;\n  if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n  const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n  return mod(num, groupOrder - _1n) + _1n;\n}","map":{"version":3,"mappings":"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","names":["bitMask","numberToBytesBE","numberToBytesLE","bytesToNumberBE","bytesToNumberLE","ensureBytes","validateObject","_0n","BigInt","_1n","_2n","_3n","_4n","_5n","_8n","_9n","_16n","mod","a","b","result","pow","num","power","modulo","Error","res","pow2","x","invert","number","y","u","v","q","r","m","n","gcd","tonelliShanks","P","legendreC","Q","S","Z","p1div4","tonelliFast","Fp","root","eql","sqr","Q1div2","tonelliSlow","neg","ONE","g","mul","ZERO","t2","ge","FpSqrt","sqrt3mod4","c1","sqrt5mod8","n2","nv","i","sub","isNegativeLE","FIELD_FIELDS","validateField","field","initial","ORDER","MASK","BYTES","BITS","opts","reduce","map","val","FpPow","f","p","d","FpInvertBatch","nums","tmp","Array","length","lastMultiplied","acc","is0","inverted","inv","reduceRight","FpDiv","lhs","rhs","FpIsSquare","legendreConst","nLength","nBitLength","_nBitLength","undefined","toString","nByteLength","Math","ceil","Field","bitLen","isLE","redef","sqrtP","Object","freeze","create","isValid","isOdd","add","div","sqrN","addN","subN","mulN","sqrt","invertBatch","lst","cmov","c","toBytes","fromBytes","bytes","FpSqrtOdd","elm","FpSqrtEven","hashToPrivateScalar","hash","groupOrder","hashLen","minLen"],"sources":["/home/rupam/Desktop/Faucet-React/node_modules/@noble/curves/src/abstract/modular.ts"],"sourcesContent":["/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\nimport {\n  bitMask,\n  numberToBytesBE,\n  numberToBytesLE,\n  bytesToNumberBE,\n  bytesToNumberLE,\n  ensureBytes,\n  validateObject,\n} from './utils.js';\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n\n// Calculates a modulo b\nexport function mod(a: bigint, b: bigint): bigint {\n  const result = a % b;\n  return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nexport function pow(num: bigint, power: bigint, modulo: bigint): bigint {\n  if (modulo <= _0n || power < _0n) throw new Error('Expected power/modulo > 0');\n  if (modulo === _1n) return _0n;\n  let res = _1n;\n  while (power > _0n) {\n    if (power & _1n) res = (res * num) % modulo;\n    num = (num * num) % modulo;\n    power >>= _1n;\n  }\n  return res;\n}\n\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nexport function pow2(x: bigint, power: bigint, modulo: bigint): bigint {\n  let res = x;\n  while (power-- > _0n) {\n    res *= res;\n    res %= modulo;\n  }\n  return res;\n}\n\n// Inverses number over modulo\nexport function invert(number: bigint, modulo: bigint): bigint {\n  if (number === _0n || modulo <= _0n) {\n    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n  }\n  // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n  // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n  let a = mod(number, modulo);\n  let b = modulo;\n  // prettier-ignore\n  let x = _0n, y = _1n, u = _1n, v = _0n;\n  while (a !== _0n) {\n    // JIT applies optimization if those two lines follow each other\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    // prettier-ignore\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\n\n// Tonelli-Shanks algorithm\n// Paper 1: https://eprint.iacr.org/2012/685.pdf (page 12)\n// Paper 2: Square Roots from 1; 24, 51, 10 to Dan Shanks\nexport function tonelliShanks(P: bigint) {\n  // Legendre constant: used to calculate Legendre symbol (a | p),\n  // which denotes the value of a^((p-1)/2) (mod p).\n  // (a | p) ≡ 1    if a is a square (mod p)\n  // (a | p) ≡ -1   if a is not a square (mod p)\n  // (a | p) ≡ 0    if a ≡ 0 (mod p)\n  const legendreC = (P - _1n) / _2n;\n\n  let Q: bigint, S: number, Z: bigint;\n  // Step 1: By factoring out powers of 2 from p - 1,\n  // find q and s such that p - 1 = q*(2^s) with q odd\n  for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);\n\n  // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n  for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++);\n\n  // Fast-path\n  if (S === 1) {\n    const p1div4 = (P + _1n) / _4n;\n    return function tonelliFast<T>(Fp: IField<T>, n: T) {\n      const root = Fp.pow(n, p1div4);\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // Slow-path\n  const Q1div2 = (Q + _1n) / _2n;\n  return function tonelliSlow<T>(Fp: IField<T>, n: T): T {\n    // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n    if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error('Cannot find square root');\n    let r = S;\n    // TODO: will fail at Fp2/etc\n    let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n    let x = Fp.pow(n, Q1div2); // first guess at the square root\n    let b = Fp.pow(n, Q); // first guess at the fudge factor\n\n    while (!Fp.eql(b, Fp.ONE)) {\n      if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n      // Find m such b^(2^m)==1\n      let m = 1;\n      for (let t2 = Fp.sqr(b); m < r; m++) {\n        if (Fp.eql(t2, Fp.ONE)) break;\n        t2 = Fp.sqr(t2); // t2 *= t2\n      }\n      // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n      const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n      g = Fp.sqr(ge); // g = ge * ge\n      x = Fp.mul(x, ge); // x *= ge\n      b = Fp.mul(b, g); // b *= g\n      r = m;\n    }\n    return x;\n  };\n}\n\nexport function FpSqrt(P: bigint) {\n  // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n  // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n\n  // P ≡ 3 (mod 4)\n  // √n = n^((P+1)/4)\n  if (P % _4n === _3n) {\n    // Not all roots possible!\n    // const ORDER =\n    //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n    // const NUM = 72057594037927816n;\n    const p1div4 = (P + _1n) / _4n;\n    return function sqrt3mod4<T>(Fp: IField<T>, n: T) {\n      const root = Fp.pow(n, p1div4);\n      // Throw if root**2 != n\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n  if (P % _8n === _5n) {\n    const c1 = (P - _5n) / _8n;\n    return function sqrt5mod8<T>(Fp: IField<T>, n: T) {\n      const n2 = Fp.mul(n, _2n);\n      const v = Fp.pow(n2, c1);\n      const nv = Fp.mul(n, v);\n      const i = Fp.mul(Fp.mul(nv, _2n), v);\n      const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // P ≡ 9 (mod 16)\n  if (P % _16n === _9n) {\n    // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n    // Means we cannot use sqrt for constants at all!\n    //\n    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    // sqrt = (x) => {\n    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n    // }\n  }\n\n  // Other cases: Tonelli-Shanks algorithm\n  return tonelliShanks(P);\n}\n\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num: bigint, modulo: bigint) => (mod(num, modulo) & _1n) === _1n;\n\n// Field is not always over prime, Fp2 for example has ORDER(q)=p^m\nexport interface IField<T> {\n  ORDER: bigint;\n  BYTES: number;\n  BITS: number;\n  MASK: bigint;\n  ZERO: T;\n  ONE: T;\n  // 1-arg\n  create: (num: T) => T;\n  isValid: (num: T) => boolean;\n  is0: (num: T) => boolean;\n  neg(num: T): T;\n  inv(num: T): T;\n  sqrt(num: T): T;\n  sqr(num: T): T;\n  // 2-args\n  eql(lhs: T, rhs: T): boolean;\n  add(lhs: T, rhs: T): T;\n  sub(lhs: T, rhs: T): T;\n  mul(lhs: T, rhs: T | bigint): T;\n  pow(lhs: T, power: bigint): T;\n  div(lhs: T, rhs: T | bigint): T;\n  // N for NonNormalized (for now)\n  addN(lhs: T, rhs: T): T;\n  subN(lhs: T, rhs: T): T;\n  mulN(lhs: T, rhs: T | bigint): T;\n  sqrN(num: T): T;\n\n  // Optional\n  // Should be same as sgn0 function in https://datatracker.ietf.org/doc/draft-irtf-cfrg-hash-to-curve/\n  // NOTE: sgn0 is 'negative in LE', which is same as odd. And negative in LE is kinda strange definition anyway.\n  isOdd?(num: T): boolean; // Odd instead of even since we have it for Fp2\n  // legendre?(num: T): T;\n  pow(lhs: T, power: bigint): T;\n  invertBatch: (lst: T[]) => T[];\n  toBytes(num: T): Uint8Array;\n  fromBytes(bytes: Uint8Array): T;\n  // If c is False, CMOV returns a, otherwise it returns b.\n  cmov(a: T, b: T, c: boolean): T;\n}\n// prettier-ignore\nconst FIELD_FIELDS = [\n  'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n  'eql', 'add', 'sub', 'mul', 'pow', 'div',\n  'addN', 'subN', 'mulN', 'sqrN'\n] as const;\nexport function validateField<T>(field: IField<T>) {\n  const initial = {\n    ORDER: 'bigint',\n    MASK: 'bigint',\n    BYTES: 'isSafeInteger',\n    BITS: 'isSafeInteger',\n  } as Record<string, string>;\n  const opts = FIELD_FIELDS.reduce((map, val: string) => {\n    map[val] = 'function';\n    return map;\n  }, initial);\n  return validateObject(field, opts);\n}\n\n// Generic field functions\nexport function FpPow<T>(f: IField<T>, num: T, power: bigint): T {\n  // Should have same speed as pow for bigints\n  // TODO: benchmark!\n  if (power < _0n) throw new Error('Expected power > 0');\n  if (power === _0n) return f.ONE;\n  if (power === _1n) return num;\n  let p = f.ONE;\n  let d = num;\n  while (power > _0n) {\n    if (power & _1n) p = f.mul(p, d);\n    d = f.sqr(d);\n    power >>= _1n;\n  }\n  return p;\n}\n\n// 0 is non-invertible: non-batched version will throw on 0\nexport function FpInvertBatch<T>(f: IField<T>, nums: T[]): T[] {\n  const tmp = new Array(nums.length);\n  // Walk from first to last, multiply them by each other MOD p\n  const lastMultiplied = nums.reduce((acc, num, i) => {\n    if (f.is0(num)) return acc;\n    tmp[i] = acc;\n    return f.mul(acc, num);\n  }, f.ONE);\n  // Invert last element\n  const inverted = f.inv(lastMultiplied);\n  // Walk from last to first, multiply them by inverted each other MOD p\n  nums.reduceRight((acc, num, i) => {\n    if (f.is0(num)) return acc;\n    tmp[i] = f.mul(acc, tmp[i]);\n    return f.mul(acc, num);\n  }, inverted);\n  return tmp;\n}\n\nexport function FpDiv<T>(f: IField<T>, lhs: T, rhs: T | bigint): T {\n  return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare<T>(f: IField<T>) {\n  const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n  return (x: T): boolean => {\n    const p = f.pow(x, legendreConst);\n    return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n  };\n}\n\n// CURVE.n lengths\nexport function nLength(n: bigint, nBitLength?: number) {\n  // Bit size, byte size of CURVE.n\n  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n  const nByteLength = Math.ceil(_nBitLength / 8);\n  return { nBitLength: _nBitLength, nByteLength };\n}\n\ntype FpField = IField<bigint> & Required<Pick<IField<bigint>, 'isOdd'>>;\n/**\n * Initializes a galois field over prime. Non-primes are not supported for now.\n * Do not init in loop: slow. Very fragile: always run a benchmark on change.\n * Major performance gains:\n * a) non-normalized operations like mulN instead of mul\n * b) `Object.freeze`\n * c) Same object shape: never add or remove keys\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(\n  ORDER: bigint,\n  bitLen?: number,\n  isLE = false,\n  redef: Partial<IField<bigint>> = {}\n): Readonly<FpField> {\n  if (ORDER <= _0n) throw new Error(`Expected Fp ORDER > 0, got ${ORDER}`);\n  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n  if (BYTES > 2048) throw new Error('Field lengths over 2048 bytes are not supported');\n  const sqrtP = FpSqrt(ORDER);\n  const f: Readonly<FpField> = Object.freeze({\n    ORDER,\n    BITS,\n    BYTES,\n    MASK: bitMask(BITS),\n    ZERO: _0n,\n    ONE: _1n,\n    create: (num) => mod(num, ORDER),\n    isValid: (num) => {\n      if (typeof num !== 'bigint')\n        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n      return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n    },\n    is0: (num) => num === _0n,\n    isOdd: (num) => (num & _1n) === _1n,\n    neg: (num) => mod(-num, ORDER),\n    eql: (lhs, rhs) => lhs === rhs,\n\n    sqr: (num) => mod(num * num, ORDER),\n    add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n    pow: (num, power) => FpPow(f, num, power),\n    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n\n    // Same as above, but doesn't normalize\n    sqrN: (num) => num * num,\n    addN: (lhs, rhs) => lhs + rhs,\n    subN: (lhs, rhs) => lhs - rhs,\n    mulN: (lhs, rhs) => lhs * rhs,\n\n    inv: (num) => invert(num, ORDER),\n    sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n    invertBatch: (lst) => FpInvertBatch(f, lst),\n    // TODO: do we really need constant cmov?\n    // We don't have const-time bigints anyway, so probably will be not very useful\n    cmov: (a, b, c) => (c ? b : a),\n    toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n    fromBytes: (bytes) => {\n      if (bytes.length !== BYTES)\n        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n      return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n    },\n  } as FpField);\n  return Object.freeze(f);\n}\n\nexport function FpSqrtOdd<T>(Fp: IField<T>, elm: T) {\n  if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? root : Fp.neg(root);\n}\n\nexport function FpSqrtEven<T>(Fp: IField<T>, elm: T) {\n  if (!Fp.isOdd) throw new Error(`Field doesn't have isOdd`);\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n\n/**\n * FIPS 186 B.4.1-compliant \"constant-time\" private key generation utility.\n * Can take (n+8) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 40 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. curveFn.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function hashToPrivateScalar(\n  hash: string | Uint8Array,\n  groupOrder: bigint,\n  isLE = false\n): bigint {\n  hash = ensureBytes('privateHash', hash);\n  const hashLen = hash.length;\n  const minLen = nLength(groupOrder).nByteLength + 8;\n  if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n    throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n  const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n  return mod(num, groupOrder - _1n) + _1n;\n}\n"]},"metadata":{},"sourceType":"module"}