{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SHA2 = void 0;\n\nconst _assert_js_1 = require(\"./_assert.js\");\n\nconst utils_js_1 = require(\"./utils.js\"); // Polyfill for Safari 14\n\n\nfunction setBigUint64(view, byteOffset, value, isLE) {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n\n  const _32n = BigInt(32);\n\n  const _u32_max = BigInt(0xffffffff);\n\n  const wh = Number(value >> _32n & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n} // Base SHA2 class (RFC 6234)\n\n\nclass SHA2 extends utils_js_1.Hash {\n  constructor(blockLen, outputLen, padOffset, isLE) {\n    super();\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.padOffset = padOffset;\n    this.isLE = isLE;\n    this.finished = false;\n    this.length = 0;\n    this.pos = 0;\n    this.destroyed = false;\n    this.buffer = new Uint8Array(blockLen);\n    this.view = (0, utils_js_1.createView)(this.buffer);\n  }\n\n  update(data) {\n    _assert_js_1.default.exists(this);\n\n    const {\n      view,\n      buffer,\n      blockLen\n    } = this;\n    data = (0, utils_js_1.toBytes)(data);\n    const len = data.length;\n\n    for (let pos = 0; pos < len;) {\n      const take = Math.min(blockLen - this.pos, len - pos); // Fast path: we have at least one block in input, cast it to view and process\n\n      if (take === blockLen) {\n        const dataView = (0, utils_js_1.createView)(data);\n\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n\n        continue;\n      }\n\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n\n  digestInto(out) {\n    _assert_js_1.default.exists(this);\n\n    _assert_js_1.default.output(out, this);\n\n    this.finished = true; // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n\n    const {\n      buffer,\n      view,\n      blockLen,\n      isLE\n    } = this;\n    let {\n      pos\n    } = this; // append the bit '1' to the message\n\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0); // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    } // Pad until full block byte with zeros\n\n\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0; // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n\n\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = (0, utils_js_1.createView)(out);\n    const len = this.outputLen; // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n\n  digest() {\n    const {\n      buffer,\n      outputLen\n    } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n\n  _cloneInto(to) {\n    to || (to = new this.constructor());\n    to.set(...this.get());\n    const {\n      blockLen,\n      buffer,\n      length,\n      finished,\n      destroyed,\n      pos\n    } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n\n}\n\nexports.SHA2 = SHA2;","map":{"version":3,"mappings":"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","names":["setBigUint64","view","byteOffset","value","isLE","_32n","BigInt","_u32_max","wh","Number","wl","h","l","setUint32","SHA2","utils_js_1","constructor","blockLen","outputLen","padOffset","buffer","Uint8Array","update","data","_assert_js_1","exists","len","length","pos","take","Math","min","dataView","process","set","subarray","roundClean","digestInto","out","output","finished","fill","i","oview","Error","outLen","state","get","digest","res","slice","destroy","_cloneInto","to","destroyed","exports"],"sources":["/home/rupam/Desktop/Faucet-React/node_modules/@noble/hashes/src/_sha2.ts"],"sourcesContent":["import assert from './_assert.js';\nimport { Hash, createView, Input, toBytes } from './utils.js';\n\n// Polyfill for Safari 14\nfunction setBigUint64(view: DataView, byteOffset: number, value: bigint, isLE: boolean): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n// Base SHA2 class (RFC 6234)\nexport abstract class SHA2<T extends SHA2<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(\n    readonly blockLen: number,\n    public outputLen: number,\n    readonly padOffset: number,\n    readonly isLE: boolean\n  ) {\n    super();\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    assert.exists(this);\n    const { view, buffer, blockLen } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array) {\n    assert.exists(this);\n    assert.output(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0);\n    // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest() {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}