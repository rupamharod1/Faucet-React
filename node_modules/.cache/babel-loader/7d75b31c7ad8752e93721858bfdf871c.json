{"ast":null,"code":"/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { FormatterError } from 'web3-errors';\nimport { FMT_BYTES, FMT_NUMBER } from 'web3-types';\nimport { isNullish, isObject, utils } from 'web3-validator';\nimport { bytesToUint8Array, bytesToHex, numberToHex, toBigInt } from './converters.js';\nimport { mergeDeep } from './objects.js';\nimport { padLeft } from './string_manipulation.js';\nimport { uint8ArrayConcat } from './uint8array.js';\nconst {\n  parseBaseType\n} = utils;\nexport const isDataFormat = dataFormat => typeof dataFormat === 'object' && !isNullish(dataFormat) && 'number' in dataFormat && 'bytes' in dataFormat;\n/**\n * Finds the schema that corresponds to a specific data path within a larger JSON schema.\n * It works by iterating over the dataPath array and traversing the JSON schema one step at a time until it reaches the end of the path.\n *\n * @param schema - represents a JSON schema, which is an object that describes the structure of JSON data\n * @param dataPath - represents an array of strings that specifies the path to the data within the JSON schema\n * @param oneOfPath - represents an optional array of two-element tuples that specifies the \"oneOf\" option to choose, if the schema has oneOf and the data path can match multiple subschemas\n * @returns the JSON schema that matches the data path\n *\n */\n\nconst findSchemaByDataPath = function (schema, dataPath) {\n  let oneOfPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let result = Object.assign({}, schema);\n  let previousDataPath;\n\n  for (const dataPart of dataPath) {\n    if (result.oneOf && previousDataPath) {\n      const path = oneOfPath.find(function (element) {\n        return this === element[0];\n      }, previousDataPath !== null && previousDataPath !== void 0 ? previousDataPath : '');\n\n      if (path && path[0] === previousDataPath) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        result = result.oneOf[path[1]];\n      }\n    }\n\n    if (!result.properties && !result.items) {\n      return undefined;\n    }\n\n    if (result.properties) {\n      result = result.properties[dataPart];\n    } else if (result.items && result.items.properties) {\n      const node = result.items.properties;\n\n      if (!node) {\n        return undefined;\n      }\n\n      result = node[dataPart];\n    } else if (result.items && isObject(result.items)) {\n      result = result.items;\n    } else if (result.items && Array.isArray(result.items)) {\n      result = result.items[parseInt(dataPart, 10)];\n    }\n\n    if (result && dataPart) previousDataPath = dataPart;\n  }\n\n  return result;\n};\n/**\n * Converts a value depending on the format\n * @param value - value to convert\n * @param ethType - The type of the value to be parsed\n * @param format - The format to be converted to\n * @returns - The value converted to the specified format\n */\n\n\nexport const convertScalarValue = (value, ethType, format) => {\n  try {\n    const {\n      baseType,\n      baseTypeSize\n    } = parseBaseType(ethType);\n\n    if (baseType === 'int' || baseType === 'uint') {\n      switch (format.number) {\n        case FMT_NUMBER.NUMBER:\n          return Number(toBigInt(value));\n\n        case FMT_NUMBER.HEX:\n          return numberToHex(toBigInt(value));\n\n        case FMT_NUMBER.STR:\n          return toBigInt(value).toString();\n\n        case FMT_NUMBER.BIGINT:\n          return toBigInt(value);\n\n        default:\n          throw new FormatterError(`Invalid format: ${String(format.number)}`);\n      }\n    }\n\n    if (baseType === 'bytes') {\n      let paddedValue;\n\n      if (baseTypeSize) {\n        if (typeof value === 'string') paddedValue = padLeft(value, baseTypeSize * 2);else if (value instanceof Uint8Array) {\n          paddedValue = uint8ArrayConcat(new Uint8Array(baseTypeSize - value.length), value);\n        }\n      } else {\n        paddedValue = value;\n      }\n\n      switch (format.bytes) {\n        case FMT_BYTES.HEX:\n          return bytesToHex(bytesToUint8Array(paddedValue));\n\n        case FMT_BYTES.UINT8ARRAY:\n          return bytesToUint8Array(paddedValue);\n\n        default:\n          throw new FormatterError(`Invalid format: ${String(format.bytes)}`);\n      }\n    }\n  } catch (error) {\n    // If someone didn't use `eth` keyword we can return original value\n    // as the scope of this code is formatting not validation\n    return value;\n  }\n\n  return value;\n};\n/**\n * Converts the data to the specified format\n * @param data - data to convert\n * @param schema - The JSON schema that describes the structure of the data\n * @param dataPath - A string array that specifies the path to the data within the JSON schema\n * @param format  - The format to be converted to\n * @param oneOfPath - An optional array of two-element tuples that specifies the \"oneOf\" option to choose, if the schema has oneOf and the data path can match multiple subschemas\n * @returns - The data converted to the specified format\n */\n\nexport const convert = function (data, schema, dataPath, format) {\n  let oneOfPath = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n\n  var _a, _b; // If it's a scalar value\n\n\n  if (!isObject(data) && !Array.isArray(data)) {\n    return convertScalarValue(data, schema === null || schema === void 0 ? void 0 : schema.format, format);\n  }\n\n  const object = data;\n\n  for (const [key, value] of Object.entries(object)) {\n    dataPath.push(key);\n    const schemaProp = findSchemaByDataPath(schema, dataPath, oneOfPath); // If value is a scaler value\n\n    if (isNullish(schemaProp)) {\n      delete object[key];\n      dataPath.pop();\n      continue;\n    } // If value is an object, recurse into it\n\n\n    if (isObject(value)) {\n      convert(value, schema, dataPath, format);\n      dataPath.pop();\n      continue;\n    } // If value is an array\n\n\n    if (Array.isArray(value)) {\n      let _schemaProp = schemaProp; // TODO This is a naive approach to solving the issue of\n      // a schema using oneOf. This chunk of code was intended to handle\n      // BlockSchema.transactions\n      // TODO BlockSchema.transactions are not being formatted\n\n      if ((schemaProp === null || schemaProp === void 0 ? void 0 : schemaProp.oneOf) !== undefined) {\n        // The following code is basically saying:\n        // if the schema specifies oneOf, then we are to loop\n        // over each possible schema and check if they type of the schema\n        // matches the type of value[0], and if so we use the oneOfSchemaProp\n        // as the schema for formatting\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n        schemaProp.oneOf.forEach((oneOfSchemaProp, index) => {\n          var _a, _b;\n\n          if (!Array.isArray(schemaProp === null || schemaProp === void 0 ? void 0 : schemaProp.items) && (typeof value[0] === 'object' && ((_a = oneOfSchemaProp === null || oneOfSchemaProp === void 0 ? void 0 : oneOfSchemaProp.items) === null || _a === void 0 ? void 0 : _a.type) === 'object' || typeof value[0] === 'string' && ((_b = oneOfSchemaProp === null || oneOfSchemaProp === void 0 ? void 0 : oneOfSchemaProp.items) === null || _b === void 0 ? void 0 : _b.type) !== 'object')) {\n            _schemaProp = oneOfSchemaProp;\n            oneOfPath.push([key, index]);\n          }\n        });\n      }\n\n      if (isNullish(_schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items)) {\n        // Can not find schema for array item, delete that item\n        delete object[key];\n        dataPath.pop();\n        continue;\n      } // If schema for array items is a single type\n\n\n      if (isObject(_schemaProp.items) && !isNullish(_schemaProp.items.format)) {\n        for (let i = 0; i < value.length; i += 1) {\n          object[key][i] = convertScalarValue(value[i], // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n          (_a = _schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items) === null || _a === void 0 ? void 0 : _a.format, format);\n        }\n\n        dataPath.pop();\n        continue;\n      } // If schema for array items is an object\n\n\n      if (!Array.isArray(_schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items) && ((_b = _schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items) === null || _b === void 0 ? void 0 : _b.type) === 'object') {\n        for (const arrObject of value) {\n          convert(arrObject, schema, dataPath, format, oneOfPath);\n        }\n\n        dataPath.pop();\n        continue;\n      } // If schema for array is a tuple\n\n\n      if (Array.isArray(_schemaProp === null || _schemaProp === void 0 ? void 0 : _schemaProp.items)) {\n        for (let i = 0; i < value.length; i += 1) {\n          object[key][i] = convertScalarValue(value[i], _schemaProp.items[i].format, format);\n        }\n\n        dataPath.pop();\n        continue;\n      }\n    }\n\n    object[key] = convertScalarValue(value, schemaProp.format, format);\n    dataPath.pop();\n  }\n\n  return object;\n};\nexport const format = (schema, data, returnFormat) => {\n  let dataToParse;\n\n  if (isObject(data)) {\n    dataToParse = mergeDeep({}, data);\n  } else if (Array.isArray(data)) {\n    dataToParse = [...data];\n  } else {\n    dataToParse = data;\n  } // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\n\n  const jsonSchema = isObject(schema) ? schema : utils.ethAbiToJsonSchema(schema);\n\n  if (!jsonSchema.properties && !jsonSchema.items && !jsonSchema.format) {\n    throw new FormatterError('Invalid json schema for formatting');\n  }\n\n  return convert(dataToParse, jsonSchema, [], returnFormat);\n};","map":{"version":3,"mappings":"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","names":["FormatterError","FMT_BYTES","FMT_NUMBER","isNullish","isObject","utils","bytesToUint8Array","bytesToHex","numberToHex","toBigInt","mergeDeep","padLeft","uint8ArrayConcat","parseBaseType","isDataFormat","dataFormat","findSchemaByDataPath","schema","dataPath","oneOfPath","result","Object","previousDataPath","dataPart","oneOf","path","find","element","properties","items","undefined","node","Array","isArray","parseInt","convertScalarValue","value","ethType","format","baseType","baseTypeSize","number","NUMBER","Number","HEX","STR","toString","BIGINT","String","paddedValue","Uint8Array","length","bytes","UINT8ARRAY","error","convert","data","object","key","entries","push","schemaProp","pop","_schemaProp","forEach","oneOfSchemaProp","index","_a","type","_b","i","arrObject","returnFormat","dataToParse","jsonSchema","ethAbiToJsonSchema"],"sources":["/home/rupam/Desktop/Faucet-React/node_modules/web3-utils/src/formatter.ts"],"sourcesContent":["/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { FormatterError } from 'web3-errors';\nimport { Bytes, DataFormat, FMT_BYTES, FMT_NUMBER, FormatType } from 'web3-types';\nimport { isNullish, isObject, JsonSchema, utils, ValidationSchemaInput } from 'web3-validator';\nimport { bytesToUint8Array, bytesToHex, numberToHex, toBigInt } from './converters.js';\nimport { mergeDeep } from './objects.js';\nimport { padLeft } from './string_manipulation.js';\nimport { uint8ArrayConcat } from './uint8array.js';\n\nconst { parseBaseType } = utils;\n\nexport const isDataFormat = (dataFormat: unknown): dataFormat is DataFormat =>\n\ttypeof dataFormat === 'object' &&\n\t!isNullish(dataFormat) &&\n\t'number' in dataFormat &&\n\t'bytes' in dataFormat;\n\n/**\n * Finds the schema that corresponds to a specific data path within a larger JSON schema.\n * It works by iterating over the dataPath array and traversing the JSON schema one step at a time until it reaches the end of the path.\n *\n * @param schema - represents a JSON schema, which is an object that describes the structure of JSON data\n * @param dataPath - represents an array of strings that specifies the path to the data within the JSON schema\n * @param oneOfPath - represents an optional array of two-element tuples that specifies the \"oneOf\" option to choose, if the schema has oneOf and the data path can match multiple subschemas\n * @returns the JSON schema that matches the data path\n *\n */\nconst findSchemaByDataPath = (\n\tschema: JsonSchema,\n\tdataPath: string[],\n\toneOfPath: [string, number][] = [],\n): JsonSchema | undefined => {\n\tlet result: JsonSchema = { ...schema } as JsonSchema;\n\tlet previousDataPath: string | undefined;\n\n\tfor (const dataPart of dataPath) {\n\t\tif (result.oneOf && previousDataPath) {\n\t\t\tconst path = oneOfPath.find(function (element: [string, number]) {\n\t\t\t\treturn (this as unknown as string) === element[0];\n\t\t\t}, previousDataPath ?? '');\n\n\t\t\tif (path && path[0] === previousDataPath) {\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n\t\t\t\tresult = result.oneOf[path[1]];\n\t\t\t}\n\t\t}\n\t\tif (!result.properties && !result.items) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (result.properties) {\n\t\t\tresult = (result.properties as Record<string, JsonSchema>)[dataPart];\n\t\t} else if (result.items && (result.items as JsonSchema).properties) {\n\t\t\tconst node = (result.items as JsonSchema).properties as Record<string, JsonSchema>;\n\n\t\t\tif (!node) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tresult = node[dataPart];\n\t\t} else if (result.items && isObject(result.items)) {\n\t\t\tresult = result.items;\n\t\t} else if (result.items && Array.isArray(result.items)) {\n\t\t\tresult = result.items[parseInt(dataPart, 10)];\n\t\t}\n\n\t\tif (result && dataPart) previousDataPath = dataPart;\n\t}\n\n\treturn result;\n};\n/**\n * Converts a value depending on the format\n * @param value - value to convert\n * @param ethType - The type of the value to be parsed\n * @param format - The format to be converted to\n * @returns - The value converted to the specified format\n */\nexport const convertScalarValue = (value: unknown, ethType: string, format: DataFormat) => {\n\ttry {\n\t\tconst { baseType, baseTypeSize } = parseBaseType(ethType);\n\t\tif (baseType === 'int' || baseType === 'uint') {\n\t\t\tswitch (format.number) {\n\t\t\t\tcase FMT_NUMBER.NUMBER:\n\t\t\t\t\treturn Number(toBigInt(value));\n\t\t\t\tcase FMT_NUMBER.HEX:\n\t\t\t\t\treturn numberToHex(toBigInt(value));\n\t\t\t\tcase FMT_NUMBER.STR:\n\t\t\t\t\treturn toBigInt(value).toString();\n\t\t\t\tcase FMT_NUMBER.BIGINT:\n\t\t\t\t\treturn toBigInt(value);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new FormatterError(`Invalid format: ${String(format.number)}`);\n\t\t\t}\n\t\t}\n\t\tif (baseType === 'bytes') {\n\t\t\tlet paddedValue;\n\t\t\tif (baseTypeSize) {\n\t\t\t\tif (typeof value === 'string') paddedValue = padLeft(value, baseTypeSize * 2);\n\t\t\t\telse if (value instanceof Uint8Array) {\n\t\t\t\t\tpaddedValue = uint8ArrayConcat(\n\t\t\t\t\t\tnew Uint8Array(baseTypeSize - value.length),\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpaddedValue = value;\n\t\t\t}\n\t\t\tswitch (format.bytes) {\n\t\t\t\tcase FMT_BYTES.HEX:\n\t\t\t\t\treturn bytesToHex(bytesToUint8Array(paddedValue as Bytes));\n\t\t\t\tcase FMT_BYTES.UINT8ARRAY:\n\t\t\t\t\treturn bytesToUint8Array(paddedValue as Bytes);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new FormatterError(`Invalid format: ${String(format.bytes)}`);\n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\t// If someone didn't use `eth` keyword we can return original value\n\t\t// as the scope of this code is formatting not validation\n\t\treturn value;\n\t}\n\n\treturn value;\n};\n/**\n * Converts the data to the specified format\n * @param data - data to convert\n * @param schema - The JSON schema that describes the structure of the data\n * @param dataPath - A string array that specifies the path to the data within the JSON schema\n * @param format  - The format to be converted to\n * @param oneOfPath - An optional array of two-element tuples that specifies the \"oneOf\" option to choose, if the schema has oneOf and the data path can match multiple subschemas\n * @returns - The data converted to the specified format\n */\nexport const convert = (\n\tdata: Record<string, unknown> | unknown[] | unknown,\n\tschema: JsonSchema,\n\tdataPath: string[],\n\tformat: DataFormat,\n\toneOfPath: [string, number][] = [],\n) => {\n\t// If it's a scalar value\n\tif (!isObject(data) && !Array.isArray(data)) {\n\t\treturn convertScalarValue(data, schema?.format as string, format);\n\t}\n\n\tconst object = data as Record<string, unknown>;\n\n\tfor (const [key, value] of Object.entries(object)) {\n\t\tdataPath.push(key);\n\t\tconst schemaProp = findSchemaByDataPath(schema, dataPath, oneOfPath);\n\n\t\t// If value is a scaler value\n\t\tif (isNullish(schemaProp)) {\n\t\t\tdelete object[key];\n\t\t\tdataPath.pop();\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t// If value is an object, recurse into it\n\t\tif (isObject(value)) {\n\t\t\tconvert(value, schema, dataPath, format);\n\t\t\tdataPath.pop();\n\t\t\tcontinue;\n\t\t}\n\n\t\t// If value is an array\n\t\tif (Array.isArray(value)) {\n\t\t\tlet _schemaProp = schemaProp;\n\n\t\t\t// TODO This is a naive approach to solving the issue of\n\t\t\t// a schema using oneOf. This chunk of code was intended to handle\n\t\t\t// BlockSchema.transactions\n\t\t\t// TODO BlockSchema.transactions are not being formatted\n\t\t\tif (schemaProp?.oneOf !== undefined) {\n\t\t\t\t// The following code is basically saying:\n\t\t\t\t// if the schema specifies oneOf, then we are to loop\n\t\t\t\t// over each possible schema and check if they type of the schema\n\t\t\t\t// matches the type of value[0], and if so we use the oneOfSchemaProp\n\t\t\t\t// as the schema for formatting\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n\t\t\t\tschemaProp.oneOf.forEach((oneOfSchemaProp: JsonSchema, index: number) => {\n\t\t\t\t\tif (\n\t\t\t\t\t\t!Array.isArray(schemaProp?.items) &&\n\t\t\t\t\t\t((typeof value[0] === 'object' &&\n\t\t\t\t\t\t\t(oneOfSchemaProp?.items as JsonSchema)?.type === 'object') ||\n\t\t\t\t\t\t\t(typeof value[0] === 'string' &&\n\t\t\t\t\t\t\t\t(oneOfSchemaProp?.items as JsonSchema)?.type !== 'object'))\n\t\t\t\t\t) {\n\t\t\t\t\t\t_schemaProp = oneOfSchemaProp;\n\t\t\t\t\t\toneOfPath.push([key, index]);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (isNullish(_schemaProp?.items)) {\n\t\t\t\t// Can not find schema for array item, delete that item\n\t\t\t\tdelete object[key];\n\t\t\t\tdataPath.pop();\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If schema for array items is a single type\n\t\t\tif (isObject(_schemaProp.items) && !isNullish(_schemaProp.items.format)) {\n\t\t\t\tfor (let i = 0; i < value.length; i += 1) {\n\t\t\t\t\t(object[key] as unknown[])[i] = convertScalarValue(\n\t\t\t\t\t\tvalue[i],\n\t\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n\t\t\t\t\t\t_schemaProp?.items?.format,\n\t\t\t\t\t\tformat,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tdataPath.pop();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If schema for array items is an object\n\t\t\tif (!Array.isArray(_schemaProp?.items) && _schemaProp?.items?.type === 'object') {\n\t\t\t\tfor (const arrObject of value) {\n\t\t\t\t\tconvert(\n\t\t\t\t\t\tarrObject as Record<string, unknown> | unknown[],\n\t\t\t\t\t\tschema,\n\t\t\t\t\t\tdataPath,\n\t\t\t\t\t\tformat,\n\t\t\t\t\t\toneOfPath,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tdataPath.pop();\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If schema for array is a tuple\n\t\t\tif (Array.isArray(_schemaProp?.items)) {\n\t\t\t\tfor (let i = 0; i < value.length; i += 1) {\n\t\t\t\t\t(object[key] as unknown[])[i] = convertScalarValue(\n\t\t\t\t\t\tvalue[i],\n\t\t\t\t\t\t_schemaProp.items[i].format as string,\n\t\t\t\t\t\tformat,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tdataPath.pop();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tobject[key] = convertScalarValue(value, schemaProp.format as string, format);\n\n\t\tdataPath.pop();\n\t}\n\n\treturn object;\n};\n\nexport const format = <\n\tDataType extends Record<string, unknown> | unknown[] | unknown,\n\tReturnType extends DataFormat,\n>(\n\tschema: ValidationSchemaInput | JsonSchema,\n\tdata: DataType,\n\treturnFormat: ReturnType,\n): FormatType<DataType, ReturnType> => {\n\tlet dataToParse: Record<string, unknown> | unknown[] | unknown;\n\n\tif (isObject(data)) {\n\t\tdataToParse = mergeDeep({}, data);\n\t} else if (Array.isArray(data)) {\n\t\tdataToParse = [...data];\n\t} else {\n\t\tdataToParse = data;\n\t}\n\n\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\tconst jsonSchema: JsonSchema = isObject(schema) ? schema : utils.ethAbiToJsonSchema(schema);\n\n\tif (!jsonSchema.properties && !jsonSchema.items && !jsonSchema.format) {\n\t\tthrow new FormatterError('Invalid json schema for formatting');\n\t}\n\n\treturn convert(dataToParse, jsonSchema, [], returnFormat) as FormatType<\n\t\ttypeof data,\n\t\tReturnType\n\t>;\n};\n"]},"metadata":{},"sourceType":"module"}