{"ast":null,"code":"/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { parseAbiParameter } from 'abitype';\nimport { AbiError } from 'web3-errors';\nimport { isNullish } from 'web3-utils';\nimport { isSimplifiedStructFormat, mapStructNameAndType, mapStructToCoderFormat } from '../utils.js';\nexport const WORD_SIZE = 32;\nexport function alloc() {\n  let size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n  var _a;\n\n  if (((_a = globalThis.Buffer) === null || _a === void 0 ? void 0 : _a.alloc) !== undefined) {\n    const buf = globalThis.Buffer.alloc(size);\n    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n  }\n\n  return new Uint8Array(size);\n}\n/**\n * Where possible returns a Uint8Array of the requested size that references\n * uninitialized memory. Only use if you are certain you will immediately\n * overwrite every value in the returned `Uint8Array`.\n */\n\nexport function allocUnsafe() {\n  let size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n  var _a;\n\n  if (((_a = globalThis.Buffer) === null || _a === void 0 ? void 0 : _a.allocUnsafe) !== undefined) {\n    const buf = globalThis.Buffer.allocUnsafe(size);\n    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n  }\n\n  return new Uint8Array(size);\n}\nexport function convertExternalAbiParameter(abiParam) {\n  var _a, _b;\n\n  return Object.assign(Object.assign({}, abiParam), {\n    name: (_a = abiParam.name) !== null && _a !== void 0 ? _a : '',\n    components: (_b = abiParam.components) === null || _b === void 0 ? void 0 : _b.map(c => convertExternalAbiParameter(c))\n  });\n}\nexport function isAbiParameter(param) {\n  return !isNullish(param) && typeof param === 'object' && !isNullish(param.type) && typeof param.type === 'string';\n}\nexport function toAbiParams(abi) {\n  return abi.map(input => {\n    var _a;\n\n    if (isAbiParameter(input)) {\n      return input;\n    }\n\n    if (typeof input === 'string') {\n      return convertExternalAbiParameter(parseAbiParameter(input.replace(/tuple/, '')));\n    }\n\n    if (isSimplifiedStructFormat(input)) {\n      const structName = Object.keys(input)[0];\n      const structInfo = mapStructNameAndType(structName);\n      structInfo.name = (_a = structInfo.name) !== null && _a !== void 0 ? _a : '';\n      return Object.assign(Object.assign({}, structInfo), {\n        components: mapStructToCoderFormat(input[structName])\n      });\n    }\n\n    throw new AbiError('Invalid abi');\n  });\n}\nexport function extractArrayType(param) {\n  const arrayParenthesisStart = param.type.lastIndexOf('[');\n  const arrayParamType = param.type.substring(0, arrayParenthesisStart);\n  const sizeString = param.type.substring(arrayParenthesisStart);\n  let size = -1;\n\n  if (sizeString !== '[]') {\n    size = Number(sizeString.slice(1, -1)); // eslint-disable-next-line no-restricted-globals\n\n    if (isNaN(size)) {\n      throw new AbiError('Invalid fixed array size', {\n        size: sizeString\n      });\n    }\n  }\n\n  return {\n    param: {\n      type: arrayParamType,\n      name: '',\n      components: param.components\n    },\n    size\n  };\n}\n/**\n * Param is dynamic if it's dynamic base type or if some of his children (components, array items)\n * is of dynamic type\n * @param param\n */\n\nexport function isDynamic(param) {\n  var _a, _b;\n\n  if (param.type === 'string' || param.type === 'bytes' || param.type.endsWith('[]')) return true;\n\n  if (param.type === 'tuple') {\n    return (_b = (_a = param.components) === null || _a === void 0 ? void 0 : _a.some(isDynamic)) !== null && _b !== void 0 ? _b : false;\n  }\n\n  if (param.type.endsWith(']')) {\n    return isDynamic(extractArrayType(param).param);\n  }\n\n  return false;\n}","map":{"version":3,"mappings":"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","names":["parseAbiParameter","AbiError","isNullish","isSimplifiedStructFormat","mapStructNameAndType","mapStructToCoderFormat","WORD_SIZE","alloc","size","Buffer","_a","undefined","buf","globalThis","Uint8Array","buffer","byteOffset","byteLength","allocUnsafe","convertExternalAbiParameter","abiParam","name","components","_b","map","c","isAbiParameter","param","type","toAbiParams","abi","input","replace","structName","Object","keys","structInfo","extractArrayType","arrayParenthesisStart","lastIndexOf","arrayParamType","substring","sizeString","Number","slice","isNaN","isDynamic","endsWith","some"],"sources":["/home/rupam/Desktop/Faucet-React/node_modules/web3-eth-abi/src/coders/utils.ts"],"sourcesContent":["/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport { AbiParameter as ExternalAbiParameter, parseAbiParameter } from 'abitype';\nimport { AbiError } from 'web3-errors';\nimport { AbiInput, AbiParameter, AbiStruct } from 'web3-types';\nimport { isNullish } from 'web3-utils';\nimport {\n\tisSimplifiedStructFormat,\n\tmapStructNameAndType,\n\tmapStructToCoderFormat,\n} from '../utils.js';\n\nexport const WORD_SIZE = 32;\n\nexport function alloc(size = 0): Uint8Array {\n\tif (globalThis.Buffer?.alloc !== undefined) {\n\t\tconst buf = globalThis.Buffer.alloc(size);\n\t\treturn new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n\t}\n\n\treturn new Uint8Array(size);\n}\n\n/**\n * Where possible returns a Uint8Array of the requested size that references\n * uninitialized memory. Only use if you are certain you will immediately\n * overwrite every value in the returned `Uint8Array`.\n */\nexport function allocUnsafe(size = 0): Uint8Array {\n\tif (globalThis.Buffer?.allocUnsafe !== undefined) {\n\t\tconst buf = globalThis.Buffer.allocUnsafe(size);\n\t\treturn new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n\t}\n\n\treturn new Uint8Array(size);\n}\n\nexport function convertExternalAbiParameter(abiParam: ExternalAbiParameter): AbiParameter {\n\treturn {\n\t\t...abiParam,\n\t\tname: abiParam.name ?? '',\n\t\tcomponents: (abiParam as { components: readonly AbiParameter[] }).components?.map(c =>\n\t\t\tconvertExternalAbiParameter(c),\n\t\t),\n\t};\n}\n\nexport function isAbiParameter(param: unknown): param is AbiParameter {\n\treturn (\n\t\t!isNullish(param) &&\n\t\ttypeof param === 'object' &&\n\t\t!isNullish((param as { type: unknown }).type) &&\n\t\ttypeof (param as { type: unknown }).type === 'string'\n\t);\n}\n\nexport function toAbiParams(abi: ReadonlyArray<AbiInput>): ReadonlyArray<AbiParameter> {\n\treturn abi.map(input => {\n\t\tif (isAbiParameter(input)) {\n\t\t\treturn input;\n\t\t}\n\t\tif (typeof input === 'string') {\n\t\t\treturn convertExternalAbiParameter(parseAbiParameter(input.replace(/tuple/, '')));\n\t\t}\n\n\t\tif (isSimplifiedStructFormat(input)) {\n\t\t\tconst structName = Object.keys(input)[0];\n\t\t\tconst structInfo = mapStructNameAndType(structName);\n\t\t\tstructInfo.name = structInfo.name ?? '';\n\t\t\treturn {\n\t\t\t\t...structInfo,\n\t\t\t\tcomponents: mapStructToCoderFormat(\n\t\t\t\t\tinput[structName as keyof typeof input] as unknown as AbiStruct,\n\t\t\t\t),\n\t\t\t};\n\t\t}\n\t\tthrow new AbiError('Invalid abi');\n\t});\n}\n\nexport function extractArrayType(param: AbiParameter): { size: number; param: AbiParameter } {\n\tconst arrayParenthesisStart = param.type.lastIndexOf('[');\n\tconst arrayParamType = param.type.substring(0, arrayParenthesisStart);\n\tconst sizeString = param.type.substring(arrayParenthesisStart);\n\tlet size = -1;\n\tif (sizeString !== '[]') {\n\t\tsize = Number(sizeString.slice(1, -1));\n\t\t// eslint-disable-next-line no-restricted-globals\n\t\tif (isNaN(size)) {\n\t\t\tthrow new AbiError('Invalid fixed array size', { size: sizeString });\n\t\t}\n\t}\n\treturn {\n\t\tparam: { type: arrayParamType, name: '', components: param.components },\n\t\tsize,\n\t};\n}\n\n/**\n * Param is dynamic if it's dynamic base type or if some of his children (components, array items)\n * is of dynamic type\n * @param param\n */\nexport function isDynamic(param: AbiParameter): boolean {\n\tif (param.type === 'string' || param.type === 'bytes' || param.type.endsWith('[]')) return true;\n\tif (param.type === 'tuple') {\n\t\treturn param.components?.some(isDynamic) ?? false;\n\t}\n\tif (param.type.endsWith(']')) {\n\t\treturn isDynamic(extractArrayType(param).param);\n\t}\n\treturn false;\n}\n"]},"metadata":{},"sourceType":"module"}