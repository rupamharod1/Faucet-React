{"ast":null,"code":"\"use strict\";\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getCreateAccessListParams = exports.isWeb3ContractContext = exports.isContractInitOptions = exports.getEstimateGasParams = exports.getEthTxCallParams = exports.getSendTxParams = void 0;\n\nconst web3_errors_1 = require(\"web3-errors\");\n\nconst web3_utils_1 = require(\"web3-utils\");\n\nconst encoding_js_1 = require(\"./encoding.js\");\n\nconst dataInputEncodeMethodHelper = (txParams, abi, params, dataInputFill) => {\n  var _a, _b;\n\n  const tx = {};\n\n  if (!(0, web3_utils_1.isNullish)(txParams.data) || dataInputFill === 'both') {\n    tx.data = (0, encoding_js_1.encodeMethodABI)(abi, params, (_a = txParams.data) !== null && _a !== void 0 ? _a : txParams.input);\n  }\n\n  if (!(0, web3_utils_1.isNullish)(txParams.input) || dataInputFill === 'both') {\n    tx.input = (0, encoding_js_1.encodeMethodABI)(abi, params, (_b = txParams.input) !== null && _b !== void 0 ? _b : txParams.data);\n  } // if input and data is empty, use web3config default\n\n\n  if ((0, web3_utils_1.isNullish)(tx.input) && (0, web3_utils_1.isNullish)(tx.data)) {\n    tx[dataInputFill] = (0, encoding_js_1.encodeMethodABI)(abi, params);\n  }\n\n  return {\n    data: tx.data,\n    input: tx.input\n  };\n};\n\nconst getSendTxParams = _ref => {\n  let {\n    abi,\n    params,\n    options,\n    contractOptions\n  } = _ref;\n\n  var _a, _b, _c;\n\n  const deploymentCall = (_c = (_b = (_a = options === null || options === void 0 ? void 0 : options.input) !== null && _a !== void 0 ? _a : options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : contractOptions.input) !== null && _c !== void 0 ? _c : contractOptions.data;\n\n  if (!deploymentCall && !(options === null || options === void 0 ? void 0 : options.to) && !contractOptions.address) {\n    throw new web3_errors_1.Web3ContractError('Contract address not specified');\n  }\n\n  if (!(options === null || options === void 0 ? void 0 : options.from) && !contractOptions.from) {\n    throw new web3_errors_1.Web3ContractError('Contract \"from\" address not specified');\n  }\n\n  let txParams = (0, web3_utils_1.mergeDeep)({\n    to: contractOptions.address,\n    gas: contractOptions.gas,\n    gasPrice: contractOptions.gasPrice,\n    from: contractOptions.from,\n    input: contractOptions.input,\n    maxPriorityFeePerGas: contractOptions.maxPriorityFeePerGas,\n    maxFeePerGas: contractOptions.maxFeePerGas,\n    data: contractOptions.data\n  }, options);\n  const dataInput = dataInputEncodeMethodHelper(txParams, abi, params, options === null || options === void 0 ? void 0 : options.dataInputFill);\n  txParams = Object.assign(Object.assign({}, txParams), {\n    data: dataInput.data,\n    input: dataInput.input\n  });\n  return txParams;\n};\n\nexports.getSendTxParams = getSendTxParams;\n\nconst getEthTxCallParams = _ref2 => {\n  let {\n    abi,\n    params,\n    options,\n    contractOptions\n  } = _ref2;\n\n  if (!(options === null || options === void 0 ? void 0 : options.to) && !contractOptions.address) {\n    throw new web3_errors_1.Web3ContractError('Contract address not specified');\n  }\n\n  let txParams = (0, web3_utils_1.mergeDeep)({\n    to: contractOptions.address,\n    gas: contractOptions.gas,\n    gasPrice: contractOptions.gasPrice,\n    from: contractOptions.from,\n    input: contractOptions.input,\n    maxPriorityFeePerGas: contractOptions.maxPriorityFeePerGas,\n    maxFeePerGas: contractOptions.maxFeePerGas,\n    data: contractOptions.data\n  }, options);\n  const dataInput = dataInputEncodeMethodHelper(txParams, abi, params, options === null || options === void 0 ? void 0 : options.dataInputFill);\n  txParams = Object.assign(Object.assign({}, txParams), {\n    data: dataInput.data,\n    input: dataInput.input\n  });\n  return txParams;\n};\n\nexports.getEthTxCallParams = getEthTxCallParams;\n\nconst getEstimateGasParams = _ref3 => {\n  let {\n    abi,\n    params,\n    options,\n    contractOptions\n  } = _ref3;\n  let txParams = (0, web3_utils_1.mergeDeep)({\n    to: contractOptions.address,\n    gas: contractOptions.gas,\n    gasPrice: contractOptions.gasPrice,\n    from: contractOptions.from,\n    input: contractOptions.input,\n    data: contractOptions.data\n  }, options);\n  const dataInput = dataInputEncodeMethodHelper(txParams, abi, params, options === null || options === void 0 ? void 0 : options.dataInputFill);\n  txParams = Object.assign(Object.assign({}, txParams), {\n    data: dataInput.data,\n    input: dataInput.input\n  });\n  return txParams;\n};\n\nexports.getEstimateGasParams = getEstimateGasParams;\n\nconst isContractInitOptions = options => typeof options === 'object' && !(0, web3_utils_1.isNullish)(options) && ['input', 'data', 'from', 'gas', 'gasPrice', 'gasLimit', 'address', 'jsonInterface', 'syncWithContext', 'dataInputFill'].some(key => key in options);\n\nexports.isContractInitOptions = isContractInitOptions;\n\nconst isWeb3ContractContext = options => typeof options === 'object' && !(0, web3_utils_1.isNullish)(options) && !(0, exports.isContractInitOptions)(options);\n\nexports.isWeb3ContractContext = isWeb3ContractContext;\n\nconst getCreateAccessListParams = _ref4 => {\n  let {\n    abi,\n    params,\n    options,\n    contractOptions\n  } = _ref4;\n\n  if (!(options === null || options === void 0 ? void 0 : options.to) && !contractOptions.address) {\n    throw new web3_errors_1.Web3ContractError('Contract address not specified');\n  }\n\n  if (!(options === null || options === void 0 ? void 0 : options.from) && !contractOptions.from) {\n    throw new web3_errors_1.Web3ContractError('Contract \"from\" address not specified');\n  }\n\n  let txParams = (0, web3_utils_1.mergeDeep)({\n    to: contractOptions.address,\n    gas: contractOptions.gas,\n    gasPrice: contractOptions.gasPrice,\n    from: contractOptions.from,\n    input: contractOptions.input,\n    maxPriorityFeePerGas: contractOptions.maxPriorityFeePerGas,\n    maxFeePerGas: contractOptions.maxFeePerGas,\n    data: contractOptions.data\n  }, options);\n  const dataInput = dataInputEncodeMethodHelper(txParams, abi, params, options === null || options === void 0 ? void 0 : options.dataInputFill);\n  txParams = Object.assign(Object.assign({}, txParams), {\n    data: dataInput.data,\n    input: dataInput.input\n  });\n  return txParams;\n};\n\nexports.getCreateAccessListParams = getCreateAccessListParams;","map":{"version":3,"mappings":"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","names":["dataInputEncodeMethodHelper","txParams","abi","params","dataInputFill","tx","data","_a","input","_b","getSendTxParams","options","contractOptions","deploymentCall","_c","to","address","web3_errors_1","from","gas","gasPrice","maxPriorityFeePerGas","maxFeePerGas","dataInput","exports","getEthTxCallParams","getEstimateGasParams","isContractInitOptions","some","key","isWeb3ContractContext","getCreateAccessListParams"],"sources":["/home/rupam/Desktop/Faucet-React/node_modules/web3-eth-contract/src/utils.ts"],"sourcesContent":["﻿/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport { Web3ContractError } from 'web3-errors';\nimport {\n\tTransactionForAccessList,\n\tAbiFunctionFragment,\n\tTransactionWithSenderAPI,\n\tTransactionCall,\n\tHexString,\n\tAddress,\n\tNonPayableCallOptions,\n\tPayableCallOptions,\n\tContractInitOptions,\n\tContractOptions,\n} from 'web3-types';\nimport { isNullish, mergeDeep } from 'web3-utils';\nimport { encodeMethodABI } from './encoding.js';\nimport { Web3ContractContext } from './types.js';\n\nconst dataInputEncodeMethodHelper = (\n\ttxParams: TransactionCall | TransactionForAccessList,\n\tabi: AbiFunctionFragment,\n\tparams: unknown[],\n\tdataInputFill?: 'data' | 'input' | 'both',\n): { data?: HexString; input?: HexString } => {\n\tconst tx: { data?: HexString; input?: HexString } = {};\n\tif (!isNullish(txParams.data) || dataInputFill === 'both') {\n\t\ttx.data = encodeMethodABI(abi, params, (txParams.data ?? txParams.input) as HexString);\n\t}\n\tif (!isNullish(txParams.input) || dataInputFill === 'both') {\n\t\ttx.input = encodeMethodABI(abi, params, (txParams.input ?? txParams.data) as HexString);\n\t}\n\t// if input and data is empty, use web3config default\n\tif (isNullish(tx.input) && isNullish(tx.data)) {\n\t\ttx[dataInputFill as 'data' | 'input'] = encodeMethodABI(abi, params);\n\t}\n\n\treturn { data: tx.data as HexString, input: tx.input as HexString };\n};\n\nexport const getSendTxParams = ({\n\tabi,\n\tparams,\n\toptions,\n\tcontractOptions,\n}: {\n\tabi: AbiFunctionFragment;\n\tparams: unknown[];\n\toptions?: (PayableCallOptions | NonPayableCallOptions) & {\n\t\tinput?: HexString;\n\t\tdata?: HexString;\n\t\tto?: Address;\n\t\tdataInputFill?: 'input' | 'data' | 'both';\n\t};\n\tcontractOptions: ContractOptions;\n}): TransactionCall => {\n\tconst deploymentCall =\n\t\toptions?.input ?? options?.data ?? contractOptions.input ?? contractOptions.data;\n\tif (!deploymentCall && !options?.to && !contractOptions.address) {\n\t\tthrow new Web3ContractError('Contract address not specified');\n\t}\n\n\tif (!options?.from && !contractOptions.from) {\n\t\tthrow new Web3ContractError('Contract \"from\" address not specified');\n\t}\n\tlet txParams = mergeDeep(\n\t\t{\n\t\t\tto: contractOptions.address,\n\t\t\tgas: contractOptions.gas,\n\t\t\tgasPrice: contractOptions.gasPrice,\n\t\t\tfrom: contractOptions.from,\n\t\t\tinput: contractOptions.input,\n\t\t\tmaxPriorityFeePerGas: contractOptions.maxPriorityFeePerGas,\n\t\t\tmaxFeePerGas: contractOptions.maxFeePerGas,\n\t\t\tdata: contractOptions.data,\n\t\t},\n\t\toptions as unknown as Record<string, unknown>,\n\t) as unknown as TransactionCall;\n\tconst dataInput = dataInputEncodeMethodHelper(txParams, abi, params, options?.dataInputFill);\n\ttxParams = { ...txParams, data: dataInput.data, input: dataInput.input };\n\n\treturn txParams;\n};\n\nexport const getEthTxCallParams = ({\n\tabi,\n\tparams,\n\toptions,\n\tcontractOptions,\n}: {\n\tabi: AbiFunctionFragment;\n\tparams: unknown[];\n\toptions?: (PayableCallOptions | NonPayableCallOptions) & {\n\t\tto?: Address;\n\t\tdataInputFill?: 'input' | 'data' | 'both';\n\t};\n\tcontractOptions: ContractOptions;\n}): TransactionCall => {\n\tif (!options?.to && !contractOptions.address) {\n\t\tthrow new Web3ContractError('Contract address not specified');\n\t}\n\tlet txParams = mergeDeep(\n\t\t{\n\t\t\tto: contractOptions.address,\n\t\t\tgas: contractOptions.gas,\n\t\t\tgasPrice: contractOptions.gasPrice,\n\t\t\tfrom: contractOptions.from,\n\t\t\tinput: contractOptions.input,\n\t\t\tmaxPriorityFeePerGas: contractOptions.maxPriorityFeePerGas,\n\t\t\tmaxFeePerGas: contractOptions.maxFeePerGas,\n\t\t\tdata: contractOptions.data,\n\t\t},\n\t\toptions as unknown as Record<string, unknown>,\n\t) as unknown as TransactionCall;\n\n\tconst dataInput = dataInputEncodeMethodHelper(txParams, abi, params, options?.dataInputFill);\n\ttxParams = { ...txParams, data: dataInput.data, input: dataInput.input };\n\n\treturn txParams;\n};\n\nexport const getEstimateGasParams = ({\n\tabi,\n\tparams,\n\toptions,\n\tcontractOptions,\n}: {\n\tabi: AbiFunctionFragment;\n\tparams: unknown[];\n\toptions?: (PayableCallOptions | NonPayableCallOptions) & {\n\t\tdataInputFill?: 'input' | 'data' | 'both';\n\t};\n\tcontractOptions: ContractOptions;\n}): Partial<TransactionWithSenderAPI> => {\n\tlet txParams = mergeDeep(\n\t\t{\n\t\t\tto: contractOptions.address,\n\t\t\tgas: contractOptions.gas,\n\t\t\tgasPrice: contractOptions.gasPrice,\n\t\t\tfrom: contractOptions.from,\n\t\t\tinput: contractOptions.input,\n\t\t\tdata: contractOptions.data,\n\t\t},\n\t\toptions as unknown as Record<string, unknown>,\n\t) as unknown as TransactionCall;\n\n\tconst dataInput = dataInputEncodeMethodHelper(txParams, abi, params, options?.dataInputFill);\n\ttxParams = { ...txParams, data: dataInput.data, input: dataInput.input };\n\n\treturn txParams as TransactionWithSenderAPI;\n};\n\nexport const isContractInitOptions = (options: unknown): options is ContractInitOptions =>\n\ttypeof options === 'object' &&\n\t!isNullish(options) &&\n\t[\n\t\t'input',\n\t\t'data',\n\t\t'from',\n\t\t'gas',\n\t\t'gasPrice',\n\t\t'gasLimit',\n\t\t'address',\n\t\t'jsonInterface',\n\t\t'syncWithContext',\n\t\t'dataInputFill',\n\t].some(key => key in options);\n\nexport const isWeb3ContractContext = (options: unknown): options is Web3ContractContext =>\n\ttypeof options === 'object' && !isNullish(options) && !isContractInitOptions(options);\n\nexport const getCreateAccessListParams = ({\n\tabi,\n\tparams,\n\toptions,\n\tcontractOptions,\n}: {\n\tabi: AbiFunctionFragment;\n\tparams: unknown[];\n\toptions?: (PayableCallOptions | NonPayableCallOptions) & {\n\t\tto?: Address;\n\t\tdataInputFill?: 'input' | 'data' | 'both';\n\t};\n\tcontractOptions: ContractOptions;\n}): TransactionForAccessList => {\n\tif (!options?.to && !contractOptions.address) {\n\t\tthrow new Web3ContractError('Contract address not specified');\n\t}\n\n\tif (!options?.from && !contractOptions.from) {\n\t\tthrow new Web3ContractError('Contract \"from\" address not specified');\n\t}\n\n\tlet txParams = mergeDeep(\n\t\t{\n\t\t\tto: contractOptions.address,\n\t\t\tgas: contractOptions.gas,\n\t\t\tgasPrice: contractOptions.gasPrice,\n\t\t\tfrom: contractOptions.from,\n\t\t\tinput: contractOptions.input,\n\t\t\tmaxPriorityFeePerGas: contractOptions.maxPriorityFeePerGas,\n\t\t\tmaxFeePerGas: contractOptions.maxFeePerGas,\n\t\t\tdata: contractOptions.data,\n\t\t},\n\t\toptions as unknown as Record<string, unknown>,\n\t) as unknown as TransactionForAccessList;\n\n\tconst dataInput = dataInputEncodeMethodHelper(txParams, abi, params, options?.dataInputFill);\n\ttxParams = { ...txParams, data: dataInput.data, input: dataInput.input };\n\n\treturn txParams;\n};\n"]},"metadata":{},"sourceType":"script"}