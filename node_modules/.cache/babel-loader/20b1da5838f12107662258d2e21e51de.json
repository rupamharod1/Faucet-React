{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SocketProvider = void 0;\n\nconst web3_errors_1 = require(\"web3-errors\");\n\nconst web3_eip1193_provider_js_1 = require(\"./web3_eip1193_provider.js\");\n\nconst chunk_response_parser_js_1 = require(\"./chunk_response_parser.js\");\n\nconst validation_js_1 = require(\"./validation.js\");\n\nconst web3_deferred_promise_js_1 = require(\"./web3_deferred_promise.js\");\n\nconst jsonRpc = __importStar(require(\"./json_rpc.js\"));\n\nconst DEFAULT_RECONNECTION_OPTIONS = {\n  autoReconnect: true,\n  delay: 5000,\n  maxAttempts: 5\n};\nconst NORMAL_CLOSE_CODE = 1000; // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close\n\nclass SocketProvider extends web3_eip1193_provider_js_1.Eip1193Provider {\n  /**\n   * This is an abstract class for implementing a socket provider (e.g. WebSocket, IPC). It extends the EIP-1193 provider {@link EIP1193Provider}.\n   * @param socketPath - The path to the socket (e.g. /ipc/path or ws://localhost:8546)\n   * @param socketOptions - The options for the socket connection. Its type is supposed to be specified in the inherited classes.\n   * @param reconnectOptions - The options for the socket reconnection {@link ReconnectOptions}\n   */\n  constructor(socketPath, socketOptions, reconnectOptions) {\n    super();\n    this._connectionStatus = 'connecting'; // Message handlers. Due to bounding of `this` and removing the listeners we have to keep it's reference.\n\n    this._onMessageHandler = this._onMessage.bind(this);\n    this._onOpenHandler = this._onConnect.bind(this);\n    this._onCloseHandler = this._onCloseEvent.bind(this);\n    this._onErrorHandler = this._onError.bind(this);\n    if (!this._validateProviderPath(socketPath)) throw new web3_errors_1.InvalidClientError(socketPath);\n    this._socketPath = socketPath;\n    this._socketOptions = socketOptions;\n    this._reconnectOptions = Object.assign(Object.assign({}, DEFAULT_RECONNECTION_OPTIONS), reconnectOptions !== null && reconnectOptions !== void 0 ? reconnectOptions : {});\n    this._pendingRequestsQueue = new Map();\n    this._sentRequestsQueue = new Map();\n\n    this._init();\n\n    this.connect();\n    this.chunkResponseParser = new chunk_response_parser_js_1.ChunkResponseParser(this._eventEmitter, this._reconnectOptions.autoReconnect);\n    this.chunkResponseParser.onError(() => {\n      this._clearQueues();\n    });\n    this.isReconnecting = false;\n  }\n\n  get SocketConnection() {\n    return this._socketConnection;\n  }\n\n  _init() {\n    this._reconnectAttempts = 0;\n  }\n  /**\n   * Try to establish a connection to the socket\n   */\n\n\n  connect() {\n    try {\n      this._openSocketConnection();\n\n      this._connectionStatus = 'connecting';\n\n      this._addSocketListeners();\n    } catch (e) {\n      if (!this.isReconnecting) {\n        this._connectionStatus = 'disconnected';\n\n        if (e && e.message) {\n          throw new web3_errors_1.ConnectionError(`Error while connecting to ${this._socketPath}. Reason: ${e.message}`);\n        } else {\n          throw new web3_errors_1.InvalidClientError(this._socketPath);\n        }\n      } else {\n        setImmediate(() => {\n          this._reconnect();\n        });\n      }\n    }\n  } // eslint-disable-next-line class-methods-use-this\n\n\n  _validateProviderPath(path) {\n    return !!path;\n  }\n  /**\n   *\n   * @returns `true` if the socket supports subscriptions\n   */\n  // eslint-disable-next-line class-methods-use-this\n\n\n  supportsSubscriptions() {\n    return true;\n  }\n\n  on(type, listener) {\n    this._eventEmitter.on(type, listener);\n  }\n\n  once(type, listener) {\n    this._eventEmitter.once(type, listener);\n  }\n\n  removeListener(type, listener) {\n    this._eventEmitter.removeListener(type, listener);\n  }\n\n  _onDisconnect(code, data) {\n    this._connectionStatus = 'disconnected';\n\n    super._onDisconnect(code, data);\n  }\n  /**\n   * Disconnects the socket\n   * @param code - The code to be sent to the server\n   * @param data - The data to be sent to the server\n   */\n\n\n  disconnect(code, data) {\n    const disconnectCode = code !== null && code !== void 0 ? code : NORMAL_CLOSE_CODE;\n\n    this._removeSocketListeners();\n\n    if (this.getStatus() !== 'disconnected') {\n      this._closeSocketConnection(disconnectCode, data);\n    }\n\n    this._onDisconnect(disconnectCode, data);\n  }\n  /**\n   * Removes all listeners for the specified event type.\n   * @param type - The event type to remove the listeners for\n   */\n\n\n  removeAllListeners(type) {\n    this._eventEmitter.removeAllListeners(type);\n  }\n\n  _onError(event) {\n    // do not emit error while trying to reconnect\n    if (this.isReconnecting) {\n      this._reconnect();\n    } else {\n      this._eventEmitter.emit('error', event);\n    }\n  }\n  /**\n   * Resets the socket, removing all listeners and pending requests\n   */\n\n\n  reset() {\n    this._sentRequestsQueue.clear();\n\n    this._pendingRequestsQueue.clear();\n\n    this._init();\n\n    this._removeSocketListeners();\n\n    this._addSocketListeners();\n  }\n\n  _reconnect() {\n    if (this.isReconnecting) {\n      return;\n    }\n\n    this.isReconnecting = true;\n\n    if (this._sentRequestsQueue.size > 0) {\n      this._sentRequestsQueue.forEach((request, key) => {\n        request.deferredPromise.reject(new web3_errors_1.PendingRequestsOnReconnectingError());\n\n        this._sentRequestsQueue.delete(key);\n      });\n    }\n\n    if (this._reconnectAttempts < this._reconnectOptions.maxAttempts) {\n      this._reconnectAttempts += 1;\n      setTimeout(() => {\n        this._removeSocketListeners();\n\n        this.connect();\n        this.isReconnecting = false;\n      }, this._reconnectOptions.delay);\n    } else {\n      this.isReconnecting = false;\n\n      this._clearQueues();\n\n      this._removeSocketListeners();\n\n      this._eventEmitter.emit('error', new web3_errors_1.MaxAttemptsReachedOnReconnectingError(this._reconnectOptions.maxAttempts));\n    }\n  }\n  /**\n   *  Creates a request object to be sent to the server\n   */\n\n\n  request(request) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if ((0, validation_js_1.isNullish)(this._socketConnection)) {\n        throw new Error('Connection is undefined');\n      } // if socket disconnected - open connection\n\n\n      if (this.getStatus() === 'disconnected') {\n        this.connect();\n      }\n\n      const requestId = jsonRpc.isBatchRequest(request) ? request[0].id : request.id;\n\n      if (!requestId) {\n        throw new web3_errors_1.Web3WSProviderError('Request Id not defined');\n      }\n\n      if (this._sentRequestsQueue.has(requestId)) {\n        throw new web3_errors_1.RequestAlreadySentError(requestId);\n      }\n\n      const deferredPromise = new web3_deferred_promise_js_1.Web3DeferredPromise();\n      deferredPromise.catch(error => {\n        this._eventEmitter.emit('error', error);\n      });\n      const reqItem = {\n        payload: request,\n        deferredPromise\n      };\n\n      if (this.getStatus() === 'connecting') {\n        this._pendingRequestsQueue.set(requestId, reqItem);\n\n        return reqItem.deferredPromise;\n      }\n\n      this._sentRequestsQueue.set(requestId, reqItem);\n\n      try {\n        this._sendToSocket(reqItem.payload);\n      } catch (error) {\n        this._sentRequestsQueue.delete(requestId);\n\n        this._eventEmitter.emit('error', error);\n      }\n\n      return deferredPromise;\n    });\n  }\n\n  _onConnect() {\n    this._connectionStatus = 'connected';\n    this._reconnectAttempts = 0;\n\n    super._onConnect();\n\n    this._sendPendingRequests();\n  }\n\n  _sendPendingRequests() {\n    for (const [id, value] of this._pendingRequestsQueue.entries()) {\n      this._sendToSocket(value.payload);\n\n      this._pendingRequestsQueue.delete(id);\n\n      this._sentRequestsQueue.set(id, value);\n    }\n  }\n\n  _onMessage(event) {\n    const responses = this._parseResponses(event);\n\n    if ((0, validation_js_1.isNullish)(responses) || responses.length === 0) {\n      return;\n    }\n\n    for (const response of responses) {\n      if (jsonRpc.isResponseWithNotification(response) && response.method.endsWith('_subscription')) {\n        this._eventEmitter.emit('message', response);\n\n        return;\n      }\n\n      const requestId = jsonRpc.isBatchResponse(response) ? response[0].id : response.id;\n\n      const requestItem = this._sentRequestsQueue.get(requestId);\n\n      if (!requestItem) {\n        return;\n      }\n\n      if (jsonRpc.isBatchResponse(response) || jsonRpc.isResponseWithResult(response) || jsonRpc.isResponseWithError(response)) {\n        this._eventEmitter.emit('message', response);\n\n        requestItem.deferredPromise.resolve(response);\n      }\n\n      this._sentRequestsQueue.delete(requestId);\n    }\n  }\n\n  _clearQueues(event) {\n    if (this._pendingRequestsQueue.size > 0) {\n      this._pendingRequestsQueue.forEach((request, key) => {\n        request.deferredPromise.reject(new web3_errors_1.ConnectionNotOpenError(event));\n\n        this._pendingRequestsQueue.delete(key);\n      });\n    }\n\n    if (this._sentRequestsQueue.size > 0) {\n      this._sentRequestsQueue.forEach((request, key) => {\n        request.deferredPromise.reject(new web3_errors_1.ConnectionNotOpenError(event));\n\n        this._sentRequestsQueue.delete(key);\n      });\n    }\n\n    this._removeSocketListeners();\n  }\n\n}\n\nexports.SocketProvider = SocketProvider;","map":{"version":3,"mappings":"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","names":["DEFAULT_RECONNECTION_OPTIONS","autoReconnect","delay","maxAttempts","NORMAL_CLOSE_CODE","SocketProvider","web3_eip1193_provider_js_1","constructor","socketPath","socketOptions","reconnectOptions","_connectionStatus","_onMessageHandler","_onMessage","bind","_onOpenHandler","_onConnect","_onCloseHandler","_onCloseEvent","_onErrorHandler","_onError","_validateProviderPath","web3_errors_1","_socketPath","_socketOptions","_reconnectOptions","Object","_pendingRequestsQueue","Map","_sentRequestsQueue","_init","connect","chunkResponseParser","chunk_response_parser_js_1","_eventEmitter","onError","_clearQueues","isReconnecting","SocketConnection","_socketConnection","_reconnectAttempts","_openSocketConnection","_addSocketListeners","e","message","setImmediate","_reconnect","path","supportsSubscriptions","on","type","listener","once","removeListener","_onDisconnect","code","data","disconnect","disconnectCode","_removeSocketListeners","getStatus","_closeSocketConnection","removeAllListeners","event","emit","reset","clear","size","forEach","request","key","deferredPromise","reject","delete","setTimeout","Error","requestId","jsonRpc","isBatchRequest","id","has","web3_deferred_promise_js_1","catch","error","reqItem","payload","set","_sendToSocket","_sendPendingRequests","value","entries","responses","_parseResponses","length","response","isResponseWithNotification","method","endsWith","isBatchResponse","requestItem","get","isResponseWithResult","isResponseWithError","resolve","exports"],"sources":["/home/rupam/Desktop/Faucet-React/node_modules/web3-utils/src/socket_provider.ts"],"sourcesContent":["/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport {\n\tConnectionEvent,\n\tEip1193EventName,\n\tEthExecutionAPI,\n\tJsonRpcBatchRequest,\n\tJsonRpcBatchResponse,\n\tJsonRpcId,\n\tJsonRpcNotification,\n\tJsonRpcRequest,\n\tJsonRpcResponse,\n\tJsonRpcResponseWithResult,\n\tJsonRpcResult,\n\tProviderConnectInfo,\n\tProviderMessage,\n\tProviderRpcError,\n\tSocketRequestItem,\n\tWeb3APIMethod,\n\tWeb3APIPayload,\n\tWeb3APIReturnType,\n\tWeb3APISpec,\n\tWeb3Eip1193ProviderEventCallback,\n\tWeb3ProviderEventCallback,\n\tWeb3ProviderMessageEventCallback,\n\tWeb3ProviderStatus,\n} from 'web3-types';\nimport {\n\tConnectionError,\n\tConnectionNotOpenError,\n\tInvalidClientError,\n\tMaxAttemptsReachedOnReconnectingError,\n\tPendingRequestsOnReconnectingError,\n\tRequestAlreadySentError,\n\tWeb3WSProviderError,\n} from 'web3-errors';\nimport { Eip1193Provider } from './web3_eip1193_provider.js';\nimport { ChunkResponseParser } from './chunk_response_parser.js';\nimport { isNullish } from './validation.js';\nimport { Web3DeferredPromise } from './web3_deferred_promise.js';\nimport * as jsonRpc from './json_rpc.js';\n\nexport type ReconnectOptions = {\n\tautoReconnect: boolean;\n\tdelay: number;\n\tmaxAttempts: number;\n};\n\nconst DEFAULT_RECONNECTION_OPTIONS = {\n\tautoReconnect: true,\n\tdelay: 5000,\n\tmaxAttempts: 5,\n};\n\nconst NORMAL_CLOSE_CODE = 1000; // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close\n\nexport abstract class SocketProvider<\n\tMessageEvent,\n\tCloseEvent,\n\tErrorEvent,\n\tAPI extends Web3APISpec = EthExecutionAPI,\n> extends Eip1193Provider<API> {\n\tprotected isReconnecting: boolean;\n\tprotected readonly _socketPath: string;\n\tprotected readonly chunkResponseParser: ChunkResponseParser;\n\t/* eslint-disable @typescript-eslint/no-explicit-any */\n\tprotected readonly _pendingRequestsQueue: Map<JsonRpcId, SocketRequestItem<any, any, any>>;\n\t/* eslint-disable @typescript-eslint/no-explicit-any */\n\tprotected readonly _sentRequestsQueue: Map<JsonRpcId, SocketRequestItem<any, any, any>>;\n\tprotected _reconnectAttempts!: number;\n\tprotected readonly _socketOptions?: unknown;\n\tprotected readonly _reconnectOptions: ReconnectOptions;\n\tprotected _socketConnection?: unknown;\n\tpublic get SocketConnection() {\n\t\treturn this._socketConnection;\n\t}\n\tprotected _connectionStatus: Web3ProviderStatus;\n\tprotected readonly _onMessageHandler: (event: MessageEvent) => void;\n\tprotected readonly _onOpenHandler: () => void;\n\tprotected readonly _onCloseHandler: (event: CloseEvent) => void;\n\tprotected readonly _onErrorHandler: (event: ErrorEvent) => void;\n\n\t/**\n\t * This is an abstract class for implementing a socket provider (e.g. WebSocket, IPC). It extends the EIP-1193 provider {@link EIP1193Provider}.\n\t * @param socketPath - The path to the socket (e.g. /ipc/path or ws://localhost:8546)\n\t * @param socketOptions - The options for the socket connection. Its type is supposed to be specified in the inherited classes.\n\t * @param reconnectOptions - The options for the socket reconnection {@link ReconnectOptions}\n\t */\n\tpublic constructor(\n\t\tsocketPath: string,\n\t\tsocketOptions?: unknown,\n\t\treconnectOptions?: Partial<ReconnectOptions>,\n\t) {\n\t\tsuper();\n\t\tthis._connectionStatus = 'connecting';\n\n\t\t// Message handlers. Due to bounding of `this` and removing the listeners we have to keep it's reference.\n\t\tthis._onMessageHandler = this._onMessage.bind(this);\n\t\tthis._onOpenHandler = this._onConnect.bind(this);\n\t\tthis._onCloseHandler = this._onCloseEvent.bind(this);\n\t\tthis._onErrorHandler = this._onError.bind(this);\n\n\t\tif (!this._validateProviderPath(socketPath)) throw new InvalidClientError(socketPath);\n\n\t\tthis._socketPath = socketPath;\n\t\tthis._socketOptions = socketOptions;\n\n\t\tthis._reconnectOptions = {\n\t\t\t...DEFAULT_RECONNECTION_OPTIONS,\n\t\t\t...(reconnectOptions ?? {}),\n\t\t};\n\n\t\tthis._pendingRequestsQueue = new Map<JsonRpcId, SocketRequestItem<any, any, any>>();\n\t\tthis._sentRequestsQueue = new Map<JsonRpcId, SocketRequestItem<any, any, any>>();\n\n\t\tthis._init();\n\t\tthis.connect();\n\t\tthis.chunkResponseParser = new ChunkResponseParser(\n\t\t\tthis._eventEmitter,\n\t\t\tthis._reconnectOptions.autoReconnect,\n\t\t);\n\t\tthis.chunkResponseParser.onError(() => {\n\t\t\tthis._clearQueues();\n\t\t});\n\t\tthis.isReconnecting = false;\n\t}\n\n\tprotected _init() {\n\t\tthis._reconnectAttempts = 0;\n\t}\n\n\t/**\n\t * Try to establish a connection to the socket\n\t */\n\tpublic connect(): void {\n\t\ttry {\n\t\t\tthis._openSocketConnection();\n\t\t\tthis._connectionStatus = 'connecting';\n\t\t\tthis._addSocketListeners();\n\t\t} catch (e) {\n\t\t\tif (!this.isReconnecting) {\n\t\t\t\tthis._connectionStatus = 'disconnected';\n\t\t\t\tif (e && (e as Error).message) {\n\t\t\t\t\tthrow new ConnectionError(\n\t\t\t\t\t\t`Error while connecting to ${this._socketPath}. Reason: ${\n\t\t\t\t\t\t\t(e as Error).message\n\t\t\t\t\t\t}`,\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new InvalidClientError(this._socketPath);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsetImmediate(() => {\n\t\t\t\t\tthis._reconnect();\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected abstract _openSocketConnection(): void;\n\tprotected abstract _addSocketListeners(): void;\n\n\tprotected abstract _removeSocketListeners(): void;\n\n\tprotected abstract _onCloseEvent(_event: unknown): void;\n\n\tprotected abstract _sendToSocket(_payload: Web3APIPayload<API, any>): void;\n\n\tprotected abstract _parseResponses(_event: MessageEvent): JsonRpcResponse[];\n\n\tprotected abstract _closeSocketConnection(_code?: number, _data?: string): void;\n\n\t// eslint-disable-next-line class-methods-use-this\n\tprotected _validateProviderPath(path: string): boolean {\n\t\treturn !!path;\n\t}\n\n\t/**\n\t *\n\t * @returns `true` if the socket supports subscriptions\n\t */\n\t// eslint-disable-next-line class-methods-use-this\n\tpublic supportsSubscriptions(): boolean {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Registers a listener for the specified event type.\n\t * @param type - The event type to listen for\n\t * @param listener - The callback to be invoked when the event is emitted\n\t */\n\tpublic on(\n\t\ttype: 'disconnect',\n\t\tlistener: Web3Eip1193ProviderEventCallback<ProviderRpcError>,\n\t): void;\n\tpublic on(\n\t\ttype: 'connect',\n\t\tlistener: Web3Eip1193ProviderEventCallback<ProviderConnectInfo>,\n\t): void;\n\tpublic on(type: 'chainChanged', listener: Web3Eip1193ProviderEventCallback<string>): void;\n\tpublic on(type: 'accountsChanged', listener: Web3Eip1193ProviderEventCallback<string[]>): void;\n\tpublic on<T = JsonRpcResult>(\n\t\ttype: 'message',\n\t\tlistener:\n\t\t\t| Web3Eip1193ProviderEventCallback<ProviderMessage>\n\t\t\t| Web3ProviderMessageEventCallback<T>,\n\t): void;\n\tpublic on<T = JsonRpcResult>(\n\t\ttype: string,\n\t\tlistener: Web3Eip1193ProviderEventCallback<unknown> | Web3ProviderEventCallback<T>,\n\t): void;\n\tpublic on<T = JsonRpcResult, P = unknown>(\n\t\ttype: string | Eip1193EventName,\n\t\tlistener:\n\t\t\t| Web3Eip1193ProviderEventCallback<P>\n\t\t\t| Web3ProviderMessageEventCallback<T>\n\t\t\t| Web3ProviderEventCallback<T>,\n\t): void {\n\t\tthis._eventEmitter.on(type, listener);\n\t}\n\n\t/**\n\t * Registers a listener for the specified event type that will be invoked at most once.\n\t * @param type  - The event type to listen for\n\t * @param listener - The callback to be invoked when the event is emitted\n\t */\n\tpublic once(\n\t\ttype: 'disconnect',\n\t\tlistener: Web3Eip1193ProviderEventCallback<ProviderRpcError>,\n\t): void;\n\tpublic once(\n\t\ttype: 'connect',\n\t\tlistener: Web3Eip1193ProviderEventCallback<ProviderConnectInfo>,\n\t): void;\n\tpublic once(type: 'chainChanged', listener: Web3Eip1193ProviderEventCallback<string>): void;\n\tpublic once(\n\t\ttype: 'accountsChanged',\n\t\tlistener: Web3Eip1193ProviderEventCallback<string[]>,\n\t): void;\n\tpublic once<T = JsonRpcResult>(\n\t\ttype: 'message',\n\t\tlistener:\n\t\t\t| Web3Eip1193ProviderEventCallback<ProviderMessage>\n\t\t\t| Web3ProviderMessageEventCallback<T>,\n\t): void;\n\tpublic once<T = JsonRpcResult>(\n\t\ttype: string,\n\t\tlistener: Web3Eip1193ProviderEventCallback<unknown> | Web3ProviderEventCallback<T>,\n\t): void;\n\tpublic once<T = JsonRpcResult, P = unknown>(\n\t\ttype: string | Eip1193EventName,\n\t\tlistener:\n\t\t\t| Web3Eip1193ProviderEventCallback<P>\n\t\t\t| Web3ProviderMessageEventCallback<T>\n\t\t\t| Web3ProviderEventCallback<T>,\n\t): void {\n\t\tthis._eventEmitter.once(type, listener);\n\t}\n\n\t/**\n\t *  Removes a listener for the specified event type.\n\t * @param type - The event type to remove the listener for\n\t * @param listener - The callback to be executed\n\t */\n\tpublic removeListener(\n\t\ttype: 'disconnect',\n\t\tlistener: Web3Eip1193ProviderEventCallback<ProviderRpcError>,\n\t): void;\n\tpublic removeListener(\n\t\ttype: 'connect',\n\t\tlistener: Web3Eip1193ProviderEventCallback<ProviderConnectInfo>,\n\t): void;\n\tpublic removeListener(\n\t\ttype: 'chainChanged',\n\t\tlistener: Web3Eip1193ProviderEventCallback<string>,\n\t): void;\n\tpublic removeListener(\n\t\ttype: 'accountsChanged',\n\t\tlistener: Web3Eip1193ProviderEventCallback<string[]>,\n\t): void;\n\tpublic removeListener<T = JsonRpcResult>(\n\t\ttype: 'message',\n\t\tlistener:\n\t\t\t| Web3Eip1193ProviderEventCallback<ProviderMessage>\n\t\t\t| Web3ProviderMessageEventCallback<T>,\n\t): void;\n\tpublic removeListener<T = JsonRpcResult>(\n\t\ttype: string,\n\t\tlistener: Web3Eip1193ProviderEventCallback<unknown> | Web3ProviderEventCallback<T>,\n\t): void;\n\tpublic removeListener<T = JsonRpcResult, P = unknown>(\n\t\ttype: string | Eip1193EventName,\n\t\tlistener:\n\t\t\t| Web3Eip1193ProviderEventCallback<P>\n\t\t\t| Web3ProviderMessageEventCallback<T>\n\t\t\t| Web3ProviderEventCallback<T>,\n\t): void {\n\t\tthis._eventEmitter.removeListener(type, listener);\n\t}\n\n\tprotected _onDisconnect(code: number, data?: string) {\n\t\tthis._connectionStatus = 'disconnected';\n\t\tsuper._onDisconnect(code, data);\n\t}\n\n\t/**\n\t * Disconnects the socket\n\t * @param code - The code to be sent to the server\n\t * @param data - The data to be sent to the server\n\t */\n\tpublic disconnect(code?: number, data?: string): void {\n\t\tconst disconnectCode = code ?? NORMAL_CLOSE_CODE;\n\t\tthis._removeSocketListeners();\n\t\tif (this.getStatus() !== 'disconnected') {\n\t\t\tthis._closeSocketConnection(disconnectCode, data);\n\t\t}\n\t\tthis._onDisconnect(disconnectCode, data);\n\t}\n\n\t/**\n\t * Removes all listeners for the specified event type.\n\t * @param type - The event type to remove the listeners for\n\t */\n\tpublic removeAllListeners(type: string): void {\n\t\tthis._eventEmitter.removeAllListeners(type);\n\t}\n\n\tprotected _onError(event: ErrorEvent): void {\n\t\t// do not emit error while trying to reconnect\n\t\tif (this.isReconnecting) {\n\t\t\tthis._reconnect();\n\t\t} else {\n\t\t\tthis._eventEmitter.emit('error', event);\n\t\t}\n\t}\n\n\t/**\n\t * Resets the socket, removing all listeners and pending requests\n\t */\n\tpublic reset(): void {\n\t\tthis._sentRequestsQueue.clear();\n\t\tthis._pendingRequestsQueue.clear();\n\n\t\tthis._init();\n\t\tthis._removeSocketListeners();\n\t\tthis._addSocketListeners();\n\t}\n\n\tprotected _reconnect(): void {\n\t\tif (this.isReconnecting) {\n\t\t\treturn;\n\t\t}\n\t\tthis.isReconnecting = true;\n\n\t\tif (this._sentRequestsQueue.size > 0) {\n\t\t\tthis._sentRequestsQueue.forEach(\n\t\t\t\t(request: SocketRequestItem<any, any, any>, key: JsonRpcId) => {\n\t\t\t\t\trequest.deferredPromise.reject(new PendingRequestsOnReconnectingError());\n\t\t\t\t\tthis._sentRequestsQueue.delete(key);\n\t\t\t\t},\n\t\t\t);\n\t\t}\n\n\t\tif (this._reconnectAttempts < this._reconnectOptions.maxAttempts) {\n\t\t\tthis._reconnectAttempts += 1;\n\t\t\tsetTimeout(() => {\n\t\t\t\tthis._removeSocketListeners();\n\t\t\t\tthis.connect();\n\t\t\t\tthis.isReconnecting = false;\n\t\t\t}, this._reconnectOptions.delay);\n\t\t} else {\n\t\t\tthis.isReconnecting = false;\n\t\t\tthis._clearQueues();\n\t\t\tthis._removeSocketListeners();\n\t\t\tthis._eventEmitter.emit(\n\t\t\t\t'error',\n\t\t\t\tnew MaxAttemptsReachedOnReconnectingError(this._reconnectOptions.maxAttempts),\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t *  Creates a request object to be sent to the server\n\t */\n\tpublic async request<\n\t\tMethod extends Web3APIMethod<API>,\n\t\tResultType = Web3APIReturnType<API, Method>,\n\t>(request: Web3APIPayload<API, Method>): Promise<JsonRpcResponseWithResult<ResultType>> {\n\t\tif (isNullish(this._socketConnection)) {\n\t\t\tthrow new Error('Connection is undefined');\n\t\t}\n\t\t// if socket disconnected - open connection\n\t\tif (this.getStatus() === 'disconnected') {\n\t\t\tthis.connect();\n\t\t}\n\n\t\tconst requestId = jsonRpc.isBatchRequest(request)\n\t\t\t? (request as unknown as JsonRpcBatchRequest)[0].id\n\t\t\t: (request as unknown as JsonRpcRequest).id;\n\n\t\tif (!requestId) {\n\t\t\tthrow new Web3WSProviderError('Request Id not defined');\n\t\t}\n\n\t\tif (this._sentRequestsQueue.has(requestId)) {\n\t\t\tthrow new RequestAlreadySentError(requestId);\n\t\t}\n\n\t\tconst deferredPromise = new Web3DeferredPromise<JsonRpcResponseWithResult<ResultType>>();\n\t\tdeferredPromise.catch(error => {\n\t\t\tthis._eventEmitter.emit('error', error);\n\t\t});\n\t\tconst reqItem: SocketRequestItem<API, Method, JsonRpcResponseWithResult<ResultType>> = {\n\t\t\tpayload: request,\n\t\t\tdeferredPromise,\n\t\t};\n\n\t\tif (this.getStatus() === 'connecting') {\n\t\t\tthis._pendingRequestsQueue.set(requestId, reqItem);\n\n\t\t\treturn reqItem.deferredPromise;\n\t\t}\n\n\t\tthis._sentRequestsQueue.set(requestId, reqItem);\n\n\t\ttry {\n\t\t\tthis._sendToSocket(reqItem.payload);\n\t\t} catch (error) {\n\t\t\tthis._sentRequestsQueue.delete(requestId);\n\n\t\t\tthis._eventEmitter.emit('error', error);\n\t\t}\n\n\t\treturn deferredPromise;\n\t}\n\n\tprotected _onConnect() {\n\t\tthis._connectionStatus = 'connected';\n\t\tthis._reconnectAttempts = 0;\n\t\tsuper._onConnect();\n\t\tthis._sendPendingRequests();\n\t}\n\n\tprivate _sendPendingRequests() {\n\t\tfor (const [id, value] of this._pendingRequestsQueue.entries()) {\n\t\t\tthis._sendToSocket(value.payload as Web3APIPayload<API, any>);\n\t\t\tthis._pendingRequestsQueue.delete(id);\n\t\t\tthis._sentRequestsQueue.set(id, value);\n\t\t}\n\t}\n\n\tprotected _onMessage(event: MessageEvent): void {\n\t\tconst responses = this._parseResponses(event);\n\t\tif (isNullish(responses) || responses.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor (const response of responses) {\n\t\t\tif (\n\t\t\t\tjsonRpc.isResponseWithNotification(response as JsonRpcNotification) &&\n\t\t\t\t(response as JsonRpcNotification).method.endsWith('_subscription')\n\t\t\t) {\n\t\t\t\tthis._eventEmitter.emit('message', response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst requestId = jsonRpc.isBatchResponse(response)\n\t\t\t\t? (response as unknown as JsonRpcBatchResponse)[0].id\n\t\t\t\t: (response as unknown as JsonRpcResponseWithResult).id;\n\n\t\t\tconst requestItem = this._sentRequestsQueue.get(requestId);\n\n\t\t\tif (!requestItem) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tjsonRpc.isBatchResponse(response) ||\n\t\t\t\tjsonRpc.isResponseWithResult(response) ||\n\t\t\t\tjsonRpc.isResponseWithError(response)\n\t\t\t) {\n\t\t\t\tthis._eventEmitter.emit('message', response);\n\t\t\t\trequestItem.deferredPromise.resolve(response);\n\t\t\t}\n\n\t\t\tthis._sentRequestsQueue.delete(requestId);\n\t\t}\n\t}\n\n\tprotected _clearQueues(event?: ConnectionEvent) {\n\t\tif (this._pendingRequestsQueue.size > 0) {\n\t\t\tthis._pendingRequestsQueue.forEach(\n\t\t\t\t(request: SocketRequestItem<any, any, any>, key: JsonRpcId) => {\n\t\t\t\t\trequest.deferredPromise.reject(new ConnectionNotOpenError(event));\n\t\t\t\t\tthis._pendingRequestsQueue.delete(key);\n\t\t\t\t},\n\t\t\t);\n\t\t}\n\n\t\tif (this._sentRequestsQueue.size > 0) {\n\t\t\tthis._sentRequestsQueue.forEach(\n\t\t\t\t(request: SocketRequestItem<any, any, any>, key: JsonRpcId) => {\n\t\t\t\t\trequest.deferredPromise.reject(new ConnectionNotOpenError(event));\n\t\t\t\t\tthis._sentRequestsQueue.delete(key);\n\t\t\t\t},\n\t\t\t);\n\t\t}\n\n\t\tthis._removeSocketListeners();\n\t}\n}\n"]},"metadata":{},"sourceType":"script"}