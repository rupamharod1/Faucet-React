{"ast":null,"code":"\"use strict\";\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.jsonInterfaceMethodToString = exports.flattenTypes = exports.formatParam = exports.formatOddHexstrings = exports.isOddHexstring = exports.mapTypes = exports.mapStructToCoderFormat = exports.mapStructNameAndType = exports.isSimplifiedStructFormat = exports.isAbiConstructorFragment = exports.isAbiFunctionFragment = exports.isAbiEventFragment = exports.isAbiErrorFragment = exports.isAbiFragment = void 0;\n\nconst web3_errors_1 = require(\"web3-errors\");\n\nconst web3_utils_1 = require(\"web3-utils\");\n\nconst isAbiFragment = item => !(0, web3_utils_1.isNullish)(item) && typeof item === 'object' && !(0, web3_utils_1.isNullish)(item.type) && ['function', 'event', 'constructor', 'error'].includes(item.type);\n\nexports.isAbiFragment = isAbiFragment;\n\nconst isAbiErrorFragment = item => !(0, web3_utils_1.isNullish)(item) && typeof item === 'object' && !(0, web3_utils_1.isNullish)(item.type) && item.type === 'error';\n\nexports.isAbiErrorFragment = isAbiErrorFragment;\n\nconst isAbiEventFragment = item => !(0, web3_utils_1.isNullish)(item) && typeof item === 'object' && !(0, web3_utils_1.isNullish)(item.type) && item.type === 'event';\n\nexports.isAbiEventFragment = isAbiEventFragment;\n\nconst isAbiFunctionFragment = item => !(0, web3_utils_1.isNullish)(item) && typeof item === 'object' && !(0, web3_utils_1.isNullish)(item.type) && item.type === 'function';\n\nexports.isAbiFunctionFragment = isAbiFunctionFragment;\n\nconst isAbiConstructorFragment = item => !(0, web3_utils_1.isNullish)(item) && typeof item === 'object' && !(0, web3_utils_1.isNullish)(item.type) && item.type === 'constructor';\n\nexports.isAbiConstructorFragment = isAbiConstructorFragment;\n/**\n * Check if type is simplified struct format\n */\n\nconst isSimplifiedStructFormat = type => typeof type === 'object' && typeof type.components === 'undefined' && typeof type.name === 'undefined';\n\nexports.isSimplifiedStructFormat = isSimplifiedStructFormat;\n/**\n * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\n */\n\nconst mapStructNameAndType = structName => structName.includes('[]') ? {\n  type: 'tuple[]',\n  name: structName.slice(0, -2)\n} : {\n  type: 'tuple',\n  name: structName\n};\n\nexports.mapStructNameAndType = mapStructNameAndType;\n/**\n * Maps the simplified format in to the expected format of the ABICoder\n */\n\nconst mapStructToCoderFormat = struct => {\n  const components = [];\n\n  for (const key of Object.keys(struct)) {\n    const item = struct[key];\n\n    if (typeof item === 'object') {\n      components.push(Object.assign(Object.assign({}, (0, exports.mapStructNameAndType)(key)), {\n        components: (0, exports.mapStructToCoderFormat)(item)\n      }));\n    } else {\n      components.push({\n        name: key,\n        type: struct[key]\n      });\n    }\n  }\n\n  return components;\n};\n\nexports.mapStructToCoderFormat = mapStructToCoderFormat;\n/**\n * Map types if simplified format is used\n */\n\nconst mapTypes = types => {\n  const mappedTypes = [];\n\n  for (const type of types) {\n    let modifiedType = type; // Clone object\n\n    if (typeof type === 'object') {\n      modifiedType = Object.assign({}, type);\n    } // Remap `function` type params to bytes24 since Ethers does not\n    // recognize former type. Solidity docs say `Function` is a bytes24\n    // encoding the contract address followed by the function selector hash.\n\n\n    if (typeof type === 'object' && type.type === 'function') {\n      modifiedType = Object.assign(Object.assign({}, type), {\n        type: 'bytes24'\n      });\n    }\n\n    if ((0, exports.isSimplifiedStructFormat)(modifiedType)) {\n      const structName = Object.keys(modifiedType)[0];\n      mappedTypes.push(Object.assign(Object.assign({}, (0, exports.mapStructNameAndType)(structName)), {\n        components: (0, exports.mapStructToCoderFormat)(modifiedType[structName])\n      }));\n    } else {\n      mappedTypes.push(modifiedType);\n    }\n  }\n\n  return mappedTypes;\n};\n\nexports.mapTypes = mapTypes;\n/**\n * returns true if input is a hexstring and is odd-lengthed\n */\n\nconst isOddHexstring = param => typeof param === 'string' && /^(-)?0x[0-9a-f]*$/i.test(param) && param.length % 2 === 1;\n\nexports.isOddHexstring = isOddHexstring;\n/**\n * format odd-length bytes to even-length\n */\n\nconst formatOddHexstrings = param => (0, exports.isOddHexstring)(param) ? `0x0${param.substring(2)}` : param;\n\nexports.formatOddHexstrings = formatOddHexstrings;\n/**\n * Handle some formatting of params for backwards compatibility with Ethers V4\n */\n\nconst formatParam = (type, _param) => {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  var _a; // clone if _param is an object\n\n\n  const param = typeof _param === 'object' && !Array.isArray(_param) ? Object.assign({}, _param) : _param;\n  const paramTypeBytes = /^bytes([0-9]*)$/;\n  const paramTypeBytesArray = /^bytes([0-9]*)\\[\\]$/;\n  const paramTypeNumber = /^(u?int)([0-9]*)$/;\n  const paramTypeNumberArray = /^(u?int)([0-9]*)\\[\\]$/; // Format BN to string\n\n  if (param instanceof BigInt) {\n    return param.toString(10);\n  }\n\n  if (paramTypeBytesArray.exec(type) || paramTypeNumberArray.exec(type)) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    const paramClone = [...param];\n    return paramClone.map(p => (0, exports.formatParam)(type.replace('[]', ''), p));\n  } // Format correct width for u?int[0-9]*\n\n\n  let match = paramTypeNumber.exec(type);\n\n  if (match) {\n    const size = parseInt((_a = match[2]) !== null && _a !== void 0 ? _a : '256', 10);\n\n    if (size / 8 < param.length) {\n      // pad to correct bit width\n      return (0, web3_utils_1.leftPad)(param, size);\n    }\n  } // Format correct length for bytes[0-9]+\n\n\n  match = paramTypeBytes.exec(type);\n\n  if (match) {\n    const hexParam = param instanceof Uint8Array ? (0, web3_utils_1.toHex)(param) : param; // format to correct length\n\n    const size = parseInt(match[1], 10);\n\n    if (size) {\n      let maxSize = size * 2;\n\n      if (param.startsWith('0x')) {\n        maxSize += 2;\n      } // pad to correct length\n\n\n      const paddedParam = hexParam.length < maxSize ? (0, web3_utils_1.rightPad)(param, size * 2) : hexParam;\n      return (0, exports.formatOddHexstrings)(paddedParam);\n    }\n\n    return (0, exports.formatOddHexstrings)(hexParam);\n  }\n\n  return param;\n};\n\nexports.formatParam = formatParam;\n/**\n *  used to flatten json abi inputs/outputs into an array of type-representing-strings\n */\n\nconst flattenTypes = (includeTuple, puts) => {\n  const types = [];\n  puts.forEach(param => {\n    if (typeof param.components === 'object') {\n      if (!param.type.startsWith('tuple')) {\n        throw new web3_errors_1.AbiError(`Invalid value given \"${param.type}\". Error: components found but type is not tuple.`);\n      }\n\n      const arrayBracket = param.type.indexOf('[');\n      const suffix = arrayBracket >= 0 ? param.type.substring(arrayBracket) : '';\n      const result = (0, exports.flattenTypes)(includeTuple, param.components);\n\n      if (Array.isArray(result) && includeTuple) {\n        types.push(`tuple(${result.join(',')})${suffix}`);\n      } else if (!includeTuple) {\n        types.push(`(${result.join(',')})${suffix}`);\n      } else {\n        types.push(`(${result.join()})`);\n      }\n    } else {\n      types.push(param.type);\n    }\n  });\n  return types;\n};\n\nexports.flattenTypes = flattenTypes;\n/**\n * Should be used to create full function/event name from json abi\n * returns a string\n */\n\nconst jsonInterfaceMethodToString = json => {\n  var _a, _b, _c, _d;\n\n  if ((0, exports.isAbiErrorFragment)(json) || (0, exports.isAbiEventFragment)(json) || (0, exports.isAbiFunctionFragment)(json)) {\n    if ((_a = json.name) === null || _a === void 0 ? void 0 : _a.includes('(')) {\n      return json.name;\n    }\n\n    return `${(_b = json.name) !== null && _b !== void 0 ? _b : ''}(${(0, exports.flattenTypes)(false, (_c = json.inputs) !== null && _c !== void 0 ? _c : []).join(',')})`;\n  } // Constructor fragment\n\n\n  return `(${(0, exports.flattenTypes)(false, (_d = json.inputs) !== null && _d !== void 0 ? _d : []).join(',')})`;\n};\n\nexports.jsonInterfaceMethodToString = jsonInterfaceMethodToString;","map":{"version":3,"mappings":"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","names":["isAbiFragment","item","type","includes","exports","isAbiErrorFragment","isAbiEventFragment","isAbiFunctionFragment","isAbiConstructorFragment","isSimplifiedStructFormat","components","name","mapStructNameAndType","structName","slice","mapStructToCoderFormat","struct","key","Object","keys","push","mapTypes","types","mappedTypes","modifiedType","isOddHexstring","param","test","length","formatOddHexstrings","substring","formatParam","_param","Array","isArray","paramTypeBytes","paramTypeBytesArray","paramTypeNumber","paramTypeNumberArray","BigInt","toString","exec","paramClone","map","p","replace","match","size","parseInt","_a","hexParam","Uint8Array","maxSize","startsWith","paddedParam","flattenTypes","includeTuple","puts","forEach","web3_errors_1","arrayBracket","indexOf","suffix","result","join","jsonInterfaceMethodToString","json","_b","inputs","_c","_d"],"sources":["/home/rupam/Desktop/Faucet-React/node_modules/web3-eth-abi/src/utils.ts"],"sourcesContent":["﻿/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport { AbiError } from 'web3-errors';\nimport { isNullish, leftPad, rightPad, toHex } from 'web3-utils';\nimport {\n\tAbiInput,\n\tAbiCoderStruct,\n\tAbiFragment,\n\tAbiParameter,\n\tAbiStruct,\n\tAbiEventFragment,\n\tAbiFunctionFragment,\n\tAbiConstructorFragment,\n} from 'web3-types';\n\nexport const isAbiFragment = (item: unknown): item is AbiFragment =>\n\t!isNullish(item) &&\n\ttypeof item === 'object' &&\n\t!isNullish((item as { type: string }).type) &&\n\t['function', 'event', 'constructor', 'error'].includes((item as { type: string }).type);\n\nexport const isAbiErrorFragment = (item: unknown): item is AbiEventFragment =>\n\t!isNullish(item) &&\n\ttypeof item === 'object' &&\n\t!isNullish((item as { type: string }).type) &&\n\t(item as { type: string }).type === 'error';\n\nexport const isAbiEventFragment = (item: unknown): item is AbiEventFragment =>\n\t!isNullish(item) &&\n\ttypeof item === 'object' &&\n\t!isNullish((item as { type: string }).type) &&\n\t(item as { type: string }).type === 'event';\n\nexport const isAbiFunctionFragment = (item: unknown): item is AbiFunctionFragment =>\n\t!isNullish(item) &&\n\ttypeof item === 'object' &&\n\t!isNullish((item as { type: string }).type) &&\n\t(item as { type: string }).type === 'function';\n\nexport const isAbiConstructorFragment = (item: unknown): item is AbiConstructorFragment =>\n\t!isNullish(item) &&\n\ttypeof item === 'object' &&\n\t!isNullish((item as { type: string }).type) &&\n\t(item as { type: string }).type === 'constructor';\n\n/**\n * Check if type is simplified struct format\n */\nexport const isSimplifiedStructFormat = (\n\ttype: string | Partial<AbiParameter> | Partial<AbiInput>,\n): type is Omit<AbiParameter, 'components' | 'name'> =>\n\ttypeof type === 'object' &&\n\ttypeof (type as { components: unknown }).components === 'undefined' &&\n\ttypeof (type as { name: unknown }).name === 'undefined';\n\n/**\n * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\n */\nexport const mapStructNameAndType = (structName: string): AbiStruct =>\n\tstructName.includes('[]')\n\t\t? { type: 'tuple[]', name: structName.slice(0, -2) }\n\t\t: { type: 'tuple', name: structName };\n\n/**\n * Maps the simplified format in to the expected format of the ABICoder\n */\nexport const mapStructToCoderFormat = (struct: AbiStruct): Array<AbiCoderStruct> => {\n\tconst components: Array<AbiCoderStruct> = [];\n\n\tfor (const key of Object.keys(struct)) {\n\t\tconst item = struct[key];\n\n\t\tif (typeof item === 'object') {\n\t\t\tcomponents.push({\n\t\t\t\t...mapStructNameAndType(key),\n\t\t\t\tcomponents: mapStructToCoderFormat(item as unknown as AbiStruct),\n\t\t\t});\n\t\t} else {\n\t\t\tcomponents.push({\n\t\t\t\tname: key,\n\t\t\t\ttype: struct[key] as string,\n\t\t\t});\n\t\t}\n\t}\n\treturn components;\n};\n\n/**\n * Map types if simplified format is used\n */\nexport const mapTypes = (\n\ttypes: AbiInput[],\n): Array<string | AbiParameter | Record<string, unknown>> => {\n\tconst mappedTypes: Array<string | AbiParameter | Record<string, unknown>> = [];\n\n\tfor (const type of types) {\n\t\tlet modifiedType = type;\n\n\t\t// Clone object\n\t\tif (typeof type === 'object') {\n\t\t\tmodifiedType = { ...type };\n\t\t}\n\n\t\t// Remap `function` type params to bytes24 since Ethers does not\n\t\t// recognize former type. Solidity docs say `Function` is a bytes24\n\t\t// encoding the contract address followed by the function selector hash.\n\t\tif (typeof type === 'object' && type.type === 'function') {\n\t\t\tmodifiedType = { ...type, type: 'bytes24' };\n\t\t}\n\n\t\tif (isSimplifiedStructFormat(modifiedType)) {\n\t\t\tconst structName = Object.keys(modifiedType)[0] as unknown as keyof typeof modifiedType;\n\n\t\t\tmappedTypes.push({\n\t\t\t\t...mapStructNameAndType(structName),\n\t\t\t\tcomponents: mapStructToCoderFormat(\n\t\t\t\t\tmodifiedType[structName] as unknown as AbiStruct,\n\t\t\t\t) as unknown as AbiParameter[],\n\t\t\t});\n\t\t} else {\n\t\t\tmappedTypes.push(modifiedType);\n\t\t}\n\t}\n\n\treturn mappedTypes;\n};\n\n/**\n * returns true if input is a hexstring and is odd-lengthed\n */\nexport const isOddHexstring = (param: unknown): boolean =>\n\ttypeof param === 'string' && /^(-)?0x[0-9a-f]*$/i.test(param) && param.length % 2 === 1;\n\n/**\n * format odd-length bytes to even-length\n */\nexport const formatOddHexstrings = (param: string): string =>\n\tisOddHexstring(param) ? `0x0${param.substring(2)}` : param;\n\n/**\n * Handle some formatting of params for backwards compatibility with Ethers V4\n */\nexport const formatParam = (type: string, _param: unknown): unknown => {\n\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\n\t// clone if _param is an object\n\tconst param = typeof _param === 'object' && !Array.isArray(_param) ? { ..._param } : _param;\n\tconst paramTypeBytes = /^bytes([0-9]*)$/;\n\tconst paramTypeBytesArray = /^bytes([0-9]*)\\[\\]$/;\n\tconst paramTypeNumber = /^(u?int)([0-9]*)$/;\n\tconst paramTypeNumberArray = /^(u?int)([0-9]*)\\[\\]$/;\n\n\t// Format BN to string\n\tif (param instanceof BigInt) {\n\t\treturn param.toString(10);\n\t}\n\n\tif (paramTypeBytesArray.exec(type) || paramTypeNumberArray.exec(type)) {\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-return\n\t\tconst paramClone = [...(param as Array<unknown>)];\n\t\treturn paramClone.map(p => formatParam(type.replace('[]', ''), p));\n\t}\n\n\t// Format correct width for u?int[0-9]*\n\tlet match = paramTypeNumber.exec(type);\n\tif (match) {\n\t\tconst size = parseInt(match[2] ?? '256', 10);\n\t\tif (size / 8 < (param as { length: number }).length) {\n\t\t\t// pad to correct bit width\n\t\t\treturn leftPad(param as string, size);\n\t\t}\n\t}\n\n\t// Format correct length for bytes[0-9]+\n\tmatch = paramTypeBytes.exec(type);\n\tif (match) {\n\t\tconst hexParam = param instanceof Uint8Array ? toHex(param) : param;\n\n\t\t// format to correct length\n\t\tconst size = parseInt(match[1], 10);\n\t\tif (size) {\n\t\t\tlet maxSize = size * 2;\n\n\t\t\tif ((param as string).startsWith('0x')) {\n\t\t\t\tmaxSize += 2;\n\t\t\t}\n\t\t\t// pad to correct length\n\t\t\tconst paddedParam =\n\t\t\t\t(hexParam as string).length < maxSize\n\t\t\t\t\t? rightPad(param as string, size * 2)\n\t\t\t\t\t: hexParam;\n\t\t\treturn formatOddHexstrings(paddedParam as string);\n\t\t}\n\n\t\treturn formatOddHexstrings(hexParam as string);\n\t}\n\treturn param;\n};\n\n/**\n *  used to flatten json abi inputs/outputs into an array of type-representing-strings\n */\n\nexport const flattenTypes = (\n\tincludeTuple: boolean,\n\tputs: ReadonlyArray<AbiParameter>,\n): string[] => {\n\tconst types: string[] = [];\n\n\tputs.forEach(param => {\n\t\tif (typeof param.components === 'object') {\n\t\t\tif (!param.type.startsWith('tuple')) {\n\t\t\t\tthrow new AbiError(\n\t\t\t\t\t`Invalid value given \"${param.type}\". Error: components found but type is not tuple.`,\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst arrayBracket = param.type.indexOf('[');\n\t\t\tconst suffix = arrayBracket >= 0 ? param.type.substring(arrayBracket) : '';\n\t\t\tconst result = flattenTypes(includeTuple, param.components);\n\n\t\t\tif (Array.isArray(result) && includeTuple) {\n\t\t\t\ttypes.push(`tuple(${result.join(',')})${suffix}`);\n\t\t\t} else if (!includeTuple) {\n\t\t\t\ttypes.push(`(${result.join(',')})${suffix}`);\n\t\t\t} else {\n\t\t\t\ttypes.push(`(${result.join()})`);\n\t\t\t}\n\t\t} else {\n\t\t\ttypes.push(param.type);\n\t\t}\n\t});\n\n\treturn types;\n};\n\n/**\n * Should be used to create full function/event name from json abi\n * returns a string\n */\nexport const jsonInterfaceMethodToString = (json: AbiFragment): string => {\n\tif (isAbiErrorFragment(json) || isAbiEventFragment(json) || isAbiFunctionFragment(json)) {\n\t\tif (json.name?.includes('(')) {\n\t\t\treturn json.name;\n\t\t}\n\n\t\treturn `${json.name ?? ''}(${flattenTypes(false, json.inputs ?? []).join(',')})`;\n\t}\n\n\t// Constructor fragment\n\treturn `(${flattenTypes(false, json.inputs ?? []).join(',')})`;\n};\n"]},"metadata":{},"sourceType":"script"}