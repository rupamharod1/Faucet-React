{"ast":null,"code":"import assert from './_assert.js';\nimport u64 from './_u64.js';\nimport { Hash, u32, toBytes, wrapConstructor, wrapXOFConstructorWithOpts } from './utils.js'; // Various per round constants calculations\n\nconst [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];\n\nconst _0n = BigInt(0);\n\nconst _1n = BigInt(1);\n\nconst _2n = BigInt(2);\n\nconst _7n = BigInt(7);\n\nconst _256n = BigInt(256);\n\nconst _0x71n = BigInt(0x71);\n\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n  // Pi\n  [x, y] = [y, (2 * x + 3 * y) % 5];\n  SHA3_PI.push(2 * (5 * y + x)); // Rotational\n\n  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64); // Iota\n\n  let t = _0n;\n\n  for (let j = 0; j < 7; j++) {\n    R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;\n    if (R & _2n) t ^= _1n << (_1n << BigInt(j)) - _1n;\n  }\n\n  _SHA3_IOTA.push(t);\n}\n\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = u64.split(_SHA3_IOTA, true); // Left rotation (without 0, 32, 64)\n\nconst rotlH = (h, l, s) => s > 32 ? u64.rotlBH(h, l, s) : u64.rotlSH(h, l, s);\n\nconst rotlL = (h, l, s) => s > 32 ? u64.rotlBL(h, l, s) : u64.rotlSL(h, l, s); // Same as keccakf1600, but allows to skip some rounds\n\n\nexport function keccakP(s) {\n  let rounds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 24;\n  const B = new Uint32Array(5 * 2); // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n\n  for (let round = 24 - rounds; round < 24; round++) {\n    // Theta θ\n    for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n\n    for (let x = 0; x < 10; x += 2) {\n      const idx1 = (x + 8) % 10;\n      const idx0 = (x + 2) % 10;\n      const B0 = B[idx0];\n      const B1 = B[idx0 + 1];\n      const Th = rotlH(B0, B1, 1) ^ B[idx1];\n      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n\n      for (let y = 0; y < 50; y += 10) {\n        s[x + y] ^= Th;\n        s[x + y + 1] ^= Tl;\n      }\n    } // Rho (ρ) and Pi (π)\n\n\n    let curH = s[2];\n    let curL = s[3];\n\n    for (let t = 0; t < 24; t++) {\n      const shift = SHA3_ROTL[t];\n      const Th = rotlH(curH, curL, shift);\n      const Tl = rotlL(curH, curL, shift);\n      const PI = SHA3_PI[t];\n      curH = s[PI];\n      curL = s[PI + 1];\n      s[PI] = Th;\n      s[PI + 1] = Tl;\n    } // Chi (χ)\n\n\n    for (let y = 0; y < 50; y += 10) {\n      for (let x = 0; x < 10; x++) B[x] = s[y + x];\n\n      for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n    } // Iota (ι)\n\n\n    s[0] ^= SHA3_IOTA_H[round];\n    s[1] ^= SHA3_IOTA_L[round];\n  }\n\n  B.fill(0);\n}\nexport class Keccak extends Hash {\n  // NOTE: we accept arguments in bytes instead of bits here.\n  constructor(blockLen, suffix, outputLen) {\n    let enableXOF = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let rounds = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 24;\n    super();\n    this.blockLen = blockLen;\n    this.suffix = suffix;\n    this.outputLen = outputLen;\n    this.enableXOF = enableXOF;\n    this.rounds = rounds;\n    this.pos = 0;\n    this.posOut = 0;\n    this.finished = false;\n    this.destroyed = false; // Can be passed from user as dkLen\n\n    assert.number(outputLen); // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n\n    if (0 >= this.blockLen || this.blockLen >= 200) throw new Error('Sha3 supports only keccak-f1600 function');\n    this.state = new Uint8Array(200);\n    this.state32 = u32(this.state);\n  }\n\n  keccak() {\n    keccakP(this.state32, this.rounds);\n    this.posOut = 0;\n    this.pos = 0;\n  }\n\n  update(data) {\n    assert.exists(this);\n    const {\n      blockLen,\n      state\n    } = this;\n    data = toBytes(data);\n    const len = data.length;\n\n    for (let pos = 0; pos < len;) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n\n      for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++];\n\n      if (this.pos === blockLen) this.keccak();\n    }\n\n    return this;\n  }\n\n  finish() {\n    if (this.finished) return;\n    this.finished = true;\n    const {\n      state,\n      suffix,\n      pos,\n      blockLen\n    } = this; // Do the padding\n\n    state[pos] ^= suffix;\n    if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n    state[blockLen - 1] ^= 0x80;\n    this.keccak();\n  }\n\n  writeInto(out) {\n    assert.exists(this, false);\n    assert.bytes(out);\n    this.finish();\n    const bufferOut = this.state;\n    const {\n      blockLen\n    } = this;\n\n    for (let pos = 0, len = out.length; pos < len;) {\n      if (this.posOut >= blockLen) this.keccak();\n      const take = Math.min(blockLen - this.posOut, len - pos);\n      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n      this.posOut += take;\n      pos += take;\n    }\n\n    return out;\n  }\n\n  xofInto(out) {\n    // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n    if (!this.enableXOF) throw new Error('XOF is not possible for this instance');\n    return this.writeInto(out);\n  }\n\n  xof(bytes) {\n    assert.number(bytes);\n    return this.xofInto(new Uint8Array(bytes));\n  }\n\n  digestInto(out) {\n    assert.output(out, this);\n    if (this.finished) throw new Error('digest() was already called');\n    this.writeInto(out);\n    this.destroy();\n    return out;\n  }\n\n  digest() {\n    return this.digestInto(new Uint8Array(this.outputLen));\n  }\n\n  destroy() {\n    this.destroyed = true;\n    this.state.fill(0);\n  }\n\n  _cloneInto(to) {\n    const {\n      blockLen,\n      suffix,\n      outputLen,\n      rounds,\n      enableXOF\n    } = this;\n    to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n    to.state32.set(this.state32);\n    to.pos = this.pos;\n    to.posOut = this.posOut;\n    to.finished = this.finished;\n    to.rounds = rounds; // Suffix can change in cSHAKE\n\n    to.suffix = suffix;\n    to.outputLen = outputLen;\n    to.enableXOF = enableXOF;\n    to.destroyed = this.destroyed;\n    return to;\n  }\n\n}\n\nconst gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));\n\nexport const sha3_224 = gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\n\nexport const sha3_256 = gen(0x06, 136, 256 / 8);\nexport const sha3_384 = gen(0x06, 104, 384 / 8);\nexport const sha3_512 = gen(0x06, 72, 512 / 8);\nexport const keccak_224 = gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\n\nexport const keccak_256 = gen(0x01, 136, 256 / 8);\nexport const keccak_384 = gen(0x01, 104, 384 / 8);\nexport const keccak_512 = gen(0x01, 72, 512 / 8);\n\nconst genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts(function () {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true);\n});\n\nexport const shake128 = genShake(0x1f, 168, 128 / 8);\nexport const shake256 = genShake(0x1f, 136, 256 / 8);","map":{"version":3,"mappings":"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","names":["assert","u64","Hash","u32","toBytes","wrapConstructor","wrapXOFConstructorWithOpts","SHA3_PI","SHA3_ROTL","_SHA3_IOTA","_0n","BigInt","_1n","_2n","_7n","_256n","_0x71n","round","R","x","y","push","t","j","SHA3_IOTA_H","SHA3_IOTA_L","split","rotlH","h","l","s","rotlBH","rotlSH","rotlL","rotlBL","rotlSL","keccakP","rounds","B","Uint32Array","idx1","idx0","B0","B1","Th","Tl","curH","curL","shift","PI","fill","Keccak","constructor","blockLen","suffix","outputLen","enableXOF","number","Error","state","Uint8Array","state32","keccak","posOut","pos","update","data","exists","len","length","take","Math","min","i","finish","finished","writeInto","out","bytes","bufferOut","set","subarray","xofInto","xof","digestInto","output","destroy","digest","destroyed","_cloneInto","to","gen","sha3_224","sha3_256","sha3_384","sha3_512","keccak_224","keccak_256","keccak_384","keccak_512","genShake","opts","dkLen","undefined","shake128","shake256"],"sources":["/home/rupam/Desktop/Faucet-React/node_modules/@noble/hashes/src/sha3.ts"],"sourcesContent":["import assert from './_assert.js';\nimport u64 from './_u64.js';\nimport {\n  Hash,\n  u32,\n  Input,\n  toBytes,\n  wrapConstructor,\n  wrapXOFConstructorWithOpts,\n  HashXOF,\n} from './utils.js';\n\n// Various per round constants calculations\nconst [SHA3_PI, SHA3_ROTL, _SHA3_IOTA]: [number[], number[], bigint[]] = [[], [], []];\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n  // Pi\n  [x, y] = [y, (2 * x + 3 * y) % 5];\n  SHA3_PI.push(2 * (5 * y + x));\n  // Rotational\n  SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n  // Iota\n  let t = _0n;\n  for (let j = 0; j < 7; j++) {\n    R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n    if (R & _2n) t ^= _1n << ((_1n << BigInt(j)) - _1n);\n  }\n  _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = u64.split(_SHA3_IOTA, true);\n\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h: number, l: number, s: number) =>\n  s > 32 ? u64.rotlBH(h, l, s) : u64.rotlSH(h, l, s);\nconst rotlL = (h: number, l: number, s: number) =>\n  s > 32 ? u64.rotlBL(h, l, s) : u64.rotlSL(h, l, s);\n\n// Same as keccakf1600, but allows to skip some rounds\nexport function keccakP(s: Uint32Array, rounds: number = 24) {\n  const B = new Uint32Array(5 * 2);\n  // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n  for (let round = 24 - rounds; round < 24; round++) {\n    // Theta θ\n    for (let x = 0; x < 10; x++) B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n    for (let x = 0; x < 10; x += 2) {\n      const idx1 = (x + 8) % 10;\n      const idx0 = (x + 2) % 10;\n      const B0 = B[idx0];\n      const B1 = B[idx0 + 1];\n      const Th = rotlH(B0, B1, 1) ^ B[idx1];\n      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n      for (let y = 0; y < 50; y += 10) {\n        s[x + y] ^= Th;\n        s[x + y + 1] ^= Tl;\n      }\n    }\n    // Rho (ρ) and Pi (π)\n    let curH = s[2];\n    let curL = s[3];\n    for (let t = 0; t < 24; t++) {\n      const shift = SHA3_ROTL[t];\n      const Th = rotlH(curH, curL, shift);\n      const Tl = rotlL(curH, curL, shift);\n      const PI = SHA3_PI[t];\n      curH = s[PI];\n      curL = s[PI + 1];\n      s[PI] = Th;\n      s[PI + 1] = Tl;\n    }\n    // Chi (χ)\n    for (let y = 0; y < 50; y += 10) {\n      for (let x = 0; x < 10; x++) B[x] = s[y + x];\n      for (let x = 0; x < 10; x++) s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n    }\n    // Iota (ι)\n    s[0] ^= SHA3_IOTA_H[round];\n    s[1] ^= SHA3_IOTA_L[round];\n  }\n  B.fill(0);\n}\n\nexport class Keccak extends Hash<Keccak> implements HashXOF<Keccak> {\n  protected state: Uint8Array;\n  protected pos = 0;\n  protected posOut = 0;\n  protected finished = false;\n  protected state32: Uint32Array;\n  protected destroyed = false;\n  // NOTE: we accept arguments in bytes instead of bits here.\n  constructor(\n    public blockLen: number,\n    public suffix: number,\n    public outputLen: number,\n    protected enableXOF = false,\n    protected rounds: number = 24\n  ) {\n    super();\n    // Can be passed from user as dkLen\n    assert.number(outputLen);\n    // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n    if (0 >= this.blockLen || this.blockLen >= 200)\n      throw new Error('Sha3 supports only keccak-f1600 function');\n    this.state = new Uint8Array(200);\n    this.state32 = u32(this.state);\n  }\n  protected keccak() {\n    keccakP(this.state32, this.rounds);\n    this.posOut = 0;\n    this.pos = 0;\n  }\n  update(data: Input) {\n    assert.exists(this);\n    const { blockLen, state } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      for (let i = 0; i < take; i++) state[this.pos++] ^= data[pos++];\n      if (this.pos === blockLen) this.keccak();\n    }\n    return this;\n  }\n  protected finish() {\n    if (this.finished) return;\n    this.finished = true;\n    const { state, suffix, pos, blockLen } = this;\n    // Do the padding\n    state[pos] ^= suffix;\n    if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();\n    state[blockLen - 1] ^= 0x80;\n    this.keccak();\n  }\n  protected writeInto(out: Uint8Array): Uint8Array {\n    assert.exists(this, false);\n    assert.bytes(out);\n    this.finish();\n    const bufferOut = this.state;\n    const { blockLen } = this;\n    for (let pos = 0, len = out.length; pos < len; ) {\n      if (this.posOut >= blockLen) this.keccak();\n      const take = Math.min(blockLen - this.posOut, len - pos);\n      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n      this.posOut += take;\n      pos += take;\n    }\n    return out;\n  }\n  xofInto(out: Uint8Array): Uint8Array {\n    // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n    if (!this.enableXOF) throw new Error('XOF is not possible for this instance');\n    return this.writeInto(out);\n  }\n  xof(bytes: number): Uint8Array {\n    assert.number(bytes);\n    return this.xofInto(new Uint8Array(bytes));\n  }\n  digestInto(out: Uint8Array) {\n    assert.output(out, this);\n    if (this.finished) throw new Error('digest() was already called');\n    this.writeInto(out);\n    this.destroy();\n    return out;\n  }\n  digest() {\n    return this.digestInto(new Uint8Array(this.outputLen));\n  }\n  destroy() {\n    this.destroyed = true;\n    this.state.fill(0);\n  }\n  _cloneInto(to?: Keccak): Keccak {\n    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n    to ||= new Keccak(blockLen, suffix, outputLen, enableXOF, rounds);\n    to.state32.set(this.state32);\n    to.pos = this.pos;\n    to.posOut = this.posOut;\n    to.finished = this.finished;\n    to.rounds = rounds;\n    // Suffix can change in cSHAKE\n    to.suffix = suffix;\n    to.outputLen = outputLen;\n    to.enableXOF = enableXOF;\n    to.destroyed = this.destroyed;\n    return to;\n  }\n}\n\nconst gen = (suffix: number, blockLen: number, outputLen: number) =>\n  wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));\n\nexport const sha3_224 = gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nexport const sha3_256 = gen(0x06, 136, 256 / 8);\nexport const sha3_384 = gen(0x06, 104, 384 / 8);\nexport const sha3_512 = gen(0x06, 72, 512 / 8);\nexport const keccak_224 = gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nexport const keccak_256 = gen(0x01, 136, 256 / 8);\nexport const keccak_384 = gen(0x01, 104, 384 / 8);\nexport const keccak_512 = gen(0x01, 72, 512 / 8);\n\nexport type ShakeOpts = { dkLen?: number };\n\nconst genShake = (suffix: number, blockLen: number, outputLen: number) =>\n  wrapXOFConstructorWithOpts<HashXOF<Keccak>, ShakeOpts>(\n    (opts: ShakeOpts = {}) =>\n      new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true)\n  );\n\nexport const shake128 = genShake(0x1f, 168, 128 / 8);\nexport const shake256 = genShake(0x1f, 136, 256 / 8);\n"]},"metadata":{},"sourceType":"module"}