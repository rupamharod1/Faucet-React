{"ast":null,"code":"import { bytesRegex, execTyped, integerRegex, isTupleRegex } from \"./chunk-WP7KDV47.mjs\";\nimport { __publicField } from \"./chunk-NHABU752.mjs\"; // package.json\n\nvar name = \"abitype\";\nvar version = \"0.7.1\"; // src/errors.ts\n\nvar BaseError = class extends Error {\n  constructor(shortMessage) {\n    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const details = args.cause instanceof BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;\n    const docsPath = args.cause instanceof BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;\n    const message = [shortMessage || \"An error occurred.\", \"\", ...(args.metaMessages ? [...args.metaMessages, \"\"] : []), ...(docsPath ? [`Docs: https://abitype.dev${docsPath}`] : []), ...(details ? [`Details: ${details}`] : []), `Version: ${name}@${version}`].join(\"\\n\");\n    super(message);\n\n    __publicField(this, \"details\");\n\n    __publicField(this, \"docsPath\");\n\n    __publicField(this, \"metaMessages\");\n\n    __publicField(this, \"shortMessage\");\n\n    __publicField(this, \"name\", \"AbiTypeError\");\n\n    if (args.cause) this.cause = args.cause;\n    this.details = details;\n    this.docsPath = docsPath;\n    this.metaMessages = args.metaMessages;\n    this.shortMessage = shortMessage;\n  }\n\n}; // src/narrow.ts\n\nfunction narrow(value) {\n  return value;\n} // src/human-readable/runtime/signatures.ts\n\n\nvar errorSignatureRegex = /^error (?<name>[a-zA-Z0-9_]+)\\((?<parameters>.*?)\\)$/;\n\nfunction isErrorSignature(signature) {\n  return errorSignatureRegex.test(signature);\n}\n\nfunction execErrorSignature(signature) {\n  return execTyped(errorSignatureRegex, signature);\n}\n\nvar eventSignatureRegex = /^event (?<name>[a-zA-Z0-9_]+)\\((?<parameters>.*?)\\)$/;\n\nfunction isEventSignature(signature) {\n  return eventSignatureRegex.test(signature);\n}\n\nfunction execEventSignature(signature) {\n  return execTyped(eventSignatureRegex, signature);\n}\n\nvar functionSignatureRegex = /^function (?<name>[a-zA-Z0-9_]+)\\((?<parameters>.*?)\\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns \\((?<returns>.*?)\\))?$/;\n\nfunction isFunctionSignature(signature) {\n  return functionSignatureRegex.test(signature);\n}\n\nfunction execFunctionSignature(signature) {\n  return execTyped(functionSignatureRegex, signature);\n}\n\nvar structSignatureRegex = /^struct (?<name>[a-zA-Z0-9_]+) \\{(?<properties>.*?)\\}$/;\n\nfunction isStructSignature(signature) {\n  return structSignatureRegex.test(signature);\n}\n\nfunction execStructSignature(signature) {\n  return execTyped(structSignatureRegex, signature);\n}\n\nvar constructorSignatureRegex = /^constructor\\((?<parameters>.*?)\\)(?:\\s(?<stateMutability>payable{1}))?$/;\n\nfunction isConstructorSignature(signature) {\n  return constructorSignatureRegex.test(signature);\n}\n\nfunction execConstructorSignature(signature) {\n  return execTyped(constructorSignatureRegex, signature);\n}\n\nvar fallbackSignatureRegex = /^fallback\\(\\)$/;\n\nfunction isFallbackSignature(signature) {\n  return fallbackSignatureRegex.test(signature);\n}\n\nvar receiveSignatureRegex = /^receive\\(\\) external payable$/;\n\nfunction isReceiveSignature(signature) {\n  return receiveSignatureRegex.test(signature);\n}\n\nvar modifiers = /* @__PURE__ */new Set([\"memory\", \"indexed\", \"storage\", \"calldata\"]);\nvar eventModifiers = /* @__PURE__ */new Set([\"indexed\"]);\nvar functionModifiers = /* @__PURE__ */new Set([\"calldata\", \"memory\", \"storage\"]); // src/human-readable/runtime/cache.ts\n\nfunction getParameterCacheKey(param, type) {\n  if (type) return `${type}:${param}`;\n  return param;\n}\n\nvar parameterCache = /* @__PURE__ */new Map([// Unnamed\n[\"address\", {\n  type: \"address\"\n}], [\"bool\", {\n  type: \"bool\"\n}], [\"bytes\", {\n  type: \"bytes\"\n}], [\"bytes32\", {\n  type: \"bytes32\"\n}], [\"int\", {\n  type: \"int256\"\n}], [\"int256\", {\n  type: \"int256\"\n}], [\"string\", {\n  type: \"string\"\n}], [\"uint\", {\n  type: \"uint256\"\n}], [\"uint8\", {\n  type: \"uint8\"\n}], [\"uint16\", {\n  type: \"uint16\"\n}], [\"uint24\", {\n  type: \"uint24\"\n}], [\"uint32\", {\n  type: \"uint32\"\n}], [\"uint64\", {\n  type: \"uint64\"\n}], [\"uint96\", {\n  type: \"uint96\"\n}], [\"uint112\", {\n  type: \"uint112\"\n}], [\"uint160\", {\n  type: \"uint160\"\n}], [\"uint192\", {\n  type: \"uint192\"\n}], [\"uint256\", {\n  type: \"uint256\"\n}], // Named\n[\"address owner\", {\n  type: \"address\",\n  name: \"owner\"\n}], [\"address to\", {\n  type: \"address\",\n  name: \"to\"\n}], [\"bool approved\", {\n  type: \"bool\",\n  name: \"approved\"\n}], [\"bytes _data\", {\n  type: \"bytes\",\n  name: \"_data\"\n}], [\"bytes data\", {\n  type: \"bytes\",\n  name: \"data\"\n}], [\"bytes signature\", {\n  type: \"bytes\",\n  name: \"signature\"\n}], [\"bytes32 hash\", {\n  type: \"bytes32\",\n  name: \"hash\"\n}], [\"bytes32 r\", {\n  type: \"bytes32\",\n  name: \"r\"\n}], [\"bytes32 root\", {\n  type: \"bytes32\",\n  name: \"root\"\n}], [\"bytes32 s\", {\n  type: \"bytes32\",\n  name: \"s\"\n}], [\"string name\", {\n  type: \"string\",\n  name: \"name\"\n}], [\"string symbol\", {\n  type: \"string\",\n  name: \"symbol\"\n}], [\"string tokenURI\", {\n  type: \"string\",\n  name: \"tokenURI\"\n}], [\"uint tokenId\", {\n  type: \"uint256\",\n  name: \"tokenId\"\n}], [\"uint8 v\", {\n  type: \"uint8\",\n  name: \"v\"\n}], [\"uint256 balance\", {\n  type: \"uint256\",\n  name: \"balance\"\n}], [\"uint256 tokenId\", {\n  type: \"uint256\",\n  name: \"tokenId\"\n}], [\"uint256 value\", {\n  type: \"uint256\",\n  name: \"value\"\n}], // Indexed\n[\"event:address indexed from\", {\n  type: \"address\",\n  name: \"from\",\n  indexed: true\n}], [\"event:address indexed to\", {\n  type: \"address\",\n  name: \"to\",\n  indexed: true\n}], [\"event:uint indexed tokenId\", {\n  type: \"uint256\",\n  name: \"tokenId\",\n  indexed: true\n}], [\"event:uint256 indexed tokenId\", {\n  type: \"uint256\",\n  name: \"tokenId\",\n  indexed: true\n}]]); // src/human-readable/runtime/utils.ts\n\nfunction parseSignature(signature) {\n  let structs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (isFunctionSignature(signature)) {\n    const match = execFunctionSignature(signature);\n    if (!match) throw new BaseError(\"Invalid function signature.\", {\n      details: signature\n    });\n    const inputParams = splitParameters(match.parameters);\n    const inputs = [];\n    const inputLength = inputParams.length;\n\n    for (let i = 0; i < inputLength; i++) {\n      inputs.push(parseAbiParameter(inputParams[i], {\n        modifiers: functionModifiers,\n        structs,\n        type: \"function\"\n      }));\n    }\n\n    const outputs = [];\n\n    if (match.returns) {\n      const outputParams = splitParameters(match.returns);\n      const outputLength = outputParams.length;\n\n      for (let i = 0; i < outputLength; i++) {\n        outputs.push(parseAbiParameter(outputParams[i], {\n          modifiers: functionModifiers,\n          structs,\n          type: \"function\"\n        }));\n      }\n    }\n\n    return {\n      name: match.name,\n      type: \"function\",\n      stateMutability: match.stateMutability ?? \"nonpayable\",\n      inputs,\n      outputs\n    };\n  }\n\n  if (isEventSignature(signature)) {\n    const match = execEventSignature(signature);\n    if (!match) throw new BaseError(\"Invalid event signature.\", {\n      details: signature\n    });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(parseAbiParameter(params[i], {\n        modifiers: eventModifiers,\n        structs,\n        type: \"event\"\n      }));\n    }\n\n    return {\n      name: match.name,\n      type: \"event\",\n      inputs: abiParameters\n    };\n  }\n\n  if (isErrorSignature(signature)) {\n    const match = execErrorSignature(signature);\n    if (!match) throw new BaseError(\"Invalid error signature.\", {\n      details: signature\n    });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(parseAbiParameter(params[i], {\n        structs,\n        type: \"error\"\n      }));\n    }\n\n    return {\n      name: match.name,\n      type: \"error\",\n      inputs: abiParameters\n    };\n  }\n\n  if (isConstructorSignature(signature)) {\n    const match = execConstructorSignature(signature);\n    if (!match) throw new BaseError(\"Invalid constructor signature.\", {\n      details: signature\n    });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(parseAbiParameter(params[i], {\n        structs,\n        type: \"constructor\"\n      }));\n    }\n\n    return {\n      type: \"constructor\",\n      stateMutability: match.stateMutability ?? \"nonpayable\",\n      inputs: abiParameters\n    };\n  }\n\n  if (isFallbackSignature(signature)) return {\n    type: \"fallback\"\n  };\n  if (isReceiveSignature(signature)) return {\n    type: \"receive\",\n    stateMutability: \"payable\"\n  };\n  throw new BaseError(\"Unknown signature.\", {\n    details: signature\n  });\n}\n\nvar abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z0-9_]+))?$/;\nvar abiParameterWithTupleRegex = /^\\((?<type>.+?)\\)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z0-9_]+))?$/;\nvar dynamicIntegerRegex = /^u?int$/;\n\nfunction parseAbiParameter(param, options) {\n  const parameterCacheKey = getParameterCacheKey(param, options?.type);\n  if (parameterCache.has(parameterCacheKey)) return parameterCache.get(parameterCacheKey);\n  const isTuple = isTupleRegex.test(param);\n  const match = execTyped(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);\n  if (!match) throw new BaseError(\"Invalid ABI parameter.\", {\n    details: param\n  });\n  if (match.name && isSolidityKeyword(match.name)) throw new BaseError(\"Invalid ABI parameter.\", {\n    details: param,\n    metaMessages: [`\"${match.name}\" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`]\n  });\n  const name2 = match.name ? {\n    name: match.name\n  } : {};\n  const indexed = match.modifier === \"indexed\" ? {\n    indexed: true\n  } : {};\n  const structs = options?.structs ?? {};\n  let type;\n  let components = {};\n\n  if (isTuple) {\n    type = \"tuple\";\n    const params = splitParameters(match.type);\n    const components_ = [];\n    const length = params.length;\n\n    for (let i = 0; i < length; i++) {\n      components_.push(parseAbiParameter(params[i], {\n        structs\n      }));\n    }\n\n    components = {\n      components: components_\n    };\n  } else if (match.type in structs) {\n    type = \"tuple\";\n    components = {\n      components: structs[match.type]\n    };\n  } else if (dynamicIntegerRegex.test(match.type)) {\n    type = `${match.type}256`;\n  } else {\n    type = match.type;\n    if (!(options?.type === \"struct\") && !isSolidityType(type)) throw new BaseError(\"Unknown type.\", {\n      metaMessages: [`Type \"${type}\" is not a valid ABI type.`]\n    });\n  }\n\n  if (match.modifier) {\n    if (!options?.modifiers?.has?.(match.modifier)) throw new BaseError(\"Invalid ABI parameter.\", {\n      details: param,\n      metaMessages: [`Modifier \"${match.modifier}\" not allowed${options?.type ? ` in \"${options.type}\" type` : \"\"}.`]\n    });\n    if (functionModifiers.has(match.modifier) && !isValidDataLocation(type, !!match.array)) throw new BaseError(\"Invalid ABI parameter.\", {\n      details: param,\n      metaMessages: [`Modifier \"${match.modifier}\" not allowed${options?.type ? ` in \"${options.type}\" type` : \"\"}.`, `Data location can only be specified for array, struct, or mapping types, but \"${match.modifier}\" was given.`]\n    });\n  }\n\n  const abiParameter = {\n    type: `${type}${match.array ?? \"\"}`,\n    ...name2,\n    ...indexed,\n    ...components\n  };\n  parameterCache.set(parameterCacheKey, abiParameter);\n  return abiParameter;\n}\n\nfunction splitParameters(params) {\n  let result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let current = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n  let depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n  if (params === \"\") {\n    if (current === \"\") return result;\n    if (depth !== 0) throw new BaseError(\"Unbalanced parentheses.\", {\n      metaMessages: [`\"${current.trim()}\" has too many ${depth > 0 ? \"opening\" : \"closing\"} parentheses.`],\n      details: `Depth \"${depth}\"`\n    });\n    return [...result, current.trim()];\n  }\n\n  const length = params.length;\n\n  for (let i = 0; i < length; i++) {\n    const char = params[i];\n    const tail = params.slice(i + 1);\n\n    switch (char) {\n      case \",\":\n        return depth === 0 ? splitParameters(tail, [...result, current.trim()]) : splitParameters(tail, result, `${current}${char}`, depth);\n\n      case \"(\":\n        return splitParameters(tail, result, `${current}${char}`, depth + 1);\n\n      case \")\":\n        return splitParameters(tail, result, `${current}${char}`, depth - 1);\n\n      default:\n        return splitParameters(tail, result, `${current}${char}`, depth);\n    }\n  }\n\n  return [];\n}\n\nfunction isSolidityType(type) {\n  return type === \"address\" || type === \"bool\" || type === \"function\" || type === \"string\" || bytesRegex.test(type) || integerRegex.test(type);\n}\n\nvar protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;\n\nfunction isSolidityKeyword(name2) {\n  return name2 === \"address\" || name2 === \"bool\" || name2 === \"function\" || name2 === \"string\" || name2 === \"tuple\" || bytesRegex.test(name2) || integerRegex.test(name2) || protectedKeywordsRegex.test(name2);\n}\n\nfunction isValidDataLocation(type, isArray) {\n  return isArray || type === \"bytes\" || type === \"string\" || type === \"tuple\";\n} // src/human-readable/runtime/structs.ts\n\n\nfunction parseStructs(signatures) {\n  const shallowStructs = {};\n  const signaturesLength = signatures.length;\n\n  for (let i = 0; i < signaturesLength; i++) {\n    const signature = signatures[i];\n    if (!isStructSignature(signature)) continue;\n    const match = execStructSignature(signature);\n    if (!match) throw new BaseError(\"Invalid struct signature.\", {\n      details: signature\n    });\n    const properties = match.properties.split(\";\");\n    const components = [];\n    const propertiesLength = properties.length;\n\n    for (let k = 0; k < propertiesLength; k++) {\n      const property = properties[k];\n      const trimmed = property.trim();\n      if (!trimmed) continue;\n      const abiParameter = parseAbiParameter(trimmed, {\n        type: \"struct\"\n      });\n      components.push(abiParameter);\n    }\n\n    if (!components.length) throw new BaseError(\"Invalid struct signature.\", {\n      details: signature,\n      metaMessages: [\"No properties exist.\"]\n    });\n    shallowStructs[match.name] = components;\n  }\n\n  const resolvedStructs = {};\n  const entries = Object.entries(shallowStructs);\n  const entriesLength = entries.length;\n\n  for (let i = 0; i < entriesLength; i++) {\n    const [name2, parameters] = entries[i];\n    resolvedStructs[name2] = resolveStructs(parameters, shallowStructs);\n  }\n\n  return resolvedStructs;\n}\n\nvar typeWithoutTupleRegex = /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\\[\\d*?\\])+?)?$/;\n\nfunction resolveStructs(abiParameters, structs) {\n  let ancestors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : /* @__PURE__ */new Set();\n  const components = [];\n  const length = abiParameters.length;\n\n  for (let i = 0; i < length; i++) {\n    const abiParameter = abiParameters[i];\n    const isTuple = isTupleRegex.test(abiParameter.type);\n    if (isTuple) components.push(abiParameter);else {\n      const match = execTyped(typeWithoutTupleRegex, abiParameter.type);\n      if (!match?.type) throw new BaseError(\"Invalid ABI parameter.\", {\n        details: JSON.stringify(abiParameter, null, 2),\n        metaMessages: [\"ABI parameter type is invalid.\"]\n      });\n      const {\n        array,\n        type\n      } = match;\n\n      if (type in structs) {\n        if (ancestors.has(type)) throw new BaseError(\"Circular reference detected.\", {\n          metaMessages: [`Struct \"${type}\" is a circular reference.`]\n        });\n        components.push({ ...abiParameter,\n          type: `tuple${array ?? \"\"}`,\n          components: resolveStructs(structs[type] ?? [], structs, /* @__PURE__ */new Set([...ancestors, type]))\n        });\n      } else {\n        if (isSolidityType(type)) components.push(abiParameter);else throw new BaseError(\"Unknown type.\", {\n          metaMessages: [`Type \"${type}\" is not a valid ABI type. Perhaps you forgot to include a struct signature?`]\n        });\n      }\n    }\n  }\n\n  return components;\n} // src/human-readable/parseAbi.ts\n\n\nfunction parseAbi(signatures) {\n  const structs = parseStructs(signatures);\n  const abi = [];\n  const length = signatures.length;\n\n  for (let i = 0; i < length; i++) {\n    const signature = signatures[i];\n    if (isStructSignature(signature)) continue;\n    abi.push(parseSignature(signature, structs));\n  }\n\n  return abi;\n} // src/human-readable/parseAbiItem.ts\n\n\nfunction parseAbiItem(signature) {\n  let abiItem;\n  if (typeof signature === \"string\") abiItem = parseSignature(signature);else {\n    const structs = parseStructs(signature);\n    const length = signature.length;\n\n    for (let i = 0; i < length; i++) {\n      const signature_ = signature[i];\n      if (isStructSignature(signature_)) continue;\n      abiItem = parseSignature(signature_, structs);\n      break;\n    }\n  }\n  if (!abiItem) throw new BaseError(\"Failed to parse ABI item.\", {\n    details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,\n    docsPath: \"/api/human.html#parseabiitem-1\"\n  });\n  return abiItem;\n} // src/human-readable/parseAbiParameter.ts\n\n\nfunction parseAbiParameter2(param) {\n  let abiParameter;\n  if (typeof param === \"string\") abiParameter = parseAbiParameter(param, {\n    modifiers\n  });else {\n    const structs = parseStructs(param);\n    const length = param.length;\n\n    for (let i = 0; i < length; i++) {\n      const signature = param[i];\n      if (isStructSignature(signature)) continue;\n      abiParameter = parseAbiParameter(signature, {\n        modifiers,\n        structs\n      });\n      break;\n    }\n  }\n  if (!abiParameter) throw new BaseError(\"Failed to parse ABI parameter.\", {\n    details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,\n    docsPath: \"/api/human.html#parseabiparameter-1\"\n  });\n  return abiParameter;\n} // src/human-readable/parseAbiParameters.ts\n\n\nfunction parseAbiParameters(params) {\n  const abiParameters = [];\n\n  if (typeof params === \"string\") {\n    const parameters = splitParameters(params);\n    const length = parameters.length;\n\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(parseAbiParameter(parameters[i], {\n        modifiers\n      }));\n    }\n  } else {\n    const structs = parseStructs(params);\n    const length = params.length;\n\n    for (let i = 0; i < length; i++) {\n      const signature = params[i];\n      if (isStructSignature(signature)) continue;\n      const parameters = splitParameters(signature);\n      const length2 = parameters.length;\n\n      for (let k = 0; k < length2; k++) {\n        abiParameters.push(parseAbiParameter(parameters[k], {\n          modifiers,\n          structs\n        }));\n      }\n    }\n  }\n\n  if (abiParameters.length === 0) throw new BaseError(\"Failed to parse ABI parameters.\", {\n    details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,\n    docsPath: \"/api/human.html#parseabiparameters-1\"\n  });\n  return abiParameters;\n}\n\nexport { BaseError, narrow, parseAbi, parseAbiItem, parseAbiParameter2 as parseAbiParameter, parseAbiParameters };","map":{"version":3,"names":["bytesRegex","execTyped","integerRegex","isTupleRegex","__publicField","name","version","BaseError","Error","constructor","shortMessage","args","details","cause","message","docsPath","metaMessages","join","narrow","value","errorSignatureRegex","isErrorSignature","signature","test","execErrorSignature","eventSignatureRegex","isEventSignature","execEventSignature","functionSignatureRegex","isFunctionSignature","execFunctionSignature","structSignatureRegex","isStructSignature","execStructSignature","constructorSignatureRegex","isConstructorSignature","execConstructorSignature","fallbackSignatureRegex","isFallbackSignature","receiveSignatureRegex","isReceiveSignature","modifiers","Set","eventModifiers","functionModifiers","getParameterCacheKey","param","type","parameterCache","Map","indexed","parseSignature","structs","match","inputParams","splitParameters","parameters","inputs","inputLength","length","i","push","parseAbiParameter","outputs","returns","outputParams","outputLength","stateMutability","params","abiParameters","abiParameterWithoutTupleRegex","abiParameterWithTupleRegex","dynamicIntegerRegex","options","parameterCacheKey","has","get","isTuple","isSolidityKeyword","name2","modifier","components","components_","isSolidityType","isValidDataLocation","array","abiParameter","set","result","current","depth","trim","char","tail","slice","protectedKeywordsRegex","isArray","parseStructs","signatures","shallowStructs","signaturesLength","properties","split","propertiesLength","k","property","trimmed","resolvedStructs","entries","Object","entriesLength","resolveStructs","typeWithoutTupleRegex","ancestors","JSON","stringify","parseAbi","abi","parseAbiItem","abiItem","signature_","parseAbiParameter2","parseAbiParameters","length2"],"sources":["/home/rupam/Desktop/Faucet-React/node_modules/abitype/dist/index.mjs"],"sourcesContent":["import {\n  bytesRegex,\n  execTyped,\n  integerRegex,\n  isTupleRegex\n} from \"./chunk-WP7KDV47.mjs\";\nimport {\n  __publicField\n} from \"./chunk-NHABU752.mjs\";\n\n// package.json\nvar name = \"abitype\";\nvar version = \"0.7.1\";\n\n// src/errors.ts\nvar BaseError = class extends Error {\n  constructor(shortMessage, args = {}) {\n    const details = args.cause instanceof BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;\n    const docsPath = args.cause instanceof BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;\n    const message = [\n      shortMessage || \"An error occurred.\",\n      \"\",\n      ...args.metaMessages ? [...args.metaMessages, \"\"] : [],\n      ...docsPath ? [`Docs: https://abitype.dev${docsPath}`] : [],\n      ...details ? [`Details: ${details}`] : [],\n      `Version: ${name}@${version}`\n    ].join(\"\\n\");\n    super(message);\n    __publicField(this, \"details\");\n    __publicField(this, \"docsPath\");\n    __publicField(this, \"metaMessages\");\n    __publicField(this, \"shortMessage\");\n    __publicField(this, \"name\", \"AbiTypeError\");\n    if (args.cause)\n      this.cause = args.cause;\n    this.details = details;\n    this.docsPath = docsPath;\n    this.metaMessages = args.metaMessages;\n    this.shortMessage = shortMessage;\n  }\n};\n\n// src/narrow.ts\nfunction narrow(value) {\n  return value;\n}\n\n// src/human-readable/runtime/signatures.ts\nvar errorSignatureRegex = /^error (?<name>[a-zA-Z0-9_]+)\\((?<parameters>.*?)\\)$/;\nfunction isErrorSignature(signature) {\n  return errorSignatureRegex.test(signature);\n}\nfunction execErrorSignature(signature) {\n  return execTyped(\n    errorSignatureRegex,\n    signature\n  );\n}\nvar eventSignatureRegex = /^event (?<name>[a-zA-Z0-9_]+)\\((?<parameters>.*?)\\)$/;\nfunction isEventSignature(signature) {\n  return eventSignatureRegex.test(signature);\n}\nfunction execEventSignature(signature) {\n  return execTyped(\n    eventSignatureRegex,\n    signature\n  );\n}\nvar functionSignatureRegex = /^function (?<name>[a-zA-Z0-9_]+)\\((?<parameters>.*?)\\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns \\((?<returns>.*?)\\))?$/;\nfunction isFunctionSignature(signature) {\n  return functionSignatureRegex.test(signature);\n}\nfunction execFunctionSignature(signature) {\n  return execTyped(functionSignatureRegex, signature);\n}\nvar structSignatureRegex = /^struct (?<name>[a-zA-Z0-9_]+) \\{(?<properties>.*?)\\}$/;\nfunction isStructSignature(signature) {\n  return structSignatureRegex.test(signature);\n}\nfunction execStructSignature(signature) {\n  return execTyped(\n    structSignatureRegex,\n    signature\n  );\n}\nvar constructorSignatureRegex = /^constructor\\((?<parameters>.*?)\\)(?:\\s(?<stateMutability>payable{1}))?$/;\nfunction isConstructorSignature(signature) {\n  return constructorSignatureRegex.test(signature);\n}\nfunction execConstructorSignature(signature) {\n  return execTyped(constructorSignatureRegex, signature);\n}\nvar fallbackSignatureRegex = /^fallback\\(\\)$/;\nfunction isFallbackSignature(signature) {\n  return fallbackSignatureRegex.test(signature);\n}\nvar receiveSignatureRegex = /^receive\\(\\) external payable$/;\nfunction isReceiveSignature(signature) {\n  return receiveSignatureRegex.test(signature);\n}\nvar modifiers = /* @__PURE__ */ new Set([\n  \"memory\",\n  \"indexed\",\n  \"storage\",\n  \"calldata\"\n]);\nvar eventModifiers = /* @__PURE__ */ new Set([\"indexed\"]);\nvar functionModifiers = /* @__PURE__ */ new Set([\n  \"calldata\",\n  \"memory\",\n  \"storage\"\n]);\n\n// src/human-readable/runtime/cache.ts\nfunction getParameterCacheKey(param, type) {\n  if (type)\n    return `${type}:${param}`;\n  return param;\n}\nvar parameterCache = /* @__PURE__ */ new Map([\n  // Unnamed\n  [\"address\", { type: \"address\" }],\n  [\"bool\", { type: \"bool\" }],\n  [\"bytes\", { type: \"bytes\" }],\n  [\"bytes32\", { type: \"bytes32\" }],\n  [\"int\", { type: \"int256\" }],\n  [\"int256\", { type: \"int256\" }],\n  [\"string\", { type: \"string\" }],\n  [\"uint\", { type: \"uint256\" }],\n  [\"uint8\", { type: \"uint8\" }],\n  [\"uint16\", { type: \"uint16\" }],\n  [\"uint24\", { type: \"uint24\" }],\n  [\"uint32\", { type: \"uint32\" }],\n  [\"uint64\", { type: \"uint64\" }],\n  [\"uint96\", { type: \"uint96\" }],\n  [\"uint112\", { type: \"uint112\" }],\n  [\"uint160\", { type: \"uint160\" }],\n  [\"uint192\", { type: \"uint192\" }],\n  [\"uint256\", { type: \"uint256\" }],\n  // Named\n  [\"address owner\", { type: \"address\", name: \"owner\" }],\n  [\"address to\", { type: \"address\", name: \"to\" }],\n  [\"bool approved\", { type: \"bool\", name: \"approved\" }],\n  [\"bytes _data\", { type: \"bytes\", name: \"_data\" }],\n  [\"bytes data\", { type: \"bytes\", name: \"data\" }],\n  [\"bytes signature\", { type: \"bytes\", name: \"signature\" }],\n  [\"bytes32 hash\", { type: \"bytes32\", name: \"hash\" }],\n  [\"bytes32 r\", { type: \"bytes32\", name: \"r\" }],\n  [\"bytes32 root\", { type: \"bytes32\", name: \"root\" }],\n  [\"bytes32 s\", { type: \"bytes32\", name: \"s\" }],\n  [\"string name\", { type: \"string\", name: \"name\" }],\n  [\"string symbol\", { type: \"string\", name: \"symbol\" }],\n  [\"string tokenURI\", { type: \"string\", name: \"tokenURI\" }],\n  [\"uint tokenId\", { type: \"uint256\", name: \"tokenId\" }],\n  [\"uint8 v\", { type: \"uint8\", name: \"v\" }],\n  [\"uint256 balance\", { type: \"uint256\", name: \"balance\" }],\n  [\"uint256 tokenId\", { type: \"uint256\", name: \"tokenId\" }],\n  [\"uint256 value\", { type: \"uint256\", name: \"value\" }],\n  // Indexed\n  [\n    \"event:address indexed from\",\n    { type: \"address\", name: \"from\", indexed: true }\n  ],\n  [\"event:address indexed to\", { type: \"address\", name: \"to\", indexed: true }],\n  [\n    \"event:uint indexed tokenId\",\n    { type: \"uint256\", name: \"tokenId\", indexed: true }\n  ],\n  [\n    \"event:uint256 indexed tokenId\",\n    { type: \"uint256\", name: \"tokenId\", indexed: true }\n  ]\n]);\n\n// src/human-readable/runtime/utils.ts\nfunction parseSignature(signature, structs = {}) {\n  if (isFunctionSignature(signature)) {\n    const match = execFunctionSignature(signature);\n    if (!match)\n      throw new BaseError(\"Invalid function signature.\", {\n        details: signature\n      });\n    const inputParams = splitParameters(match.parameters);\n    const inputs = [];\n    const inputLength = inputParams.length;\n    for (let i = 0; i < inputLength; i++) {\n      inputs.push(\n        parseAbiParameter(inputParams[i], {\n          modifiers: functionModifiers,\n          structs,\n          type: \"function\"\n        })\n      );\n    }\n    const outputs = [];\n    if (match.returns) {\n      const outputParams = splitParameters(match.returns);\n      const outputLength = outputParams.length;\n      for (let i = 0; i < outputLength; i++) {\n        outputs.push(\n          parseAbiParameter(outputParams[i], {\n            modifiers: functionModifiers,\n            structs,\n            type: \"function\"\n          })\n        );\n      }\n    }\n    return {\n      name: match.name,\n      type: \"function\",\n      stateMutability: match.stateMutability ?? \"nonpayable\",\n      inputs,\n      outputs\n    };\n  }\n  if (isEventSignature(signature)) {\n    const match = execEventSignature(signature);\n    if (!match)\n      throw new BaseError(\"Invalid event signature.\", {\n        details: signature\n      });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(\n        parseAbiParameter(params[i], {\n          modifiers: eventModifiers,\n          structs,\n          type: \"event\"\n        })\n      );\n    }\n    return { name: match.name, type: \"event\", inputs: abiParameters };\n  }\n  if (isErrorSignature(signature)) {\n    const match = execErrorSignature(signature);\n    if (!match)\n      throw new BaseError(\"Invalid error signature.\", {\n        details: signature\n      });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(\n        parseAbiParameter(params[i], { structs, type: \"error\" })\n      );\n    }\n    return { name: match.name, type: \"error\", inputs: abiParameters };\n  }\n  if (isConstructorSignature(signature)) {\n    const match = execConstructorSignature(signature);\n    if (!match)\n      throw new BaseError(\"Invalid constructor signature.\", {\n        details: signature\n      });\n    const params = splitParameters(match.parameters);\n    const abiParameters = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(\n        parseAbiParameter(params[i], { structs, type: \"constructor\" })\n      );\n    }\n    return {\n      type: \"constructor\",\n      stateMutability: match.stateMutability ?? \"nonpayable\",\n      inputs: abiParameters\n    };\n  }\n  if (isFallbackSignature(signature))\n    return { type: \"fallback\" };\n  if (isReceiveSignature(signature))\n    return {\n      type: \"receive\",\n      stateMutability: \"payable\"\n    };\n  throw new BaseError(\"Unknown signature.\", {\n    details: signature\n  });\n}\nvar abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z0-9_]+))?$/;\nvar abiParameterWithTupleRegex = /^\\((?<type>.+?)\\)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z0-9_]+))?$/;\nvar dynamicIntegerRegex = /^u?int$/;\nfunction parseAbiParameter(param, options) {\n  const parameterCacheKey = getParameterCacheKey(param, options?.type);\n  if (parameterCache.has(parameterCacheKey))\n    return parameterCache.get(parameterCacheKey);\n  const isTuple = isTupleRegex.test(param);\n  const match = execTyped(\n    isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex,\n    param\n  );\n  if (!match)\n    throw new BaseError(\"Invalid ABI parameter.\", {\n      details: param\n    });\n  if (match.name && isSolidityKeyword(match.name))\n    throw new BaseError(\"Invalid ABI parameter.\", {\n      details: param,\n      metaMessages: [\n        `\"${match.name}\" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`\n      ]\n    });\n  const name2 = match.name ? { name: match.name } : {};\n  const indexed = match.modifier === \"indexed\" ? { indexed: true } : {};\n  const structs = options?.structs ?? {};\n  let type;\n  let components = {};\n  if (isTuple) {\n    type = \"tuple\";\n    const params = splitParameters(match.type);\n    const components_ = [];\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      components_.push(parseAbiParameter(params[i], { structs }));\n    }\n    components = { components: components_ };\n  } else if (match.type in structs) {\n    type = \"tuple\";\n    components = { components: structs[match.type] };\n  } else if (dynamicIntegerRegex.test(match.type)) {\n    type = `${match.type}256`;\n  } else {\n    type = match.type;\n    if (!(options?.type === \"struct\") && !isSolidityType(type))\n      throw new BaseError(\"Unknown type.\", {\n        metaMessages: [`Type \"${type}\" is not a valid ABI type.`]\n      });\n  }\n  if (match.modifier) {\n    if (!options?.modifiers?.has?.(match.modifier))\n      throw new BaseError(\"Invalid ABI parameter.\", {\n        details: param,\n        metaMessages: [\n          `Modifier \"${match.modifier}\" not allowed${options?.type ? ` in \"${options.type}\" type` : \"\"}.`\n        ]\n      });\n    if (functionModifiers.has(match.modifier) && !isValidDataLocation(type, !!match.array))\n      throw new BaseError(\"Invalid ABI parameter.\", {\n        details: param,\n        metaMessages: [\n          `Modifier \"${match.modifier}\" not allowed${options?.type ? ` in \"${options.type}\" type` : \"\"}.`,\n          `Data location can only be specified for array, struct, or mapping types, but \"${match.modifier}\" was given.`\n        ]\n      });\n  }\n  const abiParameter = {\n    type: `${type}${match.array ?? \"\"}`,\n    ...name2,\n    ...indexed,\n    ...components\n  };\n  parameterCache.set(parameterCacheKey, abiParameter);\n  return abiParameter;\n}\nfunction splitParameters(params, result = [], current = \"\", depth = 0) {\n  if (params === \"\") {\n    if (current === \"\")\n      return result;\n    if (depth !== 0)\n      throw new BaseError(\"Unbalanced parentheses.\", {\n        metaMessages: [\n          `\"${current.trim()}\" has too many ${depth > 0 ? \"opening\" : \"closing\"} parentheses.`\n        ],\n        details: `Depth \"${depth}\"`\n      });\n    return [...result, current.trim()];\n  }\n  const length = params.length;\n  for (let i = 0; i < length; i++) {\n    const char = params[i];\n    const tail = params.slice(i + 1);\n    switch (char) {\n      case \",\":\n        return depth === 0 ? splitParameters(tail, [...result, current.trim()]) : splitParameters(tail, result, `${current}${char}`, depth);\n      case \"(\":\n        return splitParameters(tail, result, `${current}${char}`, depth + 1);\n      case \")\":\n        return splitParameters(tail, result, `${current}${char}`, depth - 1);\n      default:\n        return splitParameters(tail, result, `${current}${char}`, depth);\n    }\n  }\n  return [];\n}\nfunction isSolidityType(type) {\n  return type === \"address\" || type === \"bool\" || type === \"function\" || type === \"string\" || bytesRegex.test(type) || integerRegex.test(type);\n}\nvar protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;\nfunction isSolidityKeyword(name2) {\n  return name2 === \"address\" || name2 === \"bool\" || name2 === \"function\" || name2 === \"string\" || name2 === \"tuple\" || bytesRegex.test(name2) || integerRegex.test(name2) || protectedKeywordsRegex.test(name2);\n}\nfunction isValidDataLocation(type, isArray) {\n  return isArray || type === \"bytes\" || type === \"string\" || type === \"tuple\";\n}\n\n// src/human-readable/runtime/structs.ts\nfunction parseStructs(signatures) {\n  const shallowStructs = {};\n  const signaturesLength = signatures.length;\n  for (let i = 0; i < signaturesLength; i++) {\n    const signature = signatures[i];\n    if (!isStructSignature(signature))\n      continue;\n    const match = execStructSignature(signature);\n    if (!match)\n      throw new BaseError(\"Invalid struct signature.\", {\n        details: signature\n      });\n    const properties = match.properties.split(\";\");\n    const components = [];\n    const propertiesLength = properties.length;\n    for (let k = 0; k < propertiesLength; k++) {\n      const property = properties[k];\n      const trimmed = property.trim();\n      if (!trimmed)\n        continue;\n      const abiParameter = parseAbiParameter(trimmed, {\n        type: \"struct\"\n      });\n      components.push(abiParameter);\n    }\n    if (!components.length)\n      throw new BaseError(\"Invalid struct signature.\", {\n        details: signature,\n        metaMessages: [\"No properties exist.\"]\n      });\n    shallowStructs[match.name] = components;\n  }\n  const resolvedStructs = {};\n  const entries = Object.entries(shallowStructs);\n  const entriesLength = entries.length;\n  for (let i = 0; i < entriesLength; i++) {\n    const [name2, parameters] = entries[i];\n    resolvedStructs[name2] = resolveStructs(parameters, shallowStructs);\n  }\n  return resolvedStructs;\n}\nvar typeWithoutTupleRegex = /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\\[\\d*?\\])+?)?$/;\nfunction resolveStructs(abiParameters, structs, ancestors = /* @__PURE__ */ new Set()) {\n  const components = [];\n  const length = abiParameters.length;\n  for (let i = 0; i < length; i++) {\n    const abiParameter = abiParameters[i];\n    const isTuple = isTupleRegex.test(abiParameter.type);\n    if (isTuple)\n      components.push(abiParameter);\n    else {\n      const match = execTyped(\n        typeWithoutTupleRegex,\n        abiParameter.type\n      );\n      if (!match?.type)\n        throw new BaseError(\"Invalid ABI parameter.\", {\n          details: JSON.stringify(abiParameter, null, 2),\n          metaMessages: [\"ABI parameter type is invalid.\"]\n        });\n      const { array, type } = match;\n      if (type in structs) {\n        if (ancestors.has(type))\n          throw new BaseError(\"Circular reference detected.\", {\n            metaMessages: [`Struct \"${type}\" is a circular reference.`]\n          });\n        components.push({\n          ...abiParameter,\n          type: `tuple${array ?? \"\"}`,\n          components: resolveStructs(\n            structs[type] ?? [],\n            structs,\n            /* @__PURE__ */ new Set([...ancestors, type])\n          )\n        });\n      } else {\n        if (isSolidityType(type))\n          components.push(abiParameter);\n        else\n          throw new BaseError(\"Unknown type.\", {\n            metaMessages: [\n              `Type \"${type}\" is not a valid ABI type. Perhaps you forgot to include a struct signature?`\n            ]\n          });\n      }\n    }\n  }\n  return components;\n}\n\n// src/human-readable/parseAbi.ts\nfunction parseAbi(signatures) {\n  const structs = parseStructs(signatures);\n  const abi = [];\n  const length = signatures.length;\n  for (let i = 0; i < length; i++) {\n    const signature = signatures[i];\n    if (isStructSignature(signature))\n      continue;\n    abi.push(parseSignature(signature, structs));\n  }\n  return abi;\n}\n\n// src/human-readable/parseAbiItem.ts\nfunction parseAbiItem(signature) {\n  let abiItem;\n  if (typeof signature === \"string\")\n    abiItem = parseSignature(signature);\n  else {\n    const structs = parseStructs(signature);\n    const length = signature.length;\n    for (let i = 0; i < length; i++) {\n      const signature_ = signature[i];\n      if (isStructSignature(signature_))\n        continue;\n      abiItem = parseSignature(signature_, structs);\n      break;\n    }\n  }\n  if (!abiItem)\n    throw new BaseError(\"Failed to parse ABI item.\", {\n      details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,\n      docsPath: \"/api/human.html#parseabiitem-1\"\n    });\n  return abiItem;\n}\n\n// src/human-readable/parseAbiParameter.ts\nfunction parseAbiParameter2(param) {\n  let abiParameter;\n  if (typeof param === \"string\")\n    abiParameter = parseAbiParameter(param, {\n      modifiers\n    });\n  else {\n    const structs = parseStructs(param);\n    const length = param.length;\n    for (let i = 0; i < length; i++) {\n      const signature = param[i];\n      if (isStructSignature(signature))\n        continue;\n      abiParameter = parseAbiParameter(signature, { modifiers, structs });\n      break;\n    }\n  }\n  if (!abiParameter)\n    throw new BaseError(\"Failed to parse ABI parameter.\", {\n      details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,\n      docsPath: \"/api/human.html#parseabiparameter-1\"\n    });\n  return abiParameter;\n}\n\n// src/human-readable/parseAbiParameters.ts\nfunction parseAbiParameters(params) {\n  const abiParameters = [];\n  if (typeof params === \"string\") {\n    const parameters = splitParameters(params);\n    const length = parameters.length;\n    for (let i = 0; i < length; i++) {\n      abiParameters.push(parseAbiParameter(parameters[i], { modifiers }));\n    }\n  } else {\n    const structs = parseStructs(params);\n    const length = params.length;\n    for (let i = 0; i < length; i++) {\n      const signature = params[i];\n      if (isStructSignature(signature))\n        continue;\n      const parameters = splitParameters(signature);\n      const length2 = parameters.length;\n      for (let k = 0; k < length2; k++) {\n        abiParameters.push(\n          parseAbiParameter(parameters[k], { modifiers, structs })\n        );\n      }\n    }\n  }\n  if (abiParameters.length === 0)\n    throw new BaseError(\"Failed to parse ABI parameters.\", {\n      details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,\n      docsPath: \"/api/human.html#parseabiparameters-1\"\n    });\n  return abiParameters;\n}\nexport {\n  BaseError,\n  narrow,\n  parseAbi,\n  parseAbiItem,\n  parseAbiParameter2 as parseAbiParameter,\n  parseAbiParameters\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}