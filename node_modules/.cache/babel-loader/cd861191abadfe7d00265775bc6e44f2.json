{"ast":null,"code":"/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y² = x³ + ax + b\nimport * as mod from './modular.js';\nimport * as ut from './utils.js';\nimport { ensureBytes } from './utils.js';\nimport { wNAF, validateBasic } from './curve.js';\n\nfunction validatePointOpts(curve) {\n  const opts = validateBasic(curve);\n  ut.validateObject(opts, {\n    a: 'field',\n    b: 'field'\n  }, {\n    allowedPrivateKeyLengths: 'array',\n    wrapPrivateKey: 'boolean',\n    isTorsionFree: 'function',\n    clearCofactor: 'function',\n    allowInfinityPoint: 'boolean',\n    fromBytes: 'function',\n    toBytes: 'function'\n  });\n  const {\n    endo,\n    Fp,\n    a\n  } = opts;\n\n  if (endo) {\n    if (!Fp.eql(a, Fp.ZERO)) {\n      throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n    }\n\n    if (typeof endo !== 'object' || typeof endo.beta !== 'bigint' || typeof endo.splitScalar !== 'function') {\n      throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n    }\n  }\n\n  return Object.freeze({ ...opts\n  });\n} // ASN.1 DER encoding utilities\n\n\nconst {\n  bytesToNumberBE: b2n,\n  hexToBytes: h2b\n} = ut;\nexport const DER = {\n  // asn.1 DER encoding utils\n  Err: class DERErr extends Error {\n    constructor() {\n      let m = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      super(m);\n    }\n\n  },\n\n  _parseInt(data) {\n    const {\n      Err: E\n    } = DER;\n    if (data.length < 2 || data[0] !== 0x02) throw new E('Invalid signature integer tag');\n    const len = data[1];\n    const res = data.subarray(2, len + 2);\n    if (!len || res.length !== len) throw new E('Invalid signature integer: wrong length'); // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n\n    if (res[0] & 0b10000000) throw new E('Invalid signature integer: negative');\n    if (res[0] === 0x00 && !(res[1] & 0b10000000)) throw new E('Invalid signature integer: unnecessary leading zero');\n    return {\n      d: b2n(res),\n      l: data.subarray(len + 2)\n    }; // d is data, l is left\n  },\n\n  toSig(hex) {\n    // parse DER signature\n    const {\n      Err: E\n    } = DER;\n    const data = typeof hex === 'string' ? h2b(hex) : hex;\n    if (!(data instanceof Uint8Array)) throw new Error('ui8a expected');\n    let l = data.length;\n    if (l < 2 || data[0] != 0x30) throw new E('Invalid signature tag');\n    if (data[1] !== l - 2) throw new E('Invalid signature: incorrect length');\n\n    const {\n      d: r,\n      l: sBytes\n    } = DER._parseInt(data.subarray(2));\n\n    const {\n      d: s,\n      l: rBytesLeft\n    } = DER._parseInt(sBytes);\n\n    if (rBytesLeft.length) throw new E('Invalid signature: left bytes after parsing');\n    return {\n      r,\n      s\n    };\n  },\n\n  hexFromSig(sig) {\n    // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n    const slice = s => Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s;\n\n    const h = num => {\n      const hex = num.toString(16);\n      return hex.length & 1 ? `0${hex}` : hex;\n    };\n\n    const s = slice(h(sig.s));\n    const r = slice(h(sig.r));\n    const shl = s.length / 2;\n    const rhl = r.length / 2;\n    const sl = h(shl);\n    const rl = h(rhl);\n    return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n  }\n\n}; // Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\n\nconst _0n = BigInt(0),\n      _1n = BigInt(1),\n      _2n = BigInt(2),\n      _3n = BigInt(3),\n      _4n = BigInt(4);\n\nexport function weierstrassPoints(opts) {\n  const CURVE = validatePointOpts(opts);\n  const {\n    Fp\n  } = CURVE; // All curves has same field / group length as for now, but they can differ\n\n  const toBytes = CURVE.toBytes || ((c, point, isCompressed) => {\n    const a = point.toAffine();\n    return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n  });\n\n  const fromBytes = CURVE.fromBytes || (bytes => {\n    // const head = bytes[0];\n    const tail = bytes.subarray(1); // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n\n    const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n    const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n    return {\n      x,\n      y\n    };\n  });\n  /**\n   * y² = x³ + ax + b: Short weierstrass curve formula\n   * @returns y²\n   */\n\n\n  function weierstrassEquation(x) {\n    const {\n      a,\n      b\n    } = CURVE;\n    const x2 = Fp.sqr(x); // x * x\n\n    const x3 = Fp.mul(x2, x); // x2 * x\n\n    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n  } // Validate whether the passed curve params are valid.\n  // We check if curve equation works for generator point.\n  // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n  // ProjectivePoint class has not been initialized yet.\n\n\n  if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx))) throw new Error('bad generator point: equation left != right'); // Valid group elements reside in range 1..n-1\n\n  function isWithinCurveOrder(num) {\n    return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n  }\n\n  function assertGE(num) {\n    if (!isWithinCurveOrder(num)) throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n  } // Validates if priv key is valid and converts it to bigint.\n  // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n\n\n  function normPrivateKeyToScalar(key) {\n    const {\n      allowedPrivateKeyLengths: lengths,\n      nByteLength,\n      wrapPrivateKey,\n      n\n    } = CURVE;\n\n    if (lengths && typeof key !== 'bigint') {\n      if (key instanceof Uint8Array) key = ut.bytesToHex(key); // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n\n      if (typeof key !== 'string' || !lengths.includes(key.length)) throw new Error('Invalid key');\n      key = key.padStart(nByteLength * 2, '0');\n    }\n\n    let num;\n\n    try {\n      num = typeof key === 'bigint' ? key : ut.bytesToNumberBE(ensureBytes('private key', key, nByteLength));\n    } catch (error) {\n      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n    }\n\n    if (wrapPrivateKey) num = mod.mod(num, n); // disabled by default, enabled for BLS\n\n    assertGE(num); // num in range [1..N-1]\n\n    return num;\n  }\n\n  const pointPrecomputes = new Map();\n\n  function assertPrjPoint(other) {\n    if (!(other instanceof Point)) throw new Error('ProjectivePoint expected');\n  }\n  /**\n   * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n   * Default Point works in 2d / affine coordinates: (x, y)\n   * We're doing calculations in projective, because its operations don't require costly inversion.\n   */\n\n\n  class Point {\n    constructor(px, py, pz) {\n      this.px = px;\n      this.py = py;\n      this.pz = pz;\n      if (px == null || !Fp.isValid(px)) throw new Error('x required');\n      if (py == null || !Fp.isValid(py)) throw new Error('y required');\n      if (pz == null || !Fp.isValid(pz)) throw new Error('z required');\n    } // Does not validate if the point is on-curve.\n    // Use fromHex instead, or call assertValidity() later.\n\n\n    static fromAffine(p) {\n      const {\n        x,\n        y\n      } = p || {};\n      if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error('invalid affine point');\n      if (p instanceof Point) throw new Error('projective point not allowed');\n\n      const is0 = i => Fp.eql(i, Fp.ZERO); // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n\n\n      if (is0(x) && is0(y)) return Point.ZERO;\n      return new Point(x, y, Fp.ONE);\n    }\n\n    get x() {\n      return this.toAffine().x;\n    }\n\n    get y() {\n      return this.toAffine().y;\n    }\n    /**\n     * Takes a bunch of Projective Points but executes only one\n     * inversion on all of them. Inversion is very slow operation,\n     * so this improves performance massively.\n     * Optimization: converts a list of projective points to a list of identical points with Z=1.\n     */\n\n\n    static normalizeZ(points) {\n      const toInv = Fp.invertBatch(points.map(p => p.pz));\n      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n    }\n    /**\n     * Converts hash string or Uint8Array to Point.\n     * @param hex short/long ECDSA hex\n     */\n\n\n    static fromHex(hex) {\n      const P = Point.fromAffine(fromBytes(ensureBytes('pointHex', hex)));\n      P.assertValidity();\n      return P;\n    } // Multiplies generator point by privateKey.\n\n\n    static fromPrivateKey(privateKey) {\n      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n    } // \"Private method\", don't use it directly\n\n\n    _setWindowSize(windowSize) {\n      this._WINDOW_SIZE = windowSize;\n      pointPrecomputes.delete(this);\n    } // A point on curve is valid if it conforms to equation.\n\n\n    assertValidity() {\n      // Zero is valid point too!\n      if (this.is0()) {\n        if (CURVE.allowInfinityPoint) return;\n        throw new Error('bad point: ZERO');\n      } // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n\n\n      const {\n        x,\n        y\n      } = this.toAffine(); // Check if x, y are valid field elements\n\n      if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error('bad point: x or y not FE');\n      const left = Fp.sqr(y); // y²\n\n      const right = weierstrassEquation(x); // x³ + ax + b\n\n      if (!Fp.eql(left, right)) throw new Error('bad point: equation left != right');\n      if (!this.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');\n    }\n\n    hasEvenY() {\n      const {\n        y\n      } = this.toAffine();\n      if (Fp.isOdd) return !Fp.isOdd(y);\n      throw new Error(\"Field doesn't support isOdd\");\n    }\n    /**\n     * Compare one point to another.\n     */\n\n\n    equals(other) {\n      assertPrjPoint(other);\n      const {\n        px: X1,\n        py: Y1,\n        pz: Z1\n      } = this;\n      const {\n        px: X2,\n        py: Y2,\n        pz: Z2\n      } = other;\n      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n      return U1 && U2;\n    }\n    /**\n     * Flips point to one corresponding to (x, -y) in Affine coordinates.\n     */\n\n\n    negate() {\n      return new Point(this.px, Fp.neg(this.py), this.pz);\n    } // Renes-Costello-Batina exception-free doubling formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 3\n    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n\n\n    double() {\n      const {\n        a,\n        b\n      } = CURVE;\n      const b3 = Fp.mul(b, _3n);\n      const {\n        px: X1,\n        py: Y1,\n        pz: Z1\n      } = this;\n      let X3 = Fp.ZERO,\n          Y3 = Fp.ZERO,\n          Z3 = Fp.ZERO; // prettier-ignore\n\n      let t0 = Fp.mul(X1, X1); // step 1\n\n      let t1 = Fp.mul(Y1, Y1);\n      let t2 = Fp.mul(Z1, Z1);\n      let t3 = Fp.mul(X1, Y1);\n      t3 = Fp.add(t3, t3); // step 5\n\n      Z3 = Fp.mul(X1, Z1);\n      Z3 = Fp.add(Z3, Z3);\n      X3 = Fp.mul(a, Z3);\n      Y3 = Fp.mul(b3, t2);\n      Y3 = Fp.add(X3, Y3); // step 10\n\n      X3 = Fp.sub(t1, Y3);\n      Y3 = Fp.add(t1, Y3);\n      Y3 = Fp.mul(X3, Y3);\n      X3 = Fp.mul(t3, X3);\n      Z3 = Fp.mul(b3, Z3); // step 15\n\n      t2 = Fp.mul(a, t2);\n      t3 = Fp.sub(t0, t2);\n      t3 = Fp.mul(a, t3);\n      t3 = Fp.add(t3, Z3);\n      Z3 = Fp.add(t0, t0); // step 20\n\n      t0 = Fp.add(Z3, t0);\n      t0 = Fp.add(t0, t2);\n      t0 = Fp.mul(t0, t3);\n      Y3 = Fp.add(Y3, t0);\n      t2 = Fp.mul(Y1, Z1); // step 25\n\n      t2 = Fp.add(t2, t2);\n      t0 = Fp.mul(t2, t3);\n      X3 = Fp.sub(X3, t0);\n      Z3 = Fp.mul(t2, t1);\n      Z3 = Fp.add(Z3, Z3); // step 30\n\n      Z3 = Fp.add(Z3, Z3);\n      return new Point(X3, Y3, Z3);\n    } // Renes-Costello-Batina exception-free addition formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 1\n    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n\n\n    add(other) {\n      assertPrjPoint(other);\n      const {\n        px: X1,\n        py: Y1,\n        pz: Z1\n      } = this;\n      const {\n        px: X2,\n        py: Y2,\n        pz: Z2\n      } = other;\n      let X3 = Fp.ZERO,\n          Y3 = Fp.ZERO,\n          Z3 = Fp.ZERO; // prettier-ignore\n\n      const a = CURVE.a;\n      const b3 = Fp.mul(CURVE.b, _3n);\n      let t0 = Fp.mul(X1, X2); // step 1\n\n      let t1 = Fp.mul(Y1, Y2);\n      let t2 = Fp.mul(Z1, Z2);\n      let t3 = Fp.add(X1, Y1);\n      let t4 = Fp.add(X2, Y2); // step 5\n\n      t3 = Fp.mul(t3, t4);\n      t4 = Fp.add(t0, t1);\n      t3 = Fp.sub(t3, t4);\n      t4 = Fp.add(X1, Z1);\n      let t5 = Fp.add(X2, Z2); // step 10\n\n      t4 = Fp.mul(t4, t5);\n      t5 = Fp.add(t0, t2);\n      t4 = Fp.sub(t4, t5);\n      t5 = Fp.add(Y1, Z1);\n      X3 = Fp.add(Y2, Z2); // step 15\n\n      t5 = Fp.mul(t5, X3);\n      X3 = Fp.add(t1, t2);\n      t5 = Fp.sub(t5, X3);\n      Z3 = Fp.mul(a, t4);\n      X3 = Fp.mul(b3, t2); // step 20\n\n      Z3 = Fp.add(X3, Z3);\n      X3 = Fp.sub(t1, Z3);\n      Z3 = Fp.add(t1, Z3);\n      Y3 = Fp.mul(X3, Z3);\n      t1 = Fp.add(t0, t0); // step 25\n\n      t1 = Fp.add(t1, t0);\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.mul(b3, t4);\n      t1 = Fp.add(t1, t2);\n      t2 = Fp.sub(t0, t2); // step 30\n\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.add(t4, t2);\n      t0 = Fp.mul(t1, t4);\n      Y3 = Fp.add(Y3, t0);\n      t0 = Fp.mul(t5, t4); // step 35\n\n      X3 = Fp.mul(t3, X3);\n      X3 = Fp.sub(X3, t0);\n      t0 = Fp.mul(t3, t1);\n      Z3 = Fp.mul(t5, Z3);\n      Z3 = Fp.add(Z3, t0); // step 40\n\n      return new Point(X3, Y3, Z3);\n    }\n\n    subtract(other) {\n      return this.add(other.negate());\n    }\n\n    is0() {\n      return this.equals(Point.ZERO);\n    }\n\n    wNAF(n) {\n      return wnaf.wNAFCached(this, pointPrecomputes, n, comp => {\n        const toInv = Fp.invertBatch(comp.map(p => p.pz));\n        return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n      });\n    }\n    /**\n     * Non-constant-time multiplication. Uses double-and-add algorithm.\n     * It's faster, but should only be used when you don't care about\n     * an exposed private key e.g. sig verification, which works over *public* keys.\n     */\n\n\n    multiplyUnsafe(n) {\n      const I = Point.ZERO;\n      if (n === _0n) return I;\n      assertGE(n); // Will throw on 0\n\n      if (n === _1n) return this;\n      const {\n        endo\n      } = CURVE;\n      if (!endo) return wnaf.unsafeLadder(this, n); // Apply endomorphism\n\n      let {\n        k1neg,\n        k1,\n        k2neg,\n        k2\n      } = endo.splitScalar(n);\n      let k1p = I;\n      let k2p = I;\n      let d = this;\n\n      while (k1 > _0n || k2 > _0n) {\n        if (k1 & _1n) k1p = k1p.add(d);\n        if (k2 & _1n) k2p = k2p.add(d);\n        d = d.double();\n        k1 >>= _1n;\n        k2 >>= _1n;\n      }\n\n      if (k1neg) k1p = k1p.negate();\n      if (k2neg) k2p = k2p.negate();\n      k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n      return k1p.add(k2p);\n    }\n    /**\n     * Constant time multiplication.\n     * Uses wNAF method. Windowed method may be 10% faster,\n     * but takes 2x longer to generate and consumes 2x memory.\n     * Uses precomputes when available.\n     * Uses endomorphism for Koblitz curves.\n     * @param scalar by which the point would be multiplied\n     * @returns New point\n     */\n\n\n    multiply(scalar) {\n      assertGE(scalar);\n      let n = scalar;\n      let point, fake; // Fake point is used to const-time mult\n\n      const {\n        endo\n      } = CURVE;\n\n      if (endo) {\n        const {\n          k1neg,\n          k1,\n          k2neg,\n          k2\n        } = endo.splitScalar(n);\n        let {\n          p: k1p,\n          f: f1p\n        } = this.wNAF(k1);\n        let {\n          p: k2p,\n          f: f2p\n        } = this.wNAF(k2);\n        k1p = wnaf.constTimeNegate(k1neg, k1p);\n        k2p = wnaf.constTimeNegate(k2neg, k2p);\n        k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n        point = k1p.add(k2p);\n        fake = f1p.add(f2p);\n      } else {\n        const {\n          p,\n          f\n        } = this.wNAF(n);\n        point = p;\n        fake = f;\n      } // Normalize `z` for both points, but return only real one\n\n\n      return Point.normalizeZ([point, fake])[0];\n    }\n    /**\n     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n     * Not using Strauss-Shamir trick: precomputation tables are faster.\n     * The trick could be useful if both P and Q are not G (not in our case).\n     * @returns non-zero affine point\n     */\n\n\n    multiplyAndAddUnsafe(Q, a, b) {\n      const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n\n      const mul = (P, a // Select faster multiply() method\n      ) => a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a);\n\n      const sum = mul(this, a).add(mul(Q, b));\n      return sum.is0() ? undefined : sum;\n    } // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (x, y, z) ∋ (x=x/z, y=y/z)\n\n\n    toAffine(iz) {\n      const {\n        px: x,\n        py: y,\n        pz: z\n      } = this;\n      const is0 = this.is0(); // If invZ was 0, we return zero point. However we still want to execute\n      // all operations, so we replace invZ with a random number, 1.\n\n      if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n      const ax = Fp.mul(x, iz);\n      const ay = Fp.mul(y, iz);\n      const zz = Fp.mul(z, iz);\n      if (is0) return {\n        x: Fp.ZERO,\n        y: Fp.ZERO\n      };\n      if (!Fp.eql(zz, Fp.ONE)) throw new Error('invZ was invalid');\n      return {\n        x: ax,\n        y: ay\n      };\n    }\n\n    isTorsionFree() {\n      const {\n        h: cofactor,\n        isTorsionFree\n      } = CURVE;\n      if (cofactor === _1n) return true; // No subgroups, always torsion-free\n\n      if (isTorsionFree) return isTorsionFree(Point, this);\n      throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n    }\n\n    clearCofactor() {\n      const {\n        h: cofactor,\n        clearCofactor\n      } = CURVE;\n      if (cofactor === _1n) return this; // Fast-path\n\n      if (clearCofactor) return clearCofactor(Point, this);\n      return this.multiplyUnsafe(CURVE.h);\n    }\n\n    toRawBytes() {\n      let isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      this.assertValidity();\n      return toBytes(Point, this, isCompressed);\n    }\n\n    toHex() {\n      let isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      return ut.bytesToHex(this.toRawBytes(isCompressed));\n    }\n\n  }\n\n  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n  Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n  const _bits = CURVE.nBitLength;\n  const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits); // Validate if generator point is on curve\n\n  return {\n    CURVE,\n    ProjectivePoint: Point,\n    normPrivateKeyToScalar,\n    weierstrassEquation,\n    isWithinCurveOrder\n  };\n}\n\nfunction validateOpts(curve) {\n  const opts = validateBasic(curve);\n  ut.validateObject(opts, {\n    hash: 'hash',\n    hmac: 'function',\n    randomBytes: 'function'\n  }, {\n    bits2int: 'function',\n    bits2int_modN: 'function',\n    lowS: 'boolean'\n  });\n  return Object.freeze({\n    lowS: true,\n    ...opts\n  });\n}\n\nexport function weierstrass(curveDef) {\n  const CURVE = validateOpts(curveDef);\n  const {\n    Fp,\n    n: CURVE_ORDER\n  } = CURVE;\n  const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n\n  const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n\n  function isValidFieldElement(num) {\n    return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n  }\n\n  function modN(a) {\n    return mod.mod(a, CURVE_ORDER);\n  }\n\n  function invN(a) {\n    return mod.invert(a, CURVE_ORDER);\n  }\n\n  const {\n    ProjectivePoint: Point,\n    normPrivateKeyToScalar,\n    weierstrassEquation,\n    isWithinCurveOrder\n  } = weierstrassPoints({ ...CURVE,\n\n    toBytes(c, point, isCompressed) {\n      const a = point.toAffine();\n      const x = Fp.toBytes(a.x);\n      const cat = ut.concatBytes;\n\n      if (isCompressed) {\n        return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n      } else {\n        return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n      }\n    },\n\n    fromBytes(bytes) {\n      const len = bytes.length;\n      const head = bytes[0];\n      const tail = bytes.subarray(1); // this.assertValidity() is done inside of fromHex\n\n      if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n        const x = ut.bytesToNumberBE(tail);\n        if (!isValidFieldElement(x)) throw new Error('Point is not on curve');\n        const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n\n        let y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n\n        const isYOdd = (y & _1n) === _1n; // ECDSA\n\n        const isHeadOdd = (head & 1) === 1;\n        if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n        return {\n          x,\n          y\n        };\n      } else if (len === uncompressedLen && head === 0x04) {\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n        return {\n          x,\n          y\n        };\n      } else {\n        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n      }\n    }\n\n  });\n\n  const numToNByteStr = num => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));\n\n  function isBiggerThanHalfOrder(number) {\n    const HALF = CURVE_ORDER >> _1n;\n    return number > HALF;\n  }\n\n  function normalizeS(s) {\n    return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n  } // slice bytes num\n\n\n  const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));\n  /**\n   * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n   */\n\n\n  class Signature {\n    constructor(r, s, recovery) {\n      this.r = r;\n      this.s = s;\n      this.recovery = recovery;\n      this.assertValidity();\n    } // pair (bytes of r, bytes of s)\n\n\n    static fromCompact(hex) {\n      const l = CURVE.nByteLength;\n      hex = ensureBytes('compactSignature', hex, l * 2);\n      return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n    } // DER encoded ECDSA signature\n    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n\n\n    static fromDER(hex) {\n      const {\n        r,\n        s\n      } = DER.toSig(ensureBytes('DER', hex));\n      return new Signature(r, s);\n    }\n\n    assertValidity() {\n      // can use assertGE here\n      if (!isWithinCurveOrder(this.r)) throw new Error('r must be 0 < r < CURVE.n');\n      if (!isWithinCurveOrder(this.s)) throw new Error('s must be 0 < s < CURVE.n');\n    }\n\n    addRecoveryBit(recovery) {\n      return new Signature(this.r, this.s, recovery);\n    }\n\n    recoverPublicKey(msgHash) {\n      const {\n        r,\n        s,\n        recovery: rec\n      } = this;\n      const h = bits2int_modN(ensureBytes('msgHash', msgHash)); // Truncate hash\n\n      if (rec == null || ![0, 1, 2, 3].includes(rec)) throw new Error('recovery id invalid');\n      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n      if (radj >= Fp.ORDER) throw new Error('recovery id 2 or 3 invalid');\n      const prefix = (rec & 1) === 0 ? '02' : '03';\n      const R = Point.fromHex(prefix + numToNByteStr(radj));\n      const ir = invN(radj); // r^-1\n\n      const u1 = modN(-h * ir); // -hr^-1\n\n      const u2 = modN(s * ir); // sr^-1\n\n      const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n\n      if (!Q) throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n\n      Q.assertValidity();\n      return Q;\n    } // Signatures should be low-s, to prevent malleability.\n\n\n    hasHighS() {\n      return isBiggerThanHalfOrder(this.s);\n    }\n\n    normalizeS() {\n      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n    } // DER-encoded\n\n\n    toDERRawBytes() {\n      return ut.hexToBytes(this.toDERHex());\n    }\n\n    toDERHex() {\n      return DER.hexFromSig({\n        r: this.r,\n        s: this.s\n      });\n    } // padded bytes of r, then padded bytes of s\n\n\n    toCompactRawBytes() {\n      return ut.hexToBytes(this.toCompactHex());\n    }\n\n    toCompactHex() {\n      return numToNByteStr(this.r) + numToNByteStr(this.s);\n    }\n\n  }\n\n  const utils = {\n    isValidPrivateKey(privateKey) {\n      try {\n        normPrivateKeyToScalar(privateKey);\n        return true;\n      } catch (error) {\n        return false;\n      }\n    },\n\n    normPrivateKeyToScalar: normPrivateKeyToScalar,\n\n    /**\n     * Produces cryptographically secure private key from random of size (nBitLength+64)\n     * as per FIPS 186 B.4.1 with modulo bias being neglible.\n     */\n    randomPrivateKey: () => {\n      const rand = CURVE.randomBytes(Fp.BYTES + 8);\n      const num = mod.hashToPrivateScalar(rand, CURVE_ORDER);\n      return ut.numberToBytesBE(num, CURVE.nByteLength);\n    },\n\n    /**\n     * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n     * Allows to massively speed-up `point.multiply(scalar)`.\n     * @returns cached point\n     * @example\n     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n     * fast.multiply(privKey); // much faster ECDH now\n     */\n    precompute() {\n      let windowSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;\n      let point = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Point.BASE;\n\n      point._setWindowSize(windowSize);\n\n      point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n\n      return point;\n    }\n\n  };\n  /**\n   * Computes public key for a private key. Checks for validity of the private key.\n   * @param privateKey private key\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns Public key, full when isCompressed=false; short when isCompressed=true\n   */\n\n  function getPublicKey(privateKey) {\n    let isCompressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n  }\n  /**\n   * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n   */\n\n\n  function isProbPub(item) {\n    const arr = item instanceof Uint8Array;\n    const str = typeof item === 'string';\n    const len = (arr || str) && item.length;\n    if (arr) return len === compressedLen || len === uncompressedLen;\n    if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;\n    if (item instanceof Point) return true;\n    return false;\n  }\n  /**\n   * ECDH (Elliptic Curve Diffie Hellman).\n   * Computes shared public key from private key and public key.\n   * Checks: 1) private key validity 2) shared key is on-curve.\n   * Does NOT hash the result.\n   * @param privateA private key\n   * @param publicB different public key\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns shared public key\n   */\n\n\n  function getSharedSecret(privateA, publicB) {\n    let isCompressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    if (isProbPub(privateA)) throw new Error('first arg must be private key');\n    if (!isProbPub(publicB)) throw new Error('second arg must be public key');\n    const b = Point.fromHex(publicB); // check for being on-curve\n\n    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n  } // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n  // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n  // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n  // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n\n\n  const bits2int = CURVE.bits2int || function (bytes) {\n    // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n    // for some cases, since bytes.length * 8 is not actual bitLength.\n    const num = ut.bytesToNumberBE(bytes); // check for == u8 done here\n\n    const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n\n    return delta > 0 ? num >> BigInt(delta) : num;\n  };\n\n  const bits2int_modN = CURVE.bits2int_modN || function (bytes) {\n    return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n  }; // NOTE: pads output with zero as per spec\n\n\n  const ORDER_MASK = ut.bitMask(CURVE.nBitLength);\n  /**\n   * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n   */\n\n  function int2octets(num) {\n    if (typeof num !== 'bigint') throw new Error('bigint expected');\n    if (!(_0n <= num && num < ORDER_MASK)) throw new Error(`bigint expected < 2^${CURVE.nBitLength}`); // works with order, can have different size than numToField!\n\n    return ut.numberToBytesBE(num, CURVE.nByteLength);\n  } // Steps A, D of RFC6979 3.2\n  // Creates RFC6979 seed; converts msg/privKey to numbers.\n  // Used only in sign, not in verify.\n  // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n  // Also it can be bigger for P224 + SHA256\n\n\n  function prepSig(msgHash, privateKey) {\n    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultSigOpts;\n    if (['recovered', 'canonical'].some(k => k in opts)) throw new Error('sign() legacy options not supported');\n    const {\n      hash,\n      randomBytes\n    } = CURVE;\n    let {\n      lowS,\n      prehash,\n      extraEntropy: ent\n    } = opts; // generates low-s sigs by default\n\n    if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n\n    msgHash = ensureBytes('msgHash', msgHash);\n    if (prehash) msgHash = ensureBytes('prehashed msgHash', hash(msgHash)); // We can't later call bits2octets, since nested bits2int is broken for curves\n    // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n    // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n\n    const h1int = bits2int_modN(msgHash);\n    const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n\n    const seedArgs = [int2octets(d), int2octets(h1int)]; // extraEntropy. RFC6979 3.6: additional k' (optional).\n\n    if (ent != null) {\n      // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n      const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n\n      seedArgs.push(ensureBytes('extraEntropy', e, Fp.BYTES)); // check for being of size BYTES\n    }\n\n    const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n\n    const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n    // Converts signature params into point w r/s, checks result for validity.\n\n    function k2sig(kBytes) {\n      // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n      const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n\n      if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\n\n      const ik = invN(k); // k^-1 mod n\n\n      const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n\n      const r = modN(q.x); // r = q.x mod n\n\n      if (r === _0n) return; // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n      // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n      // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n\n      const s = modN(ik * modN(m + r * d)); // Not using blinding here\n\n      if (s === _0n) return;\n      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n\n      let normS = s;\n\n      if (lowS && isBiggerThanHalfOrder(s)) {\n        normS = normalizeS(s); // if lowS was passed, ensure s is always\n\n        recovery ^= 1; // // in the bottom half of N\n      }\n\n      return new Signature(r, normS, recovery); // use normS, not s\n    }\n\n    return {\n      seed,\n      k2sig\n    };\n  }\n\n  const defaultSigOpts = {\n    lowS: CURVE.lowS,\n    prehash: false\n  };\n  const defaultVerOpts = {\n    lowS: CURVE.lowS,\n    prehash: false\n  };\n  /**\n   * Signs message hash with a private key.\n   * ```\n   * sign(m, d, k) where\n   *   (x, y) = G × k\n   *   r = x mod n\n   *   s = (m + dr)/k mod n\n   * ```\n   * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n   * @param privKey private key\n   * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n   * @returns signature with recovery param\n   */\n\n  function sign(msgHash, privKey) {\n    let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultSigOpts;\n    const {\n      seed,\n      k2sig\n    } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n\n    const C = CURVE;\n    const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n    return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n  } // Enable precomputes. Slows down first publicKey computation by 20ms.\n\n\n  Point.BASE._setWindowSize(8); // utils.precompute(8, ProjectivePoint.BASE)\n\n  /**\n   * Verifies a signature against message hash and public key.\n   * Rejects lowS signatures by default: to override,\n   * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n   *\n   * ```\n   * verify(r, s, h, P) where\n   *   U1 = hs^-1 mod n\n   *   U2 = rs^-1 mod n\n   *   R = U1⋅G - U2⋅P\n   *   mod(R.x, n) == r\n   * ```\n   */\n\n\n  function verify(signature, msgHash, publicKey) {\n    let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : defaultVerOpts;\n    const sg = signature;\n    msgHash = ensureBytes('msgHash', msgHash);\n    publicKey = ensureBytes('publicKey', publicKey);\n    if ('strict' in opts) throw new Error('options.strict was renamed to lowS');\n    const {\n      lowS,\n      prehash\n    } = opts;\n    let _sig = undefined;\n    let P;\n\n    try {\n      if (typeof sg === 'string' || sg instanceof Uint8Array) {\n        // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n        // Since DER can also be 2*nByteLength bytes, we check for it first.\n        try {\n          _sig = Signature.fromDER(sg);\n        } catch (derError) {\n          if (!(derError instanceof DER.Err)) throw derError;\n          _sig = Signature.fromCompact(sg);\n        }\n      } else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n        const {\n          r,\n          s\n        } = sg;\n        _sig = new Signature(r, s);\n      } else {\n        throw new Error('PARSE');\n      }\n\n      P = Point.fromHex(publicKey);\n    } catch (error) {\n      if (error.message === 'PARSE') throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n      return false;\n    }\n\n    if (lowS && _sig.hasHighS()) return false;\n    if (prehash) msgHash = CURVE.hash(msgHash);\n    const {\n      r,\n      s\n    } = _sig;\n    const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n\n    const is = invN(s); // s^-1\n\n    const u1 = modN(h * is); // u1 = hs^-1 mod n\n\n    const u2 = modN(r * is); // u2 = rs^-1 mod n\n\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n\n    if (!R) return false;\n    const v = modN(R.x);\n    return v === r;\n  }\n\n  return {\n    CURVE,\n    getPublicKey,\n    getSharedSecret,\n    sign,\n    verify,\n    ProjectivePoint: Point,\n    Signature,\n    utils\n  };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\n\nexport function SWUFpSqrtRatio(Fp, Z) {\n  // Generic implementation\n  const q = Fp.ORDER;\n  let l = _0n;\n\n  for (let o = q - _1n; o % _2n === _0n; o /= _2n) l += _1n;\n\n  const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n  // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n  // 2n ** c1 == 2n << (c1-1)\n\n  const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;\n\n  const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n\n  const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n\n  const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n\n  const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n\n  const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n\n  const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n\n  const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n\n  let sqrtRatio = (u, v) => {\n    let tv1 = c6; // 1. tv1 = c6\n\n    let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n\n    let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n\n    tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n\n    let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n\n    tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n\n    tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n\n    tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n\n    tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n\n    let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n\n    tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n\n    let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n\n    tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n\n    tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n\n    tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n\n    tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n    // 17. for i in (c1, c1 - 1, ..., 2):\n\n    for (let i = c1; i > _1n; i--) {\n      let tv5 = i - _2n; // 18.    tv5 = i - 2\n\n      tv5 = _2n << tv5 - _1n; // 19.    tv5 = 2^tv5\n\n      let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n\n      const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n\n      tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n\n      tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n\n      tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n\n      tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n\n      tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n    }\n\n    return {\n      isValid: isQR,\n      value: tv3\n    };\n  };\n\n  if (Fp.ORDER % _4n === _3n) {\n    // sqrt_ratio_3mod4(u, v)\n    const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n\n    const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n\n    sqrtRatio = (u, v) => {\n      let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n\n      const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n\n      tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n\n      let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n\n      y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n\n      const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n\n      const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n\n      const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n\n      let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n\n      return {\n        isValid: isQR,\n        value: y\n      }; // 11. return (isQR, y) isQR ? y : y*c2\n    };\n  } // No curves uses that\n  // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n\n\n  return sqrtRatio;\n}\n/**\n * From draft-irtf-cfrg-hash-to-curve-16\n */\n\nexport function mapToCurveSimpleSWU(Fp, opts) {\n  mod.validateField(Fp);\n  if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z)) throw new Error('mapToCurveSimpleSWU: invalid opts');\n  const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n  if (!Fp.isOdd) throw new Error('Fp.isOdd is not implemented!'); // Input: u, an element of F.\n  // Output: (x, y), a point on E.\n\n  return u => {\n    // prettier-ignore\n    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n    tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n\n    tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n\n    tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n\n    tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n\n    tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n\n    tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n\n    tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n\n    tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n\n    tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n\n    tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n\n    tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n\n    tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n\n    tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n\n    tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n\n    tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n\n    tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n\n    x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n\n    const {\n      isValid,\n      value\n    } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n\n    y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n\n    y = Fp.mul(y, value); // 20.   y = y * y1\n\n    x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n\n    y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n\n    const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n\n    y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n\n    x = Fp.div(x, tv4); // 25.   x = x / tv4\n\n    return {\n      x,\n      y\n    };\n  };\n}","map":{"version":3,"mappings":"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","names":["mod","ut","ensureBytes","wNAF","validateBasic","validatePointOpts","curve","opts","validateObject","a","b","allowedPrivateKeyLengths","wrapPrivateKey","isTorsionFree","clearCofactor","allowInfinityPoint","fromBytes","toBytes","endo","Fp","eql","ZERO","Error","beta","splitScalar","Object","freeze","bytesToNumberBE","b2n","hexToBytes","h2b","DER","Err","DERErr","constructor","m","_parseInt","data","E","length","len","res","subarray","d","l","toSig","hex","Uint8Array","r","sBytes","s","rBytesLeft","hexFromSig","sig","slice","Number","parseInt","h","num","toString","shl","rhl","sl","rl","_0n","BigInt","_1n","_2n","_3n","_4n","weierstrassPoints","CURVE","c","point","isCompressed","toAffine","concatBytes","from","x","y","bytes","tail","BYTES","weierstrassEquation","x2","sqr","x3","mul","add","Gy","Gx","isWithinCurveOrder","n","assertGE","normPrivateKeyToScalar","key","lengths","nByteLength","bytesToHex","includes","padStart","error","pointPrecomputes","Map","assertPrjPoint","other","Point","px","py","pz","isValid","fromAffine","p","is0","i","ONE","normalizeZ","points","toInv","invertBatch","map","fromHex","P","assertValidity","fromPrivateKey","privateKey","BASE","multiply","_setWindowSize","windowSize","_WINDOW_SIZE","delete","left","right","hasEvenY","isOdd","equals","X1","Y1","Z1","X2","Y2","Z2","U1","U2","negate","neg","double","b3","X3","Y3","Z3","t0","t1","t2","t3","sub","t4","t5","subtract","wnaf","wNAFCached","comp","multiplyUnsafe","I","unsafeLadder","k1neg","k1","k2neg","k2","k1p","k2p","scalar","fake","f","f1p","f2p","constTimeNegate","multiplyAndAddUnsafe","Q","G","sum","undefined","iz","z","inv","ax","ay","zz","cofactor","toRawBytes","toHex","_bits","nBitLength","Math","ceil","ProjectivePoint","validateOpts","hash","hmac","randomBytes","bits2int","bits2int_modN","lowS","weierstrass","curveDef","CURVE_ORDER","compressedLen","uncompressedLen","isValidFieldElement","ORDER","modN","invN","invert","cat","head","y2","sqrt","isYOdd","isHeadOdd","numToNByteStr","numberToBytesBE","isBiggerThanHalfOrder","number","HALF","normalizeS","slcNum","to","Signature","recovery","fromCompact","fromDER","addRecoveryBit","recoverPublicKey","msgHash","rec","radj","prefix","R","ir","u1","u2","hasHighS","toDERRawBytes","toDERHex","toCompactRawBytes","toCompactHex","utils","isValidPrivateKey","randomPrivateKey","rand","hashToPrivateScalar","precompute","getPublicKey","isProbPub","item","arr","str","getSharedSecret","privateA","publicB","delta","ORDER_MASK","bitMask","int2octets","prepSig","defaultSigOpts","some","k","prehash","extraEntropy","ent","h1int","seedArgs","e","push","seed","k2sig","kBytes","ik","q","normS","defaultVerOpts","sign","privKey","C","drbg","createHmacDrbg","outputLen","verify","signature","publicKey","sg","_sig","derError","message","is","v","SWUFpSqrtRatio","Z","o","c1","_2n_pow_c1_1","_2n_pow_c1","c2","c3","c4","c5","c6","pow","c7","sqrtRatio","u","tv1","tv2","tv3","tv5","tv4","isQR","cmov","tvv5","e1","value","y1","mapToCurveSimpleSWU","validateField","A","B","tv6","div"],"sources":["/home/rupam/Desktop/Faucet-React/node_modules/@noble/curves/src/abstract/weierstrass.ts"],"sourcesContent":["/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y² = x³ + ax + b\nimport * as mod from './modular.js';\nimport * as ut from './utils.js';\nimport { CHash, Hex, PrivKey, ensureBytes } from './utils.js';\nimport { Group, GroupConstructor, wNAF, BasicCurve, validateBasic, AffinePoint } from './curve.js';\n\nexport type { AffinePoint };\ntype HmacFnSync = (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array;\ntype EndomorphismOpts = {\n  beta: bigint;\n  splitScalar: (k: bigint) => { k1neg: boolean; k1: bigint; k2neg: boolean; k2: bigint };\n};\nexport type BasicWCurve<T> = BasicCurve<T> & {\n  // Params: a, b\n  a: T;\n  b: T;\n\n  // Optional params\n  allowedPrivateKeyLengths?: readonly number[]; // for P521\n  wrapPrivateKey?: boolean; // bls12-381 requires mod(n) instead of rejecting keys >= n\n  endo?: EndomorphismOpts; // Endomorphism options for Koblitz curves\n  // When a cofactor != 1, there can be an effective methods to:\n  // 1. Determine whether a point is torsion-free\n  isTorsionFree?: (c: ProjConstructor<T>, point: ProjPointType<T>) => boolean;\n  // 2. Clear torsion component\n  clearCofactor?: (c: ProjConstructor<T>, point: ProjPointType<T>) => ProjPointType<T>;\n};\n\ntype Entropy = Hex | true;\nexport type SignOpts = { lowS?: boolean; extraEntropy?: Entropy; prehash?: boolean };\nexport type VerOpts = { lowS?: boolean; prehash?: boolean };\n\n/**\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance of nominative types in TypeScript and interfaces only check for shape, so it's hard to create unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * TODO: https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n */\n\n// Instance for 3d XYZ points\nexport interface ProjPointType<T> extends Group<ProjPointType<T>> {\n  readonly px: T;\n  readonly py: T;\n  readonly pz: T;\n  get x(): T;\n  get y(): T;\n  multiply(scalar: bigint): ProjPointType<T>;\n  toAffine(iz?: T): AffinePoint<T>;\n  isTorsionFree(): boolean;\n  clearCofactor(): ProjPointType<T>;\n  assertValidity(): void;\n  hasEvenY(): boolean;\n  toRawBytes(isCompressed?: boolean): Uint8Array;\n  toHex(isCompressed?: boolean): string;\n\n  multiplyUnsafe(scalar: bigint): ProjPointType<T>;\n  multiplyAndAddUnsafe(Q: ProjPointType<T>, a: bigint, b: bigint): ProjPointType<T> | undefined;\n  _setWindowSize(windowSize: number): void;\n}\n// Static methods for 3d XYZ points\nexport interface ProjConstructor<T> extends GroupConstructor<ProjPointType<T>> {\n  new (x: T, y: T, z: T): ProjPointType<T>;\n  fromAffine(p: AffinePoint<T>): ProjPointType<T>;\n  fromHex(hex: Hex): ProjPointType<T>;\n  fromPrivateKey(privateKey: PrivKey): ProjPointType<T>;\n  normalizeZ(points: ProjPointType<T>[]): ProjPointType<T>[];\n}\n\nexport type CurvePointsType<T> = BasicWCurve<T> & {\n  // Bytes\n  fromBytes?: (bytes: Uint8Array) => AffinePoint<T>;\n  toBytes?: (c: ProjConstructor<T>, point: ProjPointType<T>, isCompressed: boolean) => Uint8Array;\n};\n\nfunction validatePointOpts<T>(curve: CurvePointsType<T>) {\n  const opts = validateBasic(curve);\n  ut.validateObject(\n    opts,\n    {\n      a: 'field',\n      b: 'field',\n    },\n    {\n      allowedPrivateKeyLengths: 'array',\n      wrapPrivateKey: 'boolean',\n      isTorsionFree: 'function',\n      clearCofactor: 'function',\n      allowInfinityPoint: 'boolean',\n      fromBytes: 'function',\n      toBytes: 'function',\n    }\n  );\n  const { endo, Fp, a } = opts;\n  if (endo) {\n    if (!Fp.eql(a, Fp.ZERO)) {\n      throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n    }\n    if (\n      typeof endo !== 'object' ||\n      typeof endo.beta !== 'bigint' ||\n      typeof endo.splitScalar !== 'function'\n    ) {\n      throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n    }\n  }\n  return Object.freeze({ ...opts } as const);\n}\n\nexport type CurvePointsRes<T> = {\n  ProjectivePoint: ProjConstructor<T>;\n  normPrivateKeyToScalar: (key: PrivKey) => bigint;\n  weierstrassEquation: (x: T) => T;\n  isWithinCurveOrder: (num: bigint) => boolean;\n};\n\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;\nexport const DER = {\n  // asn.1 DER encoding utils\n  Err: class DERErr extends Error {\n    constructor(m = '') {\n      super(m);\n    }\n  },\n  _parseInt(data: Uint8Array): { d: bigint; l: Uint8Array } {\n    const { Err: E } = DER;\n    if (data.length < 2 || data[0] !== 0x02) throw new E('Invalid signature integer tag');\n    const len = data[1];\n    const res = data.subarray(2, len + 2);\n    if (!len || res.length !== len) throw new E('Invalid signature integer: wrong length');\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    if (res[0] & 0b10000000) throw new E('Invalid signature integer: negative');\n    if (res[0] === 0x00 && !(res[1] & 0b10000000))\n      throw new E('Invalid signature integer: unnecessary leading zero');\n    return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n  },\n  toSig(hex: string | Uint8Array): { r: bigint; s: bigint } {\n    // parse DER signature\n    const { Err: E } = DER;\n    const data = typeof hex === 'string' ? h2b(hex) : hex;\n    if (!(data instanceof Uint8Array)) throw new Error('ui8a expected');\n    let l = data.length;\n    if (l < 2 || data[0] != 0x30) throw new E('Invalid signature tag');\n    if (data[1] !== l - 2) throw new E('Invalid signature: incorrect length');\n    const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n    const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n    if (rBytesLeft.length) throw new E('Invalid signature: left bytes after parsing');\n    return { r, s };\n  },\n  hexFromSig(sig: { r: bigint; s: bigint }): string {\n    // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n    const slice = (s: string): string => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n    const h = (num: number | bigint) => {\n      const hex = num.toString(16);\n      return hex.length & 1 ? `0${hex}` : hex;\n    };\n    const s = slice(h(sig.s));\n    const r = slice(h(sig.r));\n    const shl = s.length / 2;\n    const rhl = r.length / 2;\n    const sl = h(shl);\n    const rl = h(rhl);\n    return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n  },\n};\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\n\nexport function weierstrassPoints<T>(opts: CurvePointsType<T>) {\n  const CURVE = validatePointOpts(opts);\n  const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n\n  const toBytes =\n    CURVE.toBytes ||\n    ((c: ProjConstructor<T>, point: ProjPointType<T>, isCompressed: boolean) => {\n      const a = point.toAffine();\n      return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n    });\n  const fromBytes =\n    CURVE.fromBytes ||\n    ((bytes: Uint8Array) => {\n      // const head = bytes[0];\n      const tail = bytes.subarray(1);\n      // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n      const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n      const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n      return { x, y };\n    });\n\n  /**\n   * y² = x³ + ax + b: Short weierstrass curve formula\n   * @returns y²\n   */\n  function weierstrassEquation(x: T): T {\n    const { a, b } = CURVE;\n    const x2 = Fp.sqr(x); // x * x\n    const x3 = Fp.mul(x2, x); // x2 * x\n    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n  }\n  // Validate whether the passed curve params are valid.\n  // We check if curve equation works for generator point.\n  // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n  // ProjectivePoint class has not been initialized yet.\n  if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n    throw new Error('bad generator point: equation left != right');\n\n  // Valid group elements reside in range 1..n-1\n  function isWithinCurveOrder(num: bigint): boolean {\n    return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n  }\n  function assertGE(num: bigint) {\n    if (!isWithinCurveOrder(num)) throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n  }\n  // Validates if priv key is valid and converts it to bigint.\n  // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n  function normPrivateKeyToScalar(key: PrivKey): bigint {\n    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n    if (lengths && typeof key !== 'bigint') {\n      if (key instanceof Uint8Array) key = ut.bytesToHex(key);\n      // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n      if (typeof key !== 'string' || !lengths.includes(key.length)) throw new Error('Invalid key');\n      key = key.padStart(nByteLength * 2, '0');\n    }\n    let num: bigint;\n    try {\n      num =\n        typeof key === 'bigint'\n          ? key\n          : ut.bytesToNumberBE(ensureBytes('private key', key, nByteLength));\n    } catch (error) {\n      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n    }\n    if (wrapPrivateKey) num = mod.mod(num, n); // disabled by default, enabled for BLS\n    assertGE(num); // num in range [1..N-1]\n    return num;\n  }\n\n  const pointPrecomputes = new Map<Point, Point[]>();\n  function assertPrjPoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('ProjectivePoint expected');\n  }\n  /**\n   * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n   * Default Point works in 2d / affine coordinates: (x, y)\n   * We're doing calculations in projective, because its operations don't require costly inversion.\n   */\n  class Point implements ProjPointType<T> {\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    static readonly ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n\n    constructor(readonly px: T, readonly py: T, readonly pz: T) {\n      if (px == null || !Fp.isValid(px)) throw new Error('x required');\n      if (py == null || !Fp.isValid(py)) throw new Error('y required');\n      if (pz == null || !Fp.isValid(pz)) throw new Error('z required');\n    }\n\n    // Does not validate if the point is on-curve.\n    // Use fromHex instead, or call assertValidity() later.\n    static fromAffine(p: AffinePoint<T>): Point {\n      const { x, y } = p || {};\n      if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error('invalid affine point');\n      if (p instanceof Point) throw new Error('projective point not allowed');\n      const is0 = (i: T) => Fp.eql(i, Fp.ZERO);\n      // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n      if (is0(x) && is0(y)) return Point.ZERO;\n      return new Point(x, y, Fp.ONE);\n    }\n\n    get x(): T {\n      return this.toAffine().x;\n    }\n    get y(): T {\n      return this.toAffine().y;\n    }\n\n    /**\n     * Takes a bunch of Projective Points but executes only one\n     * inversion on all of them. Inversion is very slow operation,\n     * so this improves performance massively.\n     * Optimization: converts a list of projective points to a list of identical points with Z=1.\n     */\n    static normalizeZ(points: Point[]): Point[] {\n      const toInv = Fp.invertBatch(points.map((p) => p.pz));\n      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n    }\n\n    /**\n     * Converts hash string or Uint8Array to Point.\n     * @param hex short/long ECDSA hex\n     */\n    static fromHex(hex: Hex): Point {\n      const P = Point.fromAffine(fromBytes(ensureBytes('pointHex', hex)));\n      P.assertValidity();\n      return P;\n    }\n\n    // Multiplies generator point by privateKey.\n    static fromPrivateKey(privateKey: PrivKey) {\n      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n    }\n\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n    _WINDOW_SIZE?: number;\n\n    // \"Private method\", don't use it directly\n    _setWindowSize(windowSize: number) {\n      this._WINDOW_SIZE = windowSize;\n      pointPrecomputes.delete(this);\n    }\n\n    // A point on curve is valid if it conforms to equation.\n    assertValidity(): void {\n      // Zero is valid point too!\n      if (this.is0()) {\n        if (CURVE.allowInfinityPoint) return;\n        throw new Error('bad point: ZERO');\n      }\n      // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n      const { x, y } = this.toAffine();\n      // Check if x, y are valid field elements\n      if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error('bad point: x or y not FE');\n      const left = Fp.sqr(y); // y²\n      const right = weierstrassEquation(x); // x³ + ax + b\n      if (!Fp.eql(left, right)) throw new Error('bad point: equation left != right');\n      if (!this.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');\n    }\n    hasEvenY(): boolean {\n      const { y } = this.toAffine();\n      if (Fp.isOdd) return !Fp.isOdd(y);\n      throw new Error(\"Field doesn't support isOdd\");\n    }\n\n    /**\n     * Compare one point to another.\n     */\n    equals(other: Point): boolean {\n      assertPrjPoint(other);\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      const { px: X2, py: Y2, pz: Z2 } = other;\n      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n      return U1 && U2;\n    }\n\n    /**\n     * Flips point to one corresponding to (x, -y) in Affine coordinates.\n     */\n    negate(): Point {\n      return new Point(this.px, Fp.neg(this.py), this.pz);\n    }\n\n    // Renes-Costello-Batina exception-free doubling formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 3\n    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n    double() {\n      const { a, b } = CURVE;\n      const b3 = Fp.mul(b, _3n);\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n      let t0 = Fp.mul(X1, X1); // step 1\n      let t1 = Fp.mul(Y1, Y1);\n      let t2 = Fp.mul(Z1, Z1);\n      let t3 = Fp.mul(X1, Y1);\n      t3 = Fp.add(t3, t3); // step 5\n      Z3 = Fp.mul(X1, Z1);\n      Z3 = Fp.add(Z3, Z3);\n      X3 = Fp.mul(a, Z3);\n      Y3 = Fp.mul(b3, t2);\n      Y3 = Fp.add(X3, Y3); // step 10\n      X3 = Fp.sub(t1, Y3);\n      Y3 = Fp.add(t1, Y3);\n      Y3 = Fp.mul(X3, Y3);\n      X3 = Fp.mul(t3, X3);\n      Z3 = Fp.mul(b3, Z3); // step 15\n      t2 = Fp.mul(a, t2);\n      t3 = Fp.sub(t0, t2);\n      t3 = Fp.mul(a, t3);\n      t3 = Fp.add(t3, Z3);\n      Z3 = Fp.add(t0, t0); // step 20\n      t0 = Fp.add(Z3, t0);\n      t0 = Fp.add(t0, t2);\n      t0 = Fp.mul(t0, t3);\n      Y3 = Fp.add(Y3, t0);\n      t2 = Fp.mul(Y1, Z1); // step 25\n      t2 = Fp.add(t2, t2);\n      t0 = Fp.mul(t2, t3);\n      X3 = Fp.sub(X3, t0);\n      Z3 = Fp.mul(t2, t1);\n      Z3 = Fp.add(Z3, Z3); // step 30\n      Z3 = Fp.add(Z3, Z3);\n      return new Point(X3, Y3, Z3);\n    }\n\n    // Renes-Costello-Batina exception-free addition formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 1\n    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n    add(other: Point): Point {\n      assertPrjPoint(other);\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      const { px: X2, py: Y2, pz: Z2 } = other;\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n      const a = CURVE.a;\n      const b3 = Fp.mul(CURVE.b, _3n);\n      let t0 = Fp.mul(X1, X2); // step 1\n      let t1 = Fp.mul(Y1, Y2);\n      let t2 = Fp.mul(Z1, Z2);\n      let t3 = Fp.add(X1, Y1);\n      let t4 = Fp.add(X2, Y2); // step 5\n      t3 = Fp.mul(t3, t4);\n      t4 = Fp.add(t0, t1);\n      t3 = Fp.sub(t3, t4);\n      t4 = Fp.add(X1, Z1);\n      let t5 = Fp.add(X2, Z2); // step 10\n      t4 = Fp.mul(t4, t5);\n      t5 = Fp.add(t0, t2);\n      t4 = Fp.sub(t4, t5);\n      t5 = Fp.add(Y1, Z1);\n      X3 = Fp.add(Y2, Z2); // step 15\n      t5 = Fp.mul(t5, X3);\n      X3 = Fp.add(t1, t2);\n      t5 = Fp.sub(t5, X3);\n      Z3 = Fp.mul(a, t4);\n      X3 = Fp.mul(b3, t2); // step 20\n      Z3 = Fp.add(X3, Z3);\n      X3 = Fp.sub(t1, Z3);\n      Z3 = Fp.add(t1, Z3);\n      Y3 = Fp.mul(X3, Z3);\n      t1 = Fp.add(t0, t0); // step 25\n      t1 = Fp.add(t1, t0);\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.mul(b3, t4);\n      t1 = Fp.add(t1, t2);\n      t2 = Fp.sub(t0, t2); // step 30\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.add(t4, t2);\n      t0 = Fp.mul(t1, t4);\n      Y3 = Fp.add(Y3, t0);\n      t0 = Fp.mul(t5, t4); // step 35\n      X3 = Fp.mul(t3, X3);\n      X3 = Fp.sub(X3, t0);\n      t0 = Fp.mul(t3, t1);\n      Z3 = Fp.mul(t5, Z3);\n      Z3 = Fp.add(Z3, t0); // step 40\n      return new Point(X3, Y3, Z3);\n    }\n\n    subtract(other: Point) {\n      return this.add(other.negate());\n    }\n\n    private is0() {\n      return this.equals(Point.ZERO);\n    }\n    private wNAF(n: bigint): { p: Point; f: Point } {\n      return wnaf.wNAFCached(this, pointPrecomputes, n, (comp: Point[]) => {\n        const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n        return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n      });\n    }\n\n    /**\n     * Non-constant-time multiplication. Uses double-and-add algorithm.\n     * It's faster, but should only be used when you don't care about\n     * an exposed private key e.g. sig verification, which works over *public* keys.\n     */\n    multiplyUnsafe(n: bigint): Point {\n      const I = Point.ZERO;\n      if (n === _0n) return I;\n      assertGE(n); // Will throw on 0\n      if (n === _1n) return this;\n      const { endo } = CURVE;\n      if (!endo) return wnaf.unsafeLadder(this, n);\n\n      // Apply endomorphism\n      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n      let k1p = I;\n      let k2p = I;\n      let d: Point = this;\n      while (k1 > _0n || k2 > _0n) {\n        if (k1 & _1n) k1p = k1p.add(d);\n        if (k2 & _1n) k2p = k2p.add(d);\n        d = d.double();\n        k1 >>= _1n;\n        k2 >>= _1n;\n      }\n      if (k1neg) k1p = k1p.negate();\n      if (k2neg) k2p = k2p.negate();\n      k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n      return k1p.add(k2p);\n    }\n\n    /**\n     * Constant time multiplication.\n     * Uses wNAF method. Windowed method may be 10% faster,\n     * but takes 2x longer to generate and consumes 2x memory.\n     * Uses precomputes when available.\n     * Uses endomorphism for Koblitz curves.\n     * @param scalar by which the point would be multiplied\n     * @returns New point\n     */\n    multiply(scalar: bigint): Point {\n      assertGE(scalar);\n      let n = scalar;\n      let point: Point, fake: Point; // Fake point is used to const-time mult\n      const { endo } = CURVE;\n      if (endo) {\n        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n        let { p: k1p, f: f1p } = this.wNAF(k1);\n        let { p: k2p, f: f2p } = this.wNAF(k2);\n        k1p = wnaf.constTimeNegate(k1neg, k1p);\n        k2p = wnaf.constTimeNegate(k2neg, k2p);\n        k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n        point = k1p.add(k2p);\n        fake = f1p.add(f2p);\n      } else {\n        const { p, f } = this.wNAF(n);\n        point = p;\n        fake = f;\n      }\n      // Normalize `z` for both points, but return only real one\n      return Point.normalizeZ([point, fake])[0];\n    }\n\n    /**\n     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n     * Not using Strauss-Shamir trick: precomputation tables are faster.\n     * The trick could be useful if both P and Q are not G (not in our case).\n     * @returns non-zero affine point\n     */\n    multiplyAndAddUnsafe(Q: Point, a: bigint, b: bigint): Point | undefined {\n      const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n      const mul = (\n        P: Point,\n        a: bigint // Select faster multiply() method\n      ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n      const sum = mul(this, a).add(mul(Q, b));\n      return sum.is0() ? undefined : sum;\n    }\n\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (x, y, z) ∋ (x=x/z, y=y/z)\n    toAffine(iz?: T): AffinePoint<T> {\n      const { px: x, py: y, pz: z } = this;\n      const is0 = this.is0();\n      // If invZ was 0, we return zero point. However we still want to execute\n      // all operations, so we replace invZ with a random number, 1.\n      if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n      const ax = Fp.mul(x, iz);\n      const ay = Fp.mul(y, iz);\n      const zz = Fp.mul(z, iz);\n      if (is0) return { x: Fp.ZERO, y: Fp.ZERO };\n      if (!Fp.eql(zz, Fp.ONE)) throw new Error('invZ was invalid');\n      return { x: ax, y: ay };\n    }\n    isTorsionFree(): boolean {\n      const { h: cofactor, isTorsionFree } = CURVE;\n      if (cofactor === _1n) return true; // No subgroups, always torsion-free\n      if (isTorsionFree) return isTorsionFree(Point, this);\n      throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n    }\n    clearCofactor(): Point {\n      const { h: cofactor, clearCofactor } = CURVE;\n      if (cofactor === _1n) return this; // Fast-path\n      if (clearCofactor) return clearCofactor(Point, this) as Point;\n      return this.multiplyUnsafe(CURVE.h);\n    }\n\n    toRawBytes(isCompressed = true): Uint8Array {\n      this.assertValidity();\n      return toBytes(Point, this, isCompressed);\n    }\n\n    toHex(isCompressed = true): string {\n      return ut.bytesToHex(this.toRawBytes(isCompressed));\n    }\n  }\n  const _bits = CURVE.nBitLength;\n  const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n  // Validate if generator point is on curve\n  return {\n    CURVE,\n    ProjectivePoint: Point as ProjConstructor<T>,\n    normPrivateKeyToScalar,\n    weierstrassEquation,\n    isWithinCurveOrder,\n  };\n}\n\n// Instance\nexport interface SignatureType {\n  readonly r: bigint;\n  readonly s: bigint;\n  readonly recovery?: number;\n  assertValidity(): void;\n  addRecoveryBit(recovery: number): RecoveredSignatureType;\n  hasHighS(): boolean;\n  normalizeS(): SignatureType;\n  recoverPublicKey(msgHash: Hex): ProjPointType<bigint>;\n  toCompactRawBytes(): Uint8Array;\n  toCompactHex(): string;\n  // DER-encoded\n  toDERRawBytes(isCompressed?: boolean): Uint8Array;\n  toDERHex(isCompressed?: boolean): string;\n}\nexport type RecoveredSignatureType = SignatureType & {\n  readonly recovery: number;\n};\n// Static methods\nexport type SignatureConstructor = {\n  new (r: bigint, s: bigint): SignatureType;\n  fromCompact(hex: Hex): SignatureType;\n  fromDER(hex: Hex): SignatureType;\n};\ntype SignatureLike = { r: bigint; s: bigint };\n\nexport type PubKey = Hex | ProjPointType<bigint>;\n\nexport type CurveType = BasicWCurve<bigint> & {\n  hash: CHash; // CHash not FHash because we need outputLen for DRBG\n  hmac: HmacFnSync;\n  randomBytes: (bytesLength?: number) => Uint8Array;\n  lowS?: boolean;\n  bits2int?: (bytes: Uint8Array) => bigint;\n  bits2int_modN?: (bytes: Uint8Array) => bigint;\n};\n\nfunction validateOpts(curve: CurveType) {\n  const opts = validateBasic(curve);\n  ut.validateObject(\n    opts,\n    {\n      hash: 'hash',\n      hmac: 'function',\n      randomBytes: 'function',\n    },\n    {\n      bits2int: 'function',\n      bits2int_modN: 'function',\n      lowS: 'boolean',\n    }\n  );\n  return Object.freeze({ lowS: true, ...opts } as const);\n}\n\nexport type CurveFn = {\n  CURVE: ReturnType<typeof validateOpts>;\n  getPublicKey: (privateKey: PrivKey, isCompressed?: boolean) => Uint8Array;\n  getSharedSecret: (privateA: PrivKey, publicB: Hex, isCompressed?: boolean) => Uint8Array;\n  sign: (msgHash: Hex, privKey: PrivKey, opts?: SignOpts) => RecoveredSignatureType;\n  verify: (signature: Hex | SignatureLike, msgHash: Hex, publicKey: Hex, opts?: VerOpts) => boolean;\n  ProjectivePoint: ProjConstructor<bigint>;\n  Signature: SignatureConstructor;\n  utils: {\n    normPrivateKeyToScalar: (key: PrivKey) => bigint;\n    isValidPrivateKey(privateKey: PrivKey): boolean;\n    randomPrivateKey: () => Uint8Array;\n    precompute: (windowSize?: number, point?: ProjPointType<bigint>) => ProjPointType<bigint>;\n  };\n};\n\nexport function weierstrass(curveDef: CurveType): CurveFn {\n  const CURVE = validateOpts(curveDef) as ReturnType<typeof validateOpts>;\n  const { Fp, n: CURVE_ORDER } = CURVE;\n  const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n  const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n\n  function isValidFieldElement(num: bigint): boolean {\n    return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n  }\n  function modN(a: bigint) {\n    return mod.mod(a, CURVE_ORDER);\n  }\n  function invN(a: bigint) {\n    return mod.invert(a, CURVE_ORDER);\n  }\n\n  const {\n    ProjectivePoint: Point,\n    normPrivateKeyToScalar,\n    weierstrassEquation,\n    isWithinCurveOrder,\n  } = weierstrassPoints({\n    ...CURVE,\n    toBytes(c, point, isCompressed: boolean): Uint8Array {\n      const a = point.toAffine();\n      const x = Fp.toBytes(a.x);\n      const cat = ut.concatBytes;\n      if (isCompressed) {\n        return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n      } else {\n        return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n      }\n    },\n    fromBytes(bytes: Uint8Array) {\n      const len = bytes.length;\n      const head = bytes[0];\n      const tail = bytes.subarray(1);\n      // this.assertValidity() is done inside of fromHex\n      if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n        const x = ut.bytesToNumberBE(tail);\n        if (!isValidFieldElement(x)) throw new Error('Point is not on curve');\n        const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n        let y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n        const isYOdd = (y & _1n) === _1n;\n        // ECDSA\n        const isHeadOdd = (head & 1) === 1;\n        if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n        return { x, y };\n      } else if (len === uncompressedLen && head === 0x04) {\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n        return { x, y };\n      } else {\n        throw new Error(\n          `Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`\n        );\n      }\n    },\n  });\n  const numToNByteStr = (num: bigint): string =>\n    ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));\n\n  function isBiggerThanHalfOrder(number: bigint) {\n    const HALF = CURVE_ORDER >> _1n;\n    return number > HALF;\n  }\n\n  function normalizeS(s: bigint) {\n    return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n  }\n  // slice bytes num\n  const slcNum = (b: Uint8Array, from: number, to: number) => ut.bytesToNumberBE(b.slice(from, to));\n\n  /**\n   * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n   */\n  class Signature implements SignatureType {\n    constructor(readonly r: bigint, readonly s: bigint, readonly recovery?: number) {\n      this.assertValidity();\n    }\n\n    // pair (bytes of r, bytes of s)\n    static fromCompact(hex: Hex) {\n      const l = CURVE.nByteLength;\n      hex = ensureBytes('compactSignature', hex, l * 2);\n      return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n    }\n\n    // DER encoded ECDSA signature\n    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n    static fromDER(hex: Hex) {\n      const { r, s } = DER.toSig(ensureBytes('DER', hex));\n      return new Signature(r, s);\n    }\n\n    assertValidity(): void {\n      // can use assertGE here\n      if (!isWithinCurveOrder(this.r)) throw new Error('r must be 0 < r < CURVE.n');\n      if (!isWithinCurveOrder(this.s)) throw new Error('s must be 0 < s < CURVE.n');\n    }\n\n    addRecoveryBit(recovery: number): RecoveredSignature {\n      return new Signature(this.r, this.s, recovery) as RecoveredSignature;\n    }\n\n    recoverPublicKey(msgHash: Hex): typeof Point.BASE {\n      const { r, s, recovery: rec } = this;\n      const h = bits2int_modN(ensureBytes('msgHash', msgHash)); // Truncate hash\n      if (rec == null || ![0, 1, 2, 3].includes(rec)) throw new Error('recovery id invalid');\n      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n      if (radj >= Fp.ORDER) throw new Error('recovery id 2 or 3 invalid');\n      const prefix = (rec & 1) === 0 ? '02' : '03';\n      const R = Point.fromHex(prefix + numToNByteStr(radj));\n      const ir = invN(radj); // r^-1\n      const u1 = modN(-h * ir); // -hr^-1\n      const u2 = modN(s * ir); // sr^-1\n      const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n      if (!Q) throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n      Q.assertValidity();\n      return Q;\n    }\n\n    // Signatures should be low-s, to prevent malleability.\n    hasHighS(): boolean {\n      return isBiggerThanHalfOrder(this.s);\n    }\n\n    normalizeS() {\n      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n    }\n\n    // DER-encoded\n    toDERRawBytes() {\n      return ut.hexToBytes(this.toDERHex());\n    }\n    toDERHex() {\n      return DER.hexFromSig({ r: this.r, s: this.s });\n    }\n\n    // padded bytes of r, then padded bytes of s\n    toCompactRawBytes() {\n      return ut.hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n      return numToNByteStr(this.r) + numToNByteStr(this.s);\n    }\n  }\n  type RecoveredSignature = Signature & { recovery: number };\n\n  const utils = {\n    isValidPrivateKey(privateKey: PrivKey) {\n      try {\n        normPrivateKeyToScalar(privateKey);\n        return true;\n      } catch (error) {\n        return false;\n      }\n    },\n    normPrivateKeyToScalar: normPrivateKeyToScalar,\n\n    /**\n     * Produces cryptographically secure private key from random of size (nBitLength+64)\n     * as per FIPS 186 B.4.1 with modulo bias being neglible.\n     */\n    randomPrivateKey: (): Uint8Array => {\n      const rand = CURVE.randomBytes(Fp.BYTES + 8);\n      const num = mod.hashToPrivateScalar(rand, CURVE_ORDER);\n      return ut.numberToBytesBE(num, CURVE.nByteLength);\n    },\n\n    /**\n     * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n     * Allows to massively speed-up `point.multiply(scalar)`.\n     * @returns cached point\n     * @example\n     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n     * fast.multiply(privKey); // much faster ECDH now\n     */\n    precompute(windowSize = 8, point = Point.BASE): typeof Point.BASE {\n      point._setWindowSize(windowSize);\n      point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n      return point;\n    },\n  };\n\n  /**\n   * Computes public key for a private key. Checks for validity of the private key.\n   * @param privateKey private key\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns Public key, full when isCompressed=false; short when isCompressed=true\n   */\n  function getPublicKey(privateKey: PrivKey, isCompressed = true): Uint8Array {\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n  }\n\n  /**\n   * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n   */\n  function isProbPub(item: PrivKey | PubKey): boolean {\n    const arr = item instanceof Uint8Array;\n    const str = typeof item === 'string';\n    const len = (arr || str) && (item as Hex).length;\n    if (arr) return len === compressedLen || len === uncompressedLen;\n    if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;\n    if (item instanceof Point) return true;\n    return false;\n  }\n\n  /**\n   * ECDH (Elliptic Curve Diffie Hellman).\n   * Computes shared public key from private key and public key.\n   * Checks: 1) private key validity 2) shared key is on-curve.\n   * Does NOT hash the result.\n   * @param privateA private key\n   * @param publicB different public key\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns shared public key\n   */\n  function getSharedSecret(privateA: PrivKey, publicB: Hex, isCompressed = true): Uint8Array {\n    if (isProbPub(privateA)) throw new Error('first arg must be private key');\n    if (!isProbPub(publicB)) throw new Error('second arg must be public key');\n    const b = Point.fromHex(publicB); // check for being on-curve\n    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n  }\n\n  // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n  // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n  // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n  // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n  const bits2int =\n    CURVE.bits2int ||\n    function (bytes: Uint8Array): bigint {\n      // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n      // for some cases, since bytes.length * 8 is not actual bitLength.\n      const num = ut.bytesToNumberBE(bytes); // check for == u8 done here\n      const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n      return delta > 0 ? num >> BigInt(delta) : num;\n    };\n  const bits2int_modN =\n    CURVE.bits2int_modN ||\n    function (bytes: Uint8Array): bigint {\n      return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n  // NOTE: pads output with zero as per spec\n  const ORDER_MASK = ut.bitMask(CURVE.nBitLength);\n  /**\n   * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n   */\n  function int2octets(num: bigint): Uint8Array {\n    if (typeof num !== 'bigint') throw new Error('bigint expected');\n    if (!(_0n <= num && num < ORDER_MASK))\n      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n    // works with order, can have different size than numToField!\n    return ut.numberToBytesBE(num, CURVE.nByteLength);\n  }\n\n  // Steps A, D of RFC6979 3.2\n  // Creates RFC6979 seed; converts msg/privKey to numbers.\n  // Used only in sign, not in verify.\n  // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n  // Also it can be bigger for P224 + SHA256\n  function prepSig(msgHash: Hex, privateKey: PrivKey, opts = defaultSigOpts) {\n    if (['recovered', 'canonical'].some((k) => k in opts))\n      throw new Error('sign() legacy options not supported');\n    const { hash, randomBytes } = CURVE;\n    let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n    if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n    msgHash = ensureBytes('msgHash', msgHash);\n    if (prehash) msgHash = ensureBytes('prehashed msgHash', hash(msgHash));\n\n    // We can't later call bits2octets, since nested bits2int is broken for curves\n    // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n    // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n    const h1int = bits2int_modN(msgHash);\n    const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n    const seedArgs = [int2octets(d), int2octets(h1int)];\n    // extraEntropy. RFC6979 3.6: additional k' (optional).\n    if (ent != null) {\n      // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n      const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n      seedArgs.push(ensureBytes('extraEntropy', e, Fp.BYTES)); // check for being of size BYTES\n    }\n    const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n    const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n    // Converts signature params into point w r/s, checks result for validity.\n    function k2sig(kBytes: Uint8Array): RecoveredSignature | undefined {\n      // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n      const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n      if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\n      const ik = invN(k); // k^-1 mod n\n      const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n      const r = modN(q.x); // r = q.x mod n\n      if (r === _0n) return;\n      // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n      // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n      // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n      const s = modN(ik * modN(m + r * d)); // Not using blinding here\n      if (s === _0n) return;\n      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n      let normS = s;\n      if (lowS && isBiggerThanHalfOrder(s)) {\n        normS = normalizeS(s); // if lowS was passed, ensure s is always\n        recovery ^= 1; // // in the bottom half of N\n      }\n      return new Signature(r, normS, recovery) as RecoveredSignature; // use normS, not s\n    }\n    return { seed, k2sig };\n  }\n  const defaultSigOpts: SignOpts = { lowS: CURVE.lowS, prehash: false };\n  const defaultVerOpts: VerOpts = { lowS: CURVE.lowS, prehash: false };\n\n  /**\n   * Signs message hash with a private key.\n   * ```\n   * sign(m, d, k) where\n   *   (x, y) = G × k\n   *   r = x mod n\n   *   s = (m + dr)/k mod n\n   * ```\n   * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n   * @param privKey private key\n   * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n   * @returns signature with recovery param\n   */\n  function sign(msgHash: Hex, privKey: PrivKey, opts = defaultSigOpts): RecoveredSignature {\n    const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n    const C = CURVE;\n    const drbg = ut.createHmacDrbg<RecoveredSignature>(C.hash.outputLen, C.nByteLength, C.hmac);\n    return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n  }\n\n  // Enable precomputes. Slows down first publicKey computation by 20ms.\n  Point.BASE._setWindowSize(8);\n  // utils.precompute(8, ProjectivePoint.BASE)\n\n  /**\n   * Verifies a signature against message hash and public key.\n   * Rejects lowS signatures by default: to override,\n   * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n   *\n   * ```\n   * verify(r, s, h, P) where\n   *   U1 = hs^-1 mod n\n   *   U2 = rs^-1 mod n\n   *   R = U1⋅G - U2⋅P\n   *   mod(R.x, n) == r\n   * ```\n   */\n  function verify(\n    signature: Hex | SignatureLike,\n    msgHash: Hex,\n    publicKey: Hex,\n    opts = defaultVerOpts\n  ): boolean {\n    const sg = signature;\n    msgHash = ensureBytes('msgHash', msgHash);\n    publicKey = ensureBytes('publicKey', publicKey);\n    if ('strict' in opts) throw new Error('options.strict was renamed to lowS');\n    const { lowS, prehash } = opts;\n\n    let _sig: Signature | undefined = undefined;\n    let P: ProjPointType<bigint>;\n    try {\n      if (typeof sg === 'string' || sg instanceof Uint8Array) {\n        // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n        // Since DER can also be 2*nByteLength bytes, we check for it first.\n        try {\n          _sig = Signature.fromDER(sg);\n        } catch (derError) {\n          if (!(derError instanceof DER.Err)) throw derError;\n          _sig = Signature.fromCompact(sg);\n        }\n      } else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n        const { r, s } = sg;\n        _sig = new Signature(r, s);\n      } else {\n        throw new Error('PARSE');\n      }\n      P = Point.fromHex(publicKey);\n    } catch (error) {\n      if ((error as Error).message === 'PARSE')\n        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n      return false;\n    }\n    if (lowS && _sig.hasHighS()) return false;\n    if (prehash) msgHash = CURVE.hash(msgHash);\n    const { r, s } = _sig;\n    const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n    const is = invN(s); // s^-1\n    const u1 = modN(h * is); // u1 = hs^-1 mod n\n    const u2 = modN(r * is); // u2 = rs^-1 mod n\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n    if (!R) return false;\n    const v = modN(R.x);\n    return v === r;\n  }\n  return {\n    CURVE,\n    getPublicKey,\n    getSharedSecret,\n    sign,\n    verify,\n    ProjectivePoint: Point,\n    Signature,\n    utils,\n  };\n}\n\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nexport function SWUFpSqrtRatio<T>(Fp: mod.IField<T>, Z: T) {\n  // Generic implementation\n  const q = Fp.ORDER;\n  let l = _0n;\n  for (let o = q - _1n; o % _2n === _0n; o /= _2n) l += _1n;\n  const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n  // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n  // 2n ** c1 == 2n << (c1-1)\n  const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n  const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n  const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n  const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n  const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n  const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n  const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n  const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n  let sqrtRatio = (u: T, v: T): { isValid: boolean; value: T } => {\n    let tv1 = c6; // 1. tv1 = c6\n    let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n    let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n    tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n    let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n    tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n    tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n    tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n    tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n    let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n    tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n    let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n    tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n    tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n    tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n    tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n    // 17. for i in (c1, c1 - 1, ..., 2):\n    for (let i = c1; i > _1n; i--) {\n      let tv5 = i - _2n; // 18.    tv5 = i - 2\n      tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n      let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n      const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n      tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n      tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n      tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n      tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n      tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n    }\n    return { isValid: isQR, value: tv3 };\n  };\n  if (Fp.ORDER % _4n === _3n) {\n    // sqrt_ratio_3mod4(u, v)\n    const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n    const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n    sqrtRatio = (u: T, v: T) => {\n      let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n      const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n      tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n      let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n      y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n      const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n      const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n      const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n      let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n      return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n    };\n  }\n  // No curves uses that\n  // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n  return sqrtRatio;\n}\n/**\n * From draft-irtf-cfrg-hash-to-curve-16\n */\nexport function mapToCurveSimpleSWU<T>(\n  Fp: mod.IField<T>,\n  opts: {\n    A: T;\n    B: T;\n    Z: T;\n  }\n) {\n  mod.validateField(Fp);\n  if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n    throw new Error('mapToCurveSimpleSWU: invalid opts');\n  const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n  if (!Fp.isOdd) throw new Error('Fp.isOdd is not implemented!');\n  // Input: u, an element of F.\n  // Output: (x, y), a point on E.\n  return (u: T): { x: T; y: T } => {\n    // prettier-ignore\n    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n    tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n    tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n    tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n    tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n    tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n    tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n    tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n    tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n    tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n    tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n    tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n    tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n    tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n    tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n    tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n    x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n    const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n    y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n    y = Fp.mul(y, value); // 20.   y = y * y1\n    x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n    y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n    const e1 = Fp.isOdd!(u) === Fp.isOdd!(y); // 23.  e1 = sgn0(u) == sgn0(y)\n    y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n    x = Fp.div(x, tv4); // 25.   x = x / tv4\n    return { x, y };\n  };\n}\n"]},"metadata":{},"sourceType":"module"}