{"ast":null,"code":"\"use strict\";\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hexToUint8Array = exports.uint8ArrayToHexString = exports.padLeft = exports.numberToHex = exports.hexToNumber = exports.codePointToInt = exports.transformJsonDataToAbiFormat = exports.fetchArrayElement = exports.ethAbiToJsonSchema = exports.abiSchemaToJsonSchema = exports.parseBaseType = void 0;\n\nconst web3_errors_1 = require(\"web3-errors\");\n\nconst constants_js_1 = require(\"./constants.js\");\n\nconst abi_js_1 = require(\"./validation/abi.js\");\n\nconst string_js_1 = require(\"./validation/string.js\");\n\nconst errors_js_1 = require(\"./errors.js\");\n\nconst extraTypes = ['hex', 'number', 'blockNumber', 'blockNumberOrTag', 'filter', 'bloom'];\n\nconst parseBaseType = type => {\n  // Remove all empty spaces to avoid any parsing issue.\n  let strippedType = type.replace(/ /, '');\n  let baseTypeSize;\n  let isArray = false;\n  let arraySizes = [];\n\n  if (type.includes('[')) {\n    // Extract the array type\n    strippedType = strippedType.slice(0, strippedType.indexOf('[')); // Extract array indexes\n\n    arraySizes = [...type.matchAll(/(?:\\[(\\d*)\\])/g)].map(match => parseInt(match[1], 10)).map(size => Number.isNaN(size) ? -1 : size);\n    isArray = arraySizes.length > 0;\n  }\n\n  if (constants_js_1.VALID_ETH_BASE_TYPES.includes(strippedType)) {\n    return {\n      baseType: strippedType,\n      isArray,\n      baseTypeSize,\n      arraySizes\n    };\n  }\n\n  if (strippedType.startsWith('int')) {\n    baseTypeSize = parseInt(strippedType.substring(3), 10);\n    strippedType = 'int';\n  } else if (strippedType.startsWith('uint')) {\n    baseTypeSize = parseInt(type.substring(4), 10);\n    strippedType = 'uint';\n  } else if (strippedType.startsWith('bytes')) {\n    baseTypeSize = parseInt(strippedType.substring(5), 10);\n    strippedType = 'bytes';\n  } else {\n    return {\n      baseType: undefined,\n      isArray: false,\n      baseTypeSize: undefined,\n      arraySizes\n    };\n  }\n\n  return {\n    baseType: strippedType,\n    isArray,\n    baseTypeSize,\n    arraySizes\n  };\n};\n\nexports.parseBaseType = parseBaseType;\n\nconst convertEthType = function (type) {\n  let parentSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const typePropertyPresent = Object.keys(parentSchema).includes('type');\n\n  if (typePropertyPresent) {\n    throw new errors_js_1.Web3ValidatorError([{\n      keyword: 'eth',\n      message: 'Either \"eth\" or \"type\" can be presented in schema',\n      params: {\n        eth: type\n      },\n      instancePath: '',\n      schemaPath: ''\n    }]);\n  }\n\n  const {\n    baseType,\n    baseTypeSize\n  } = (0, exports.parseBaseType)(type);\n\n  if (!baseType && !extraTypes.includes(type)) {\n    throw new errors_js_1.Web3ValidatorError([{\n      keyword: 'eth',\n      message: `Eth data type \"${type}\" is not valid`,\n      params: {\n        eth: type\n      },\n      instancePath: '',\n      schemaPath: ''\n    }]);\n  }\n\n  if (baseType) {\n    if (baseType === 'tuple') {\n      throw new Error('\"tuple\" type is not implemented directly.');\n    }\n\n    return {\n      format: `${baseType}${baseTypeSize !== null && baseTypeSize !== void 0 ? baseTypeSize : ''}`,\n      required: true\n    };\n  }\n\n  if (type) {\n    return {\n      format: type,\n      required: true\n    };\n  }\n\n  return {};\n};\n\nconst abiSchemaToJsonSchema = function (abis) {\n  let level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '/0';\n  const schema = {\n    type: 'array',\n    items: [],\n    maxItems: abis.length,\n    minItems: abis.length\n  };\n\n  for (const [index, abi] of abis.entries()) {\n    // eslint-disable-next-line no-nested-ternary\n    let abiType;\n    let abiName;\n    let abiComponents = []; // If it's a complete Abi Parameter\n    // e.g. {name: 'a', type: 'uint'}\n\n    if ((0, abi_js_1.isAbiParameterSchema)(abi)) {\n      abiType = abi.type;\n      abiName = abi.name;\n      abiComponents = abi.components; // If its short form string value e.g. ['uint']\n    } else if (typeof abi === 'string') {\n      abiType = abi;\n      abiName = `${level}/${index}`; // If it's provided in short form of tuple e.g. [['uint', 'string']]\n    } else if (Array.isArray(abi)) {\n      // If its custom tuple e.g. ['tuple[2]', ['uint', 'string']]\n      if (abi[0] && typeof abi[0] === 'string' && abi[0].startsWith('tuple') && !Array.isArray(abi[0]) && abi[1] && Array.isArray(abi[1])) {\n        // eslint-disable-next-line prefer-destructuring\n        abiType = abi[0];\n        abiName = `${level}/${index}`;\n        abiComponents = abi[1];\n      } else {\n        abiType = 'tuple';\n        abiName = `${level}/${index}`;\n        abiComponents = abi;\n      }\n    }\n\n    const {\n      baseType,\n      isArray,\n      arraySizes\n    } = (0, exports.parseBaseType)(abiType);\n    let childSchema;\n    let lastSchema = schema;\n\n    for (let i = arraySizes.length - 1; i > 0; i -= 1) {\n      childSchema = {\n        type: 'array',\n        items: [],\n        maxItems: arraySizes[i],\n        minItems: arraySizes[i]\n      };\n\n      if (arraySizes[i] < 0) {\n        delete childSchema.maxItems;\n        delete childSchema.minItems;\n      } // lastSchema.items is a Schema, concat with 'childSchema'\n\n\n      if (!Array.isArray(lastSchema.items)) {\n        lastSchema.items = [lastSchema.items, childSchema];\n      } // lastSchema.items is an empty Scheme array, set it to 'childSchema'\n      else if (lastSchema.items.length === 0) {\n        lastSchema.items = childSchema;\n      } // lastSchema.items is a non-empty Scheme array, append 'childSchema'\n      else {\n        lastSchema.items.push(childSchema);\n      }\n\n      lastSchema = childSchema;\n    }\n\n    if (baseType === 'tuple' && !isArray) {\n      const nestedTuple = (0, exports.abiSchemaToJsonSchema)(abiComponents, abiName);\n      nestedTuple.$id = abiName;\n      lastSchema.items.push(nestedTuple);\n    } else if (baseType === 'tuple' && isArray) {\n      const arraySize = arraySizes[0];\n      const item = {\n        $id: abiName,\n        type: 'array',\n        items: (0, exports.abiSchemaToJsonSchema)(abiComponents, abiName),\n        maxItems: arraySize,\n        minItems: arraySize\n      };\n\n      if (arraySize < 0) {\n        delete item.maxItems;\n        delete item.minItems;\n      }\n\n      lastSchema.items.push(item);\n    } else if (isArray) {\n      const arraySize = arraySizes[0];\n      const item = {\n        type: 'array',\n        $id: abiName,\n        items: convertEthType(String(baseType)),\n        minItems: arraySize,\n        maxItems: arraySize\n      };\n\n      if (arraySize < 0) {\n        delete item.maxItems;\n        delete item.minItems;\n      }\n\n      lastSchema.items.push(item);\n    } else if (Array.isArray(lastSchema.items)) {\n      // Array of non-tuple items\n      lastSchema.items.push(Object.assign({\n        $id: abiName\n      }, convertEthType(abiType)));\n    } else {\n      // Nested object\n      lastSchema.items.items.push(Object.assign({\n        $id: abiName\n      }, convertEthType(abiType)));\n    }\n\n    lastSchema = schema;\n  }\n\n  return schema;\n};\n\nexports.abiSchemaToJsonSchema = abiSchemaToJsonSchema;\n\nconst ethAbiToJsonSchema = abis => (0, exports.abiSchemaToJsonSchema)(abis);\n\nexports.ethAbiToJsonSchema = ethAbiToJsonSchema;\n\nconst fetchArrayElement = (data, level) => {\n  if (level === 1) {\n    return data;\n  }\n\n  return (0, exports.fetchArrayElement)(data[0], level - 1);\n};\n\nexports.fetchArrayElement = fetchArrayElement;\n\nconst transformJsonDataToAbiFormat = (abis, data, transformedData) => {\n  const newData = [];\n\n  for (const [index, abi] of abis.entries()) {\n    // eslint-disable-next-line no-nested-ternary\n    let abiType;\n    let abiName;\n    let abiComponents = []; // If it's a complete Abi Parameter\n    // e.g. {name: 'a', type: 'uint'}\n\n    if ((0, abi_js_1.isAbiParameterSchema)(abi)) {\n      abiType = abi.type;\n      abiName = abi.name;\n      abiComponents = abi.components; // If its short form string value e.g. ['uint']\n    } else if (typeof abi === 'string') {\n      abiType = abi; // If it's provided in short form of tuple e.g. [['uint', 'string']]\n    } else if (Array.isArray(abi)) {\n      // If its custom tuple e.g. ['tuple[2]', ['uint', 'string']]\n      if (abi[1] && Array.isArray(abi[1])) {\n        abiType = abi[0];\n        abiComponents = abi[1];\n      } else {\n        abiType = 'tuple';\n        abiComponents = abi;\n      }\n    }\n\n    const {\n      baseType,\n      isArray,\n      arraySizes\n    } = (0, exports.parseBaseType)(abiType);\n    const dataItem = Array.isArray(data) ? data[index] : data[abiName];\n\n    if (baseType === 'tuple' && !isArray) {\n      newData.push((0, exports.transformJsonDataToAbiFormat)(abiComponents, dataItem, transformedData));\n    } else if (baseType === 'tuple' && isArray) {\n      const tupleData = [];\n\n      for (const tupleItem of dataItem) {\n        // Nested array\n        if (arraySizes.length > 1) {\n          const nestedItems = (0, exports.fetchArrayElement)(tupleItem, arraySizes.length - 1);\n          const nestedData = [];\n\n          for (const nestedItem of nestedItems) {\n            nestedData.push((0, exports.transformJsonDataToAbiFormat)(abiComponents, nestedItem, transformedData));\n          }\n\n          tupleData.push(nestedData);\n        } else {\n          tupleData.push((0, exports.transformJsonDataToAbiFormat)(abiComponents, tupleItem, transformedData));\n        }\n      }\n\n      newData.push(tupleData);\n    } else {\n      newData.push(dataItem);\n    }\n  } // Have to reassign before pushing to transformedData\n  // eslint-disable-next-line no-param-reassign\n\n\n  transformedData = transformedData !== null && transformedData !== void 0 ? transformedData : [];\n  transformedData.push(...newData);\n  return transformedData;\n};\n\nexports.transformJsonDataToAbiFormat = transformJsonDataToAbiFormat;\n/**\n * Code points to int\n */\n\nconst codePointToInt = codePoint => {\n  if (codePoint >= 48 && codePoint <= 57) {\n    /* ['0'..'9'] -> [0..9] */\n    return codePoint - 48;\n  }\n\n  if (codePoint >= 65 && codePoint <= 70) {\n    /* ['A'..'F'] -> [10..15] */\n    return codePoint - 55;\n  }\n\n  if (codePoint >= 97 && codePoint <= 102) {\n    /* ['a'..'f'] -> [10..15] */\n    return codePoint - 87;\n  }\n\n  throw new Error(`Invalid code point: ${codePoint}`);\n};\n\nexports.codePointToInt = codePointToInt;\n/**\n * Converts value to it's number representation\n */\n\nconst hexToNumber = value => {\n  if (!(0, string_js_1.isHexStrict)(value)) {\n    throw new Error('Invalid hex string');\n  }\n\n  const [negative, hexValue] = value.startsWith('-') ? [true, value.slice(1)] : [false, value];\n  const num = BigInt(hexValue);\n\n  if (num > Number.MAX_SAFE_INTEGER) {\n    return negative ? -num : num;\n  }\n\n  if (num < Number.MIN_SAFE_INTEGER) {\n    return num;\n  }\n\n  return negative ? -1 * Number(num) : Number(num);\n};\n\nexports.hexToNumber = hexToNumber;\n/**\n * Converts value to it's hex representation\n */\n\nconst numberToHex = value => {\n  if ((typeof value === 'number' || typeof value === 'bigint') && value < 0) {\n    return `-0x${value.toString(16).slice(1)}`;\n  }\n\n  if ((typeof value === 'number' || typeof value === 'bigint') && value >= 0) {\n    return `0x${value.toString(16)}`;\n  }\n\n  if (typeof value === 'string' && (0, string_js_1.isHexStrict)(value)) {\n    const [negative, hex] = value.startsWith('-') ? [true, value.slice(1)] : [false, value];\n    const hexValue = hex.split(/^(-)?0(x|X)/).slice(-1)[0];\n    return `${negative ? '-' : ''}0x${hexValue.replace(/^0+/, '').toLowerCase()}`;\n  }\n\n  if (typeof value === 'string' && !(0, string_js_1.isHexStrict)(value)) {\n    return (0, exports.numberToHex)(BigInt(value));\n  }\n\n  throw new web3_errors_1.InvalidNumberError(value);\n};\n\nexports.numberToHex = numberToHex;\n/**\n * Adds a padding on the left of a string, if value is a integer or bigInt will be converted to a hex string.\n */\n\nconst padLeft = function (value, characterAmount) {\n  let sign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '0';\n\n  if (typeof value === 'string' && !(0, string_js_1.isHexStrict)(value)) {\n    return value.padStart(characterAmount, sign);\n  }\n\n  const hex = typeof value === 'string' && (0, string_js_1.isHexStrict)(value) ? value : (0, exports.numberToHex)(value);\n  const [prefix, hexValue] = hex.startsWith('-') ? ['-0x', hex.slice(3)] : ['0x', hex.slice(2)];\n  return `${prefix}${hexValue.padStart(characterAmount, sign)}`;\n};\n\nexports.padLeft = padLeft;\n\nfunction uint8ArrayToHexString(uint8Array) {\n  let hexString = '0x';\n\n  for (const e of uint8Array) {\n    const hex = e.toString(16);\n    hexString += hex.length === 1 ? `0${hex}` : hex;\n  }\n\n  return hexString;\n}\n\nexports.uint8ArrayToHexString = uint8ArrayToHexString;\n\nfunction hexToUint8Array(hex) {\n  let value;\n\n  if (hex.toLowerCase().startsWith('0x')) {\n    value = hex.slice(2);\n  } else {\n    value = hex;\n  }\n\n  if (value.length % 2 !== 0) {\n    throw new web3_errors_1.InvalidBytesError(`hex string has odd length: ${hex}`);\n  }\n\n  const bytes = new Uint8Array(Math.ceil(value.length / 2));\n\n  for (let i = 0; i < bytes.length; i += 1) {\n    const byte = parseInt(value.substring(i * 2, i * 2 + 2), 16);\n    bytes[i] = byte;\n  }\n\n  return bytes;\n}\n\nexports.hexToUint8Array = hexToUint8Array;","map":{"version":3,"mappings":"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","names":["extraTypes","parseBaseType","type","strippedType","replace","baseTypeSize","isArray","arraySizes","includes","slice","indexOf","matchAll","map","match","parseInt","size","Number","isNaN","length","constants_js_1","baseType","startsWith","substring","undefined","exports","convertEthType","parentSchema","typePropertyPresent","Object","keys","errors_js_1","keyword","message","params","eth","instancePath","schemaPath","Error","format","required","abiSchemaToJsonSchema","abis","level","schema","items","maxItems","minItems","index","abi","entries","abiType","abiName","abiComponents","name","components","Array","childSchema","lastSchema","i","push","nestedTuple","$id","arraySize","item","String","ethAbiToJsonSchema","fetchArrayElement","data","transformJsonDataToAbiFormat","transformedData","newData","dataItem","tupleData","tupleItem","nestedItems","nestedData","nestedItem","codePointToInt","codePoint","hexToNumber","value","negative","hexValue","num","BigInt","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","numberToHex","toString","hex","split","toLowerCase","web3_errors_1","padLeft","characterAmount","sign","padStart","prefix","uint8ArrayToHexString","uint8Array","hexString","e","hexToUint8Array","bytes","Uint8Array","Math","ceil","byte"],"sources":["/home/rupam/Desktop/Faucet-React/node_modules/web3-validator/src/utils.ts"],"sourcesContent":["﻿/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport { InvalidBytesError, InvalidNumberError } from 'web3-errors';\nimport { VALID_ETH_BASE_TYPES } from './constants.js';\nimport {\n\tFullValidationSchema,\n\tJsonSchema,\n\tShortValidationSchema,\n\tValidationSchemaInput,\n\tValidInputTypes,\n} from './types.js';\nimport { isAbiParameterSchema } from './validation/abi.js';\nimport { isHexStrict } from './validation/string.js';\nimport { Web3ValidatorError } from './errors.js';\n\nconst extraTypes = ['hex', 'number', 'blockNumber', 'blockNumberOrTag', 'filter', 'bloom'];\n\nexport const parseBaseType = <T = typeof VALID_ETH_BASE_TYPES[number]>(\n\ttype: string,\n): {\n\tbaseType?: T;\n\tbaseTypeSize: number | undefined;\n\tarraySizes: number[];\n\tisArray: boolean;\n} => {\n\t// Remove all empty spaces to avoid any parsing issue.\n\tlet strippedType = type.replace(/ /, '');\n\tlet baseTypeSize: number | undefined;\n\tlet isArray = false;\n\tlet arraySizes: number[] = [];\n\n\tif (type.includes('[')) {\n\t\t// Extract the array type\n\t\tstrippedType = strippedType.slice(0, strippedType.indexOf('['));\n\t\t// Extract array indexes\n\t\tarraySizes = [...type.matchAll(/(?:\\[(\\d*)\\])/g)]\n\t\t\t.map(match => parseInt(match[1], 10))\n\t\t\t.map(size => (Number.isNaN(size) ? -1 : size));\n\n\t\tisArray = arraySizes.length > 0;\n\t}\n\n\tif (VALID_ETH_BASE_TYPES.includes(strippedType)) {\n\t\treturn { baseType: strippedType as unknown as T, isArray, baseTypeSize, arraySizes };\n\t}\n\n\tif (strippedType.startsWith('int')) {\n\t\tbaseTypeSize = parseInt(strippedType.substring(3), 10);\n\t\tstrippedType = 'int';\n\t} else if (strippedType.startsWith('uint')) {\n\t\tbaseTypeSize = parseInt(type.substring(4), 10);\n\t\tstrippedType = 'uint';\n\t} else if (strippedType.startsWith('bytes')) {\n\t\tbaseTypeSize = parseInt(strippedType.substring(5), 10);\n\t\tstrippedType = 'bytes';\n\t} else {\n\t\treturn { baseType: undefined, isArray: false, baseTypeSize: undefined, arraySizes };\n\t}\n\n\treturn { baseType: strippedType as unknown as T, isArray, baseTypeSize, arraySizes };\n};\n\nconst convertEthType = (\n\ttype: string,\n\tparentSchema: JsonSchema = {},\n): { format?: string; required?: boolean } => {\n\tconst typePropertyPresent = Object.keys(parentSchema).includes('type');\n\n\tif (typePropertyPresent) {\n\t\tthrow new Web3ValidatorError([\n\t\t\t{\n\t\t\t\tkeyword: 'eth',\n\t\t\t\tmessage: 'Either \"eth\" or \"type\" can be presented in schema',\n\t\t\t\tparams: { eth: type },\n\t\t\t\tinstancePath: '',\n\t\t\t\tschemaPath: '',\n\t\t\t},\n\t\t]);\n\t}\n\n\tconst { baseType, baseTypeSize } = parseBaseType(type);\n\n\tif (!baseType && !extraTypes.includes(type)) {\n\t\tthrow new Web3ValidatorError([\n\t\t\t{\n\t\t\t\tkeyword: 'eth',\n\t\t\t\tmessage: `Eth data type \"${type}\" is not valid`,\n\t\t\t\tparams: { eth: type },\n\t\t\t\tinstancePath: '',\n\t\t\t\tschemaPath: '',\n\t\t\t},\n\t\t]);\n\t}\n\n\tif (baseType) {\n\t\tif (baseType === 'tuple') {\n\t\t\tthrow new Error('\"tuple\" type is not implemented directly.');\n\t\t}\n\t\treturn { format: `${baseType}${baseTypeSize ?? ''}`, required: true };\n\t}\n\tif (type) {\n\t\treturn { format: type, required: true };\n\t}\n\n\treturn {};\n};\n\nexport const abiSchemaToJsonSchema = (\n\tabis: ShortValidationSchema | FullValidationSchema,\n\tlevel = '/0',\n) => {\n\tconst schema: JsonSchema = {\n\t\ttype: 'array',\n\t\titems: [],\n\t\tmaxItems: abis.length,\n\t\tminItems: abis.length,\n\t};\n\n\tfor (const [index, abi] of abis.entries()) {\n\t\t// eslint-disable-next-line no-nested-ternary\n\t\tlet abiType!: string;\n\t\tlet abiName!: string;\n\t\tlet abiComponents: ShortValidationSchema | FullValidationSchema | undefined = [];\n\n\t\t// If it's a complete Abi Parameter\n\t\t// e.g. {name: 'a', type: 'uint'}\n\t\tif (isAbiParameterSchema(abi)) {\n\t\t\tabiType = abi.type;\n\t\t\tabiName = abi.name;\n\t\t\tabiComponents = abi.components as FullValidationSchema;\n\t\t\t// If its short form string value e.g. ['uint']\n\t\t} else if (typeof abi === 'string') {\n\t\t\tabiType = abi;\n\t\t\tabiName = `${level}/${index}`;\n\n\t\t\t// If it's provided in short form of tuple e.g. [['uint', 'string']]\n\t\t} else if (Array.isArray(abi)) {\n\t\t\t// If its custom tuple e.g. ['tuple[2]', ['uint', 'string']]\n\t\t\tif (\n\t\t\t\tabi[0] &&\n\t\t\t\ttypeof abi[0] === 'string' &&\n\t\t\t\tabi[0].startsWith('tuple') &&\n\t\t\t\t!Array.isArray(abi[0]) &&\n\t\t\t\tabi[1] &&\n\t\t\t\tArray.isArray(abi[1])\n\t\t\t) {\n\t\t\t\t// eslint-disable-next-line prefer-destructuring\n\t\t\t\tabiType = abi[0];\n\t\t\t\tabiName = `${level}/${index}`;\n\t\t\t\tabiComponents = abi[1] as ReadonlyArray<ShortValidationSchema>;\n\t\t\t} else {\n\t\t\t\tabiType = 'tuple';\n\t\t\t\tabiName = `${level}/${index}`;\n\t\t\t\tabiComponents = abi;\n\t\t\t}\n\t\t}\n\n\t\tconst { baseType, isArray, arraySizes } = parseBaseType(abiType);\n\n\t\tlet childSchema: JsonSchema;\n\t\tlet lastSchema = schema;\n\t\tfor (let i = arraySizes.length - 1; i > 0; i -= 1) {\n\t\t\tchildSchema = {\n\t\t\t\ttype: 'array',\n\t\t\t\titems: [],\n\t\t\t\tmaxItems: arraySizes[i],\n\t\t\t\tminItems: arraySizes[i],\n\t\t\t};\n\n\t\t\tif (arraySizes[i] < 0) {\n\t\t\t\tdelete childSchema.maxItems;\n\t\t\t\tdelete childSchema.minItems;\n\t\t\t}\n\n\t\t\t// lastSchema.items is a Schema, concat with 'childSchema'\n\t\t\tif (!Array.isArray(lastSchema.items)) {\n\t\t\t\tlastSchema.items = [lastSchema.items as JsonSchema, childSchema];\n\t\t\t} // lastSchema.items is an empty Scheme array, set it to 'childSchema'\n\t\t\telse if (lastSchema.items.length === 0) {\n\t\t\t\tlastSchema.items = childSchema;\n\t\t\t} // lastSchema.items is a non-empty Scheme array, append 'childSchema'\n\t\t\telse {\n\t\t\t\tlastSchema.items.push(childSchema);\n\t\t\t}\n\t\t\tlastSchema = childSchema;\n\t\t}\n\n\t\tif (baseType === 'tuple' && !isArray) {\n\t\t\tconst nestedTuple = abiSchemaToJsonSchema(abiComponents, abiName);\n\t\t\tnestedTuple.$id = abiName;\n\t\t\t(lastSchema.items as JsonSchema[]).push(nestedTuple);\n\t\t} else if (baseType === 'tuple' && isArray) {\n\t\t\tconst arraySize = arraySizes[0];\n\t\t\tconst item: JsonSchema = {\n\t\t\t\t$id: abiName,\n\t\t\t\ttype: 'array',\n\t\t\t\titems: abiSchemaToJsonSchema(abiComponents, abiName),\n\t\t\t\tmaxItems: arraySize,\n\t\t\t\tminItems: arraySize,\n\t\t\t};\n\n\t\t\tif (arraySize < 0) {\n\t\t\t\tdelete item.maxItems;\n\t\t\t\tdelete item.minItems;\n\t\t\t}\n\n\t\t\t(lastSchema.items as JsonSchema[]).push(item);\n\t\t} else if (isArray) {\n\t\t\tconst arraySize = arraySizes[0];\n\t\t\tconst item: JsonSchema = {\n\t\t\t\ttype: 'array',\n\t\t\t\t$id: abiName,\n\t\t\t\titems: convertEthType(String(baseType)),\n\t\t\t\tminItems: arraySize,\n\t\t\t\tmaxItems: arraySize,\n\t\t\t};\n\n\t\t\tif (arraySize < 0) {\n\t\t\t\tdelete item.maxItems;\n\t\t\t\tdelete item.minItems;\n\t\t\t}\n\n\t\t\t(lastSchema.items as JsonSchema[]).push(item);\n\t\t} else if (Array.isArray(lastSchema.items)) {\n\t\t\t// Array of non-tuple items\n\t\t\tlastSchema.items.push({ $id: abiName, ...convertEthType(abiType) });\n\t\t} else {\n\t\t\t// Nested object\n\t\t\t((lastSchema.items as JsonSchema).items as JsonSchema[]).push({\n\t\t\t\t$id: abiName,\n\t\t\t\t...convertEthType(abiType),\n\t\t\t});\n\t\t}\n\t\tlastSchema = schema;\n\t}\n\n\treturn schema;\n};\n\nexport const ethAbiToJsonSchema = (abis: ValidationSchemaInput) => abiSchemaToJsonSchema(abis);\n\nexport const fetchArrayElement = (data: Array<unknown>, level: number): unknown => {\n\tif (level === 1) {\n\t\treturn data;\n\t}\n\n\treturn fetchArrayElement(data[0] as Array<unknown>, level - 1);\n};\n\nexport const transformJsonDataToAbiFormat = (\n\tabis: FullValidationSchema,\n\tdata: ReadonlyArray<unknown> | Record<string, unknown>,\n\ttransformedData?: Array<unknown>,\n): Array<unknown> => {\n\tconst newData: Array<unknown> = [];\n\n\tfor (const [index, abi] of abis.entries()) {\n\t\t// eslint-disable-next-line no-nested-ternary\n\t\tlet abiType!: string;\n\t\tlet abiName!: string;\n\t\tlet abiComponents: ShortValidationSchema | FullValidationSchema | undefined = [];\n\n\t\t// If it's a complete Abi Parameter\n\t\t// e.g. {name: 'a', type: 'uint'}\n\t\tif (isAbiParameterSchema(abi)) {\n\t\t\tabiType = abi.type;\n\t\t\tabiName = abi.name;\n\t\t\tabiComponents = abi.components as FullValidationSchema;\n\t\t\t// If its short form string value e.g. ['uint']\n\t\t} else if (typeof abi === 'string') {\n\t\t\tabiType = abi;\n\n\t\t\t// If it's provided in short form of tuple e.g. [['uint', 'string']]\n\t\t} else if (Array.isArray(abi)) {\n\t\t\t// If its custom tuple e.g. ['tuple[2]', ['uint', 'string']]\n\t\t\tif (abi[1] && Array.isArray(abi[1])) {\n\t\t\t\tabiType = abi[0] as string;\n\t\t\t\tabiComponents = abi[1] as ReadonlyArray<ShortValidationSchema>;\n\t\t\t} else {\n\t\t\t\tabiType = 'tuple';\n\t\t\t\tabiComponents = abi;\n\t\t\t}\n\t\t}\n\n\t\tconst { baseType, isArray, arraySizes } = parseBaseType(abiType);\n\t\tconst dataItem = Array.isArray(data)\n\t\t\t? (data as Array<unknown>)[index]\n\t\t\t: (data as Record<string, unknown>)[abiName];\n\n\t\tif (baseType === 'tuple' && !isArray) {\n\t\t\tnewData.push(\n\t\t\t\ttransformJsonDataToAbiFormat(\n\t\t\t\t\tabiComponents as FullValidationSchema,\n\t\t\t\t\tdataItem as Array<unknown>,\n\t\t\t\t\ttransformedData,\n\t\t\t\t),\n\t\t\t);\n\t\t} else if (baseType === 'tuple' && isArray) {\n\t\t\tconst tupleData = [];\n\t\t\tfor (const tupleItem of dataItem as Array<unknown>) {\n\t\t\t\t// Nested array\n\t\t\t\tif (arraySizes.length > 1) {\n\t\t\t\t\tconst nestedItems = fetchArrayElement(\n\t\t\t\t\t\ttupleItem as Array<unknown>,\n\t\t\t\t\t\tarraySizes.length - 1,\n\t\t\t\t\t);\n\t\t\t\t\tconst nestedData = [];\n\n\t\t\t\t\tfor (const nestedItem of nestedItems as Array<unknown>) {\n\t\t\t\t\t\tnestedData.push(\n\t\t\t\t\t\t\ttransformJsonDataToAbiFormat(\n\t\t\t\t\t\t\t\tabiComponents as FullValidationSchema,\n\t\t\t\t\t\t\t\tnestedItem as Array<unknown>,\n\t\t\t\t\t\t\t\ttransformedData,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\ttupleData.push(nestedData);\n\t\t\t\t} else {\n\t\t\t\t\ttupleData.push(\n\t\t\t\t\t\ttransformJsonDataToAbiFormat(\n\t\t\t\t\t\t\tabiComponents as FullValidationSchema,\n\t\t\t\t\t\t\ttupleItem as Array<unknown>,\n\t\t\t\t\t\t\ttransformedData,\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tnewData.push(tupleData);\n\t\t} else {\n\t\t\tnewData.push(dataItem);\n\t\t}\n\t}\n\n\t// Have to reassign before pushing to transformedData\n\t// eslint-disable-next-line no-param-reassign\n\ttransformedData = transformedData ?? [];\n\ttransformedData.push(...newData);\n\n\treturn transformedData;\n};\n\n/**\n * Code points to int\n */\n\nexport const codePointToInt = (codePoint: number): number => {\n\tif (codePoint >= 48 && codePoint <= 57) {\n\t\t/* ['0'..'9'] -> [0..9] */\n\t\treturn codePoint - 48;\n\t}\n\n\tif (codePoint >= 65 && codePoint <= 70) {\n\t\t/* ['A'..'F'] -> [10..15] */\n\t\treturn codePoint - 55;\n\t}\n\n\tif (codePoint >= 97 && codePoint <= 102) {\n\t\t/* ['a'..'f'] -> [10..15] */\n\t\treturn codePoint - 87;\n\t}\n\n\tthrow new Error(`Invalid code point: ${codePoint}`);\n};\n\n/**\n * Converts value to it's number representation\n */\nexport const hexToNumber = (value: string): bigint | number => {\n\tif (!isHexStrict(value)) {\n\t\tthrow new Error('Invalid hex string');\n\t}\n\n\tconst [negative, hexValue] = value.startsWith('-') ? [true, value.slice(1)] : [false, value];\n\tconst num = BigInt(hexValue);\n\n\tif (num > Number.MAX_SAFE_INTEGER) {\n\t\treturn negative ? -num : num;\n\t}\n\n\tif (num < Number.MIN_SAFE_INTEGER) {\n\t\treturn num;\n\t}\n\n\treturn negative ? -1 * Number(num) : Number(num);\n};\n\n/**\n * Converts value to it's hex representation\n */\nexport const numberToHex = (value: ValidInputTypes): string => {\n\tif ((typeof value === 'number' || typeof value === 'bigint') && value < 0) {\n\t\treturn `-0x${value.toString(16).slice(1)}`;\n\t}\n\n\tif ((typeof value === 'number' || typeof value === 'bigint') && value >= 0) {\n\t\treturn `0x${value.toString(16)}`;\n\t}\n\n\tif (typeof value === 'string' && isHexStrict(value)) {\n\t\tconst [negative, hex] = value.startsWith('-') ? [true, value.slice(1)] : [false, value];\n\t\tconst hexValue = hex.split(/^(-)?0(x|X)/).slice(-1)[0];\n\t\treturn `${negative ? '-' : ''}0x${hexValue.replace(/^0+/, '').toLowerCase()}`;\n\t}\n\n\tif (typeof value === 'string' && !isHexStrict(value)) {\n\t\treturn numberToHex(BigInt(value));\n\t}\n\n\tthrow new InvalidNumberError(value);\n};\n\n/**\n * Adds a padding on the left of a string, if value is a integer or bigInt will be converted to a hex string.\n */\nexport const padLeft = (value: ValidInputTypes, characterAmount: number, sign = '0'): string => {\n\tif (typeof value === 'string' && !isHexStrict(value)) {\n\t\treturn value.padStart(characterAmount, sign);\n\t}\n\n\tconst hex = typeof value === 'string' && isHexStrict(value) ? value : numberToHex(value);\n\n\tconst [prefix, hexValue] = hex.startsWith('-') ? ['-0x', hex.slice(3)] : ['0x', hex.slice(2)];\n\n\treturn `${prefix}${hexValue.padStart(characterAmount, sign)}`;\n};\n\nexport function uint8ArrayToHexString(uint8Array: Uint8Array): string {\n\tlet hexString = '0x';\n\tfor (const e of uint8Array) {\n\t\tconst hex = e.toString(16);\n\t\thexString += hex.length === 1 ? `0${hex}` : hex;\n\t}\n\treturn hexString;\n}\n\nexport function hexToUint8Array(hex: string): Uint8Array {\n\tlet value;\n\tif (hex.toLowerCase().startsWith('0x')) {\n\t\tvalue = hex.slice(2);\n\t} else {\n\t\tvalue = hex;\n\t}\n\tif (value.length % 2 !== 0) {\n\t\tthrow new InvalidBytesError(`hex string has odd length: ${hex}`);\n\t}\n\tconst bytes = new Uint8Array(Math.ceil(value.length / 2));\n\tfor (let i = 0; i < bytes.length; i += 1) {\n\t\tconst byte = parseInt(value.substring(i * 2, i * 2 + 2), 16);\n\t\tbytes[i] = byte;\n\t}\n\treturn bytes;\n}\n"]},"metadata":{},"sourceType":"script"}