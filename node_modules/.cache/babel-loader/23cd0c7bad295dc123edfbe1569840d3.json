{"ast":null,"code":"/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { parseBaseType, hexToNumber } from '../utils.js';\nimport { isHexStrict } from './string.js';\n/**\n * Checks if a given value is a valid big int\n */\n\nexport const isBigInt = value => typeof value === 'bigint'; // Note: this could be simplified using ** operator, but babel does not handle it well\n// \tyou can find more at: https://github.com/babel/babel/issues/13109 and https://github.com/web3/web3.js/issues/6187\n\n/** @internal */\n\nexport const bigintPower = (base, expo) => {\n  let res = base;\n\n  for (let index = 1; index < expo; index += 1) {\n    res *= base;\n  }\n\n  return res;\n};\nexport const isUInt = function (value) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    abiType: 'uint'\n  };\n\n  if (!['number', 'string', 'bigint'].includes(typeof value) || typeof value === 'string' && value.length === 0) {\n    return false;\n  }\n\n  let size;\n\n  if (options === null || options === void 0 ? void 0 : options.abiType) {\n    const {\n      baseTypeSize\n    } = parseBaseType(options.abiType);\n\n    if (baseTypeSize) {\n      size = baseTypeSize;\n    }\n  } else if (options.bitSize) {\n    size = options.bitSize;\n  }\n\n  const maxSize = bigintPower(BigInt(2), BigInt(size !== null && size !== void 0 ? size : 256)) - BigInt(1);\n\n  try {\n    const valueToCheck = typeof value === 'string' && isHexStrict(value) ? BigInt(hexToNumber(value)) : BigInt(value);\n    return valueToCheck >= 0 && valueToCheck <= maxSize;\n  } catch (error) {\n    // Some invalid number value given which can not be converted via BigInt\n    return false;\n  }\n};\nexport const isInt = function (value) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    abiType: 'int'\n  };\n\n  if (!['number', 'string', 'bigint'].includes(typeof value)) {\n    return false;\n  }\n\n  if (typeof value === 'number' && value > Number.MAX_SAFE_INTEGER) {\n    return false;\n  }\n\n  let size;\n\n  if (options === null || options === void 0 ? void 0 : options.abiType) {\n    const {\n      baseTypeSize,\n      baseType\n    } = parseBaseType(options.abiType);\n\n    if (baseType !== 'int') {\n      return false;\n    }\n\n    if (baseTypeSize) {\n      size = baseTypeSize;\n    }\n  } else if (options.bitSize) {\n    size = options.bitSize;\n  }\n\n  const maxSize = bigintPower(BigInt(2), BigInt((size !== null && size !== void 0 ? size : 256) - 1));\n  const minSize = BigInt(-1) * bigintPower(BigInt(2), BigInt((size !== null && size !== void 0 ? size : 256) - 1));\n\n  try {\n    const valueToCheck = typeof value === 'string' && isHexStrict(value) ? BigInt(hexToNumber(value)) : BigInt(value);\n    return valueToCheck >= minSize && valueToCheck <= maxSize;\n  } catch (error) {\n    // Some invalid number value given which can not be converted via BigInt\n    return false;\n  }\n};\nexport const isNumber = value => {\n  if (isInt(value)) {\n    return true;\n  } // It would be a decimal number\n\n\n  if (typeof value === 'string' && /[0-9.]/.test(value) && value.indexOf('.') === value.lastIndexOf('.')) {\n    return true;\n  }\n\n  if (typeof value === 'number') {\n    return true;\n  }\n\n  return false;\n};","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;;AAkBA,SAASA,aAAT,EAAwBC,WAAxB,QAA2C,aAA3C;AACA,SAASC,WAAT,QAA4B,aAA5B;AAEA;;;;AAGA,OAAO,MAAMC,QAAQ,GAAIC,KAAD,IAAqC,OAAOA,KAAP,KAAiB,QAAvE,C,CAEP;AACA;;AACA;;AACA,OAAO,MAAMC,WAAW,GAAG,CAACC,IAAD,EAAeC,IAAf,KAA+B;EACzD,IAAIC,GAAG,GAAGF,IAAV;;EACA,KAAK,IAAIG,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGF,IAA5B,EAAkCE,KAAK,IAAI,CAA3C,EAA8C;IAC7CD,GAAG,IAAIF,IAAP;EACA;;EACD,OAAOE,GAAP;AACA,CANM;AAQP,OAAO,MAAME,MAAM,GAAG,UACrBN,KADqB,EAKlB;EAAA,IAHHO,OAGG,uEAHoF;IACtFC,OAAO,EAAE;EAD6E,CAGpF;;EACH,IACC,CAAC,CAAC,QAAD,EAAW,QAAX,EAAqB,QAArB,EAA+BC,QAA/B,CAAwC,OAAOT,KAA/C,CAAD,IACC,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,CAACU,MAAN,KAAiB,CAFhD,EAGE;IACD,OAAO,KAAP;EACA;;EAED,IAAIC,IAAJ;;EAEA,IAAIJ,OAAO,SAAP,WAAO,WAAP,GAAO,MAAP,UAAO,CAAEC,OAAb,EAAsB;IACrB,MAAM;MAAEI;IAAF,IAAmBhB,aAAa,CAACW,OAAO,CAACC,OAAT,CAAtC;;IAEA,IAAII,YAAJ,EAAkB;MACjBD,IAAI,GAAGC,YAAP;IACA;EACD,CAND,MAMO,IAAIL,OAAO,CAACM,OAAZ,EAAqB;IAC3BF,IAAI,GAAGJ,OAAO,CAACM,OAAf;EACA;;EAED,MAAMC,OAAO,GAAGb,WAAW,CAACc,MAAM,CAAC,CAAD,CAAP,EAAYA,MAAM,CAACJ,IAAI,SAAJ,QAAI,WAAJ,UAAQ,GAAT,CAAlB,CAAX,GAA8CI,MAAM,CAAC,CAAD,CAApE;;EAEA,IAAI;IACH,MAAMC,YAAY,GACjB,OAAOhB,KAAP,KAAiB,QAAjB,IAA6BF,WAAW,CAACE,KAAD,CAAxC,GACGe,MAAM,CAAClB,WAAW,CAACG,KAAD,CAAZ,CADT,GAEGe,MAAM,CAACf,KAAD,CAHV;IAKA,OAAOgB,YAAY,IAAI,CAAhB,IAAqBA,YAAY,IAAIF,OAA5C;EACA,CAPD,CAOE,OAAOG,KAAP,EAAc;IACf;IACA,OAAO,KAAP;EACA;AACD,CAtCM;AAwCP,OAAO,MAAMC,KAAK,GAAG,UACpBlB,KADoB,EAKjB;EAAA,IAHHO,OAGG,uEAHoF;IACtFC,OAAO,EAAE;EAD6E,CAGpF;;EACH,IAAI,CAAC,CAAC,QAAD,EAAW,QAAX,EAAqB,QAArB,EAA+BC,QAA/B,CAAwC,OAAOT,KAA/C,CAAL,EAA4D;IAC3D,OAAO,KAAP;EACA;;EAED,IAAI,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,GAAGmB,MAAM,CAACC,gBAAhD,EAAkE;IACjE,OAAO,KAAP;EACA;;EAED,IAAIT,IAAJ;;EAEA,IAAIJ,OAAO,SAAP,WAAO,WAAP,GAAO,MAAP,UAAO,CAAEC,OAAb,EAAsB;IACrB,MAAM;MAAEI,YAAF;MAAgBS;IAAhB,IAA6BzB,aAAa,CAACW,OAAO,CAACC,OAAT,CAAhD;;IAEA,IAAIa,QAAQ,KAAK,KAAjB,EAAwB;MACvB,OAAO,KAAP;IACA;;IAED,IAAIT,YAAJ,EAAkB;MACjBD,IAAI,GAAGC,YAAP;IACA;EACD,CAVD,MAUO,IAAIL,OAAO,CAACM,OAAZ,EAAqB;IAC3BF,IAAI,GAAGJ,OAAO,CAACM,OAAf;EACA;;EAED,MAAMC,OAAO,GAAGb,WAAW,CAACc,MAAM,CAAC,CAAD,CAAP,EAAYA,MAAM,CAAC,CAACJ,IAAI,SAAJ,QAAI,WAAJ,UAAQ,GAAT,IAAgB,CAAjB,CAAlB,CAA3B;EACA,MAAMW,OAAO,GAAGP,MAAM,CAAC,CAAC,CAAF,CAAN,GAAad,WAAW,CAACc,MAAM,CAAC,CAAD,CAAP,EAAYA,MAAM,CAAC,CAACJ,IAAI,SAAJ,QAAI,WAAJ,UAAQ,GAAT,IAAgB,CAAjB,CAAlB,CAAxC;;EAEA,IAAI;IACH,MAAMK,YAAY,GACjB,OAAOhB,KAAP,KAAiB,QAAjB,IAA6BF,WAAW,CAACE,KAAD,CAAxC,GACGe,MAAM,CAAClB,WAAW,CAACG,KAAD,CAAZ,CADT,GAEGe,MAAM,CAACf,KAAD,CAHV;IAKA,OAAOgB,YAAY,IAAIM,OAAhB,IAA2BN,YAAY,IAAIF,OAAlD;EACA,CAPD,CAOE,OAAOG,KAAP,EAAc;IACf;IACA,OAAO,KAAP;EACA;AACD,CA5CM;AA8CP,OAAO,MAAMM,QAAQ,GAAIvB,KAAD,IAA2B;EAClD,IAAIkB,KAAK,CAAClB,KAAD,CAAT,EAAkB;IACjB,OAAO,IAAP;EACA,CAHiD,CAKlD;;;EACA,IACC,OAAOA,KAAP,KAAiB,QAAjB,IACA,SAASwB,IAAT,CAAcxB,KAAd,CADA,IAEAA,KAAK,CAACyB,OAAN,CAAc,GAAd,MAAuBzB,KAAK,CAAC0B,WAAN,CAAkB,GAAlB,CAHxB,EAIE;IACD,OAAO,IAAP;EACA;;EAED,IAAI,OAAO1B,KAAP,KAAiB,QAArB,EAA+B;IAC9B,OAAO,IAAP;EACA;;EAED,OAAO,KAAP;AACA,CAnBM","names":["parseBaseType","hexToNumber","isHexStrict","isBigInt","value","bigintPower","base","expo","res","index","isUInt","options","abiType","includes","length","size","baseTypeSize","bitSize","maxSize","BigInt","valueToCheck","error","isInt","Number","MAX_SAFE_INTEGER","baseType","minSize","isNumber","test","indexOf","lastIndexOf"],"sources":["/home/rupam/Desktop/Faucet-React/node_modules/web3-validator/src/validation/numbers.ts"],"sourcesContent":["ï»¿/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport { ValidInputTypes } from '../types.js';\nimport { parseBaseType, hexToNumber } from '../utils.js';\nimport { isHexStrict } from './string.js';\n\n/**\n * Checks if a given value is a valid big int\n */\nexport const isBigInt = (value: ValidInputTypes): boolean => typeof value === 'bigint';\n\n// Note: this could be simplified using ** operator, but babel does not handle it well\n// \tyou can find more at: https://github.com/babel/babel/issues/13109 and https://github.com/web3/web3.js/issues/6187\n/** @internal */\nexport const bigintPower = (base: bigint, expo: bigint) => {\n\tlet res = base;\n\tfor (let index = 1; index < expo; index += 1) {\n\t\tres *= base;\n\t}\n\treturn res;\n};\n\nexport const isUInt = (\n\tvalue: ValidInputTypes,\n\toptions: { abiType: string; bitSize?: never } | { bitSize: number; abiType?: never } = {\n\t\tabiType: 'uint',\n\t},\n) => {\n\tif (\n\t\t!['number', 'string', 'bigint'].includes(typeof value) ||\n\t\t(typeof value === 'string' && value.length === 0)\n\t) {\n\t\treturn false;\n\t}\n\n\tlet size!: number;\n\n\tif (options?.abiType) {\n\t\tconst { baseTypeSize } = parseBaseType(options.abiType);\n\n\t\tif (baseTypeSize) {\n\t\t\tsize = baseTypeSize;\n\t\t}\n\t} else if (options.bitSize) {\n\t\tsize = options.bitSize;\n\t}\n\n\tconst maxSize = bigintPower(BigInt(2), BigInt(size ?? 256)) - BigInt(1);\n\n\ttry {\n\t\tconst valueToCheck =\n\t\t\ttypeof value === 'string' && isHexStrict(value)\n\t\t\t\t? BigInt(hexToNumber(value))\n\t\t\t\t: BigInt(value as number);\n\n\t\treturn valueToCheck >= 0 && valueToCheck <= maxSize;\n\t} catch (error) {\n\t\t// Some invalid number value given which can not be converted via BigInt\n\t\treturn false;\n\t}\n};\n\nexport const isInt = (\n\tvalue: ValidInputTypes,\n\toptions: { abiType: string; bitSize?: never } | { bitSize: number; abiType?: never } = {\n\t\tabiType: 'int',\n\t},\n) => {\n\tif (!['number', 'string', 'bigint'].includes(typeof value)) {\n\t\treturn false;\n\t}\n\n\tif (typeof value === 'number' && value > Number.MAX_SAFE_INTEGER) {\n\t\treturn false;\n\t}\n\n\tlet size!: number;\n\n\tif (options?.abiType) {\n\t\tconst { baseTypeSize, baseType } = parseBaseType(options.abiType);\n\n\t\tif (baseType !== 'int') {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (baseTypeSize) {\n\t\t\tsize = baseTypeSize;\n\t\t}\n\t} else if (options.bitSize) {\n\t\tsize = options.bitSize;\n\t}\n\n\tconst maxSize = bigintPower(BigInt(2), BigInt((size ?? 256) - 1));\n\tconst minSize = BigInt(-1) * bigintPower(BigInt(2), BigInt((size ?? 256) - 1));\n\n\ttry {\n\t\tconst valueToCheck =\n\t\t\ttypeof value === 'string' && isHexStrict(value)\n\t\t\t\t? BigInt(hexToNumber(value))\n\t\t\t\t: BigInt(value as number);\n\n\t\treturn valueToCheck >= minSize && valueToCheck <= maxSize;\n\t} catch (error) {\n\t\t// Some invalid number value given which can not be converted via BigInt\n\t\treturn false;\n\t}\n};\n\nexport const isNumber = (value: ValidInputTypes) => {\n\tif (isInt(value)) {\n\t\treturn true;\n\t}\n\n\t// It would be a decimal number\n\tif (\n\t\ttypeof value === 'string' &&\n\t\t/[0-9.]/.test(value) &&\n\t\tvalue.indexOf('.') === value.lastIndexOf('.')\n\t) {\n\t\treturn true;\n\t}\n\n\tif (typeof value === 'number') {\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n"]},"metadata":{},"sourceType":"module"}