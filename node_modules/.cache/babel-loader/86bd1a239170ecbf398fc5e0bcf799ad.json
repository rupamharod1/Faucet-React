{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.rejectIfBlockTimeout = void 0;\n\nconst web3_utils_1 = require(\"web3-utils\");\n\nconst web3_errors_1 = require(\"web3-errors\");\n\nconst constants_js_1 = require(\"../constants.js\"); // eslint-disable-next-line import/no-cycle\n\n\nconst rpc_method_wrappers_js_1 = require(\"../rpc_method_wrappers.js\");\n\nfunction resolveByPolling(web3Context, starterBlockNumber, transactionHash) {\n  const pollingInterval = web3Context.transactionPollingInterval;\n  const [intervalId, promiseToError] = (0, web3_utils_1.rejectIfConditionAtInterval)(() => __awaiter(this, void 0, void 0, function* () {\n    let lastBlockNumber;\n\n    try {\n      lastBlockNumber = yield (0, rpc_method_wrappers_js_1.getBlockNumber)(web3Context, constants_js_1.NUMBER_DATA_FORMAT);\n    } catch (error) {\n      console.warn('An error happen while trying to get the block number', error);\n      return undefined;\n    }\n\n    const numberOfBlocks = lastBlockNumber - starterBlockNumber;\n\n    if (numberOfBlocks >= web3Context.transactionBlockTimeout) {\n      return new web3_errors_1.TransactionBlockTimeoutError({\n        starterBlockNumber,\n        numberOfBlocks,\n        transactionHash\n      });\n    }\n\n    return undefined;\n  }), pollingInterval);\n\n  const clean = () => {\n    clearInterval(intervalId);\n  };\n\n  return [promiseToError, {\n    clean\n  }];\n}\n\nfunction resolveBySubscription(web3Context, starterBlockNumber, transactionHash) {\n  var _a;\n\n  return __awaiter(this, void 0, void 0, function* () {\n    // The following variable will stay true except if the data arrived,\n    //\tor if watching started after an error had occurred.\n    let needToWatchLater = true;\n    let subscription;\n    let resourceCleaner; // internal helper function\n\n    function revertToPolling(reject, previousError) {\n      if (previousError) {\n        console.warn('error happened at subscription. So revert to polling...', previousError);\n      }\n\n      resourceCleaner.clean();\n      needToWatchLater = false;\n      const [promiseToError, newResourceCleaner] = resolveByPolling(web3Context, starterBlockNumber, transactionHash);\n      resourceCleaner.clean = newResourceCleaner.clean;\n      promiseToError.catch(error => reject(error));\n    }\n\n    try {\n      subscription = yield (_a = web3Context.subscriptionManager) === null || _a === void 0 ? void 0 : _a.subscribe('newHeads');\n      resourceCleaner = {\n        clean: () => {\n          var _a; // Remove the subscription, if it was not removed somewhere\n          // \telse by calling, for example, subscriptionManager.clear()\n\n\n          if (subscription.id) {\n            (_a = web3Context.subscriptionManager) === null || _a === void 0 ? void 0 : _a.removeSubscription(subscription).then(() => {// Subscription ended successfully\n            }).catch(() => {// An error happened while ending subscription. But no need to take any action.\n            });\n          }\n        }\n      };\n    } catch (error) {\n      return resolveByPolling(web3Context, starterBlockNumber, transactionHash);\n    }\n\n    const promiseToError = new Promise((_, reject) => {\n      try {\n        subscription.on('data', lastBlockHeader => {\n          needToWatchLater = false;\n\n          if (!(lastBlockHeader === null || lastBlockHeader === void 0 ? void 0 : lastBlockHeader.number)) {\n            return;\n          }\n\n          const numberOfBlocks = Number(BigInt(lastBlockHeader.number) - BigInt(starterBlockNumber));\n\n          if (numberOfBlocks >= web3Context.transactionBlockTimeout) {\n            // Transaction Block Timeout is known to be reached by subscribing to new heads\n            reject(new web3_errors_1.TransactionBlockTimeoutError({\n              starterBlockNumber,\n              numberOfBlocks,\n              transactionHash\n            }));\n          }\n        });\n        subscription.on('error', error => {\n          revertToPolling(reject, error);\n        });\n      } catch (error) {\n        revertToPolling(reject, error);\n      } // Fallback to polling if tx receipt didn't arrived in \"blockHeaderTimeout\" [10 seconds]\n\n\n      setTimeout(() => {\n        if (needToWatchLater) {\n          revertToPolling(reject);\n        }\n      }, web3Context.blockHeaderTimeout * 1000);\n    });\n    return [promiseToError, resourceCleaner];\n  });\n}\n/* TODO: After merge, there will be constant block mining time (exactly 12 second each block, except slot missed that currently happens in <1% of slots. ) so we can optimize following function\nfor POS NWs, we can skip checking getBlockNumber(); after interval and calculate only based on time  that certain num of blocked are mined after that for internal double check, can do one getBlockNumber() call and timeout.\n*/\n\n\nfunction rejectIfBlockTimeout(web3Context, transactionHash) {\n  var _a, _b;\n\n  return __awaiter(this, void 0, void 0, function* () {\n    const {\n      provider\n    } = web3Context.requestManager;\n    let callingRes;\n    const starterBlockNumber = yield (0, rpc_method_wrappers_js_1.getBlockNumber)(web3Context, constants_js_1.NUMBER_DATA_FORMAT); // TODO: once https://github.com/web3/web3.js/issues/5521 is implemented, remove checking for `enableExperimentalFeatures.useSubscriptionWhenCheckingBlockTimeout`\n\n    if (((_b = (_a = provider).supportsSubscriptions) === null || _b === void 0 ? void 0 : _b.call(_a)) && web3Context.enableExperimentalFeatures.useSubscriptionWhenCheckingBlockTimeout) {\n      callingRes = yield resolveBySubscription(web3Context, starterBlockNumber, transactionHash);\n    } else {\n      callingRes = resolveByPolling(web3Context, starterBlockNumber, transactionHash);\n    }\n\n    return callingRes;\n  });\n}\n\nexports.rejectIfBlockTimeout = rejectIfBlockTimeout;","map":{"version":3,"mappings":"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","names":["resolveByPolling","web3Context","starterBlockNumber","transactionHash","pollingInterval","transactionPollingInterval","intervalId","promiseToError","__awaiter","lastBlockNumber","constants_js_1","error","console","warn","undefined","numberOfBlocks","transactionBlockTimeout","web3_errors_1","clean","clearInterval","resolveBySubscription","needToWatchLater","subscription","resourceCleaner","revertToPolling","reject","previousError","newResourceCleaner","catch","subscriptionManager","_a","subscribe","id","removeSubscription","then","Promise","_","on","lastBlockHeader","number","Number","BigInt","setTimeout","blockHeaderTimeout","rejectIfBlockTimeout","provider","requestManager","callingRes","supportsSubscriptions","_b","enableExperimentalFeatures","useSubscriptionWhenCheckingBlockTimeout","exports"],"sources":["/home/rupam/Desktop/Faucet-React/node_modules/web3-eth/src/utils/reject_if_block_timeout.ts"],"sourcesContent":["/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\nimport { EthExecutionAPI, Bytes, Web3BaseProvider, BlockHeaderOutput } from 'web3-types';\nimport { Web3Context } from 'web3-core';\nimport { rejectIfConditionAtInterval } from 'web3-utils';\n\nimport { TransactionBlockTimeoutError } from 'web3-errors';\nimport { NUMBER_DATA_FORMAT } from '../constants.js';\n// eslint-disable-next-line import/no-cycle\nimport { getBlockNumber } from '../rpc_method_wrappers.js';\nimport { NewHeadsSubscription } from '../web3_subscriptions.js';\n\nexport interface ResourceCleaner {\n\tclean: () => void;\n}\n\nfunction resolveByPolling(\n\tweb3Context: Web3Context<EthExecutionAPI>,\n\tstarterBlockNumber: number,\n\ttransactionHash?: Bytes,\n): [Promise<never>, ResourceCleaner] {\n\tconst pollingInterval = web3Context.transactionPollingInterval;\n\tconst [intervalId, promiseToError] =\n\t\trejectIfConditionAtInterval(async () => {\n\t\t\tlet lastBlockNumber;\n\t\t\ttry {\n\t\t\t\tlastBlockNumber = await getBlockNumber(web3Context, NUMBER_DATA_FORMAT);\n\t\t\t} catch (error) {\n\t\t\t\tconsole.warn('An error happen while trying to get the block number', error);\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tconst numberOfBlocks = lastBlockNumber - starterBlockNumber;\n\t\t\tif (numberOfBlocks >= web3Context.transactionBlockTimeout) {\n\t\t\t\treturn new TransactionBlockTimeoutError({\n\t\t\t\t\tstarterBlockNumber,\n\t\t\t\t\tnumberOfBlocks,\n\t\t\t\t\ttransactionHash,\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn undefined;\n\t\t}, pollingInterval);\n\n\tconst clean = () => {\n\t\tclearInterval(intervalId);\n\t};\n\n\treturn [promiseToError, { clean }];\n}\n\nasync function resolveBySubscription(\n\tweb3Context: Web3Context<EthExecutionAPI>,\n\tstarterBlockNumber: number,\n\ttransactionHash?: Bytes,\n): Promise<[Promise<never>, ResourceCleaner]> {\n\t// The following variable will stay true except if the data arrived,\n\t//\tor if watching started after an error had occurred.\n\tlet needToWatchLater = true;\n\n\tlet subscription: NewHeadsSubscription;\n\tlet resourceCleaner: ResourceCleaner;\n\t// internal helper function\n\tfunction revertToPolling(\n\t\treject: (value: Error | PromiseLike<Error>) => void,\n\t\tpreviousError?: Error,\n\t) {\n\t\tif (previousError) {\n\t\t\tconsole.warn('error happened at subscription. So revert to polling...', previousError);\n\t\t}\n\t\tresourceCleaner.clean();\n\n\t\tneedToWatchLater = false;\n\t\tconst [promiseToError, newResourceCleaner] = resolveByPolling(\n\t\t\tweb3Context,\n\t\t\tstarterBlockNumber,\n\t\t\ttransactionHash,\n\t\t);\n\t\tresourceCleaner.clean = newResourceCleaner.clean;\n\t\tpromiseToError.catch(error => reject(error as Error));\n\t}\n\ttry {\n\t\tsubscription = (await web3Context.subscriptionManager?.subscribe(\n\t\t\t'newHeads',\n\t\t)) as unknown as NewHeadsSubscription;\n\t\tresourceCleaner = {\n\t\t\tclean: () => {\n\t\t\t\t// Remove the subscription, if it was not removed somewhere\n\t\t\t\t// \telse by calling, for example, subscriptionManager.clear()\n\t\t\t\tif (subscription.id) {\n\t\t\t\t\tweb3Context.subscriptionManager\n\t\t\t\t\t\t?.removeSubscription(subscription)\n\t\t\t\t\t\t.then(() => {\n\t\t\t\t\t\t\t// Subscription ended successfully\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch(() => {\n\t\t\t\t\t\t\t// An error happened while ending subscription. But no need to take any action.\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t} catch (error) {\n\t\treturn resolveByPolling(web3Context, starterBlockNumber, transactionHash);\n\t}\n\tconst promiseToError: Promise<never> = new Promise((_, reject) => {\n\t\ttry {\n\t\t\tsubscription.on('data', (lastBlockHeader: BlockHeaderOutput) => {\n\t\t\t\tneedToWatchLater = false;\n\t\t\t\tif (!lastBlockHeader?.number) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst numberOfBlocks = Number(\n\t\t\t\t\tBigInt(lastBlockHeader.number) - BigInt(starterBlockNumber),\n\t\t\t\t);\n\n\t\t\t\tif (numberOfBlocks >= web3Context.transactionBlockTimeout) {\n\t\t\t\t\t// Transaction Block Timeout is known to be reached by subscribing to new heads\n\t\t\t\t\treject(\n\t\t\t\t\t\tnew TransactionBlockTimeoutError({\n\t\t\t\t\t\t\tstarterBlockNumber,\n\t\t\t\t\t\t\tnumberOfBlocks,\n\t\t\t\t\t\t\ttransactionHash,\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t\tsubscription.on('error', error => {\n\t\t\t\trevertToPolling(reject, error);\n\t\t\t});\n\t\t} catch (error) {\n\t\t\trevertToPolling(reject, error as Error);\n\t\t}\n\n\t\t// Fallback to polling if tx receipt didn't arrived in \"blockHeaderTimeout\" [10 seconds]\n\t\tsetTimeout(() => {\n\t\t\tif (needToWatchLater) {\n\t\t\t\trevertToPolling(reject);\n\t\t\t}\n\t\t}, web3Context.blockHeaderTimeout * 1000);\n\t});\n\n\treturn [promiseToError, resourceCleaner];\n}\n\n/* TODO: After merge, there will be constant block mining time (exactly 12 second each block, except slot missed that currently happens in <1% of slots. ) so we can optimize following function\nfor POS NWs, we can skip checking getBlockNumber(); after interval and calculate only based on time  that certain num of blocked are mined after that for internal double check, can do one getBlockNumber() call and timeout. \n*/\nexport async function rejectIfBlockTimeout(\n\tweb3Context: Web3Context<EthExecutionAPI>,\n\ttransactionHash?: Bytes,\n): Promise<[Promise<never>, ResourceCleaner]> {\n\tconst { provider } = web3Context.requestManager;\n\tlet callingRes: [Promise<never>, ResourceCleaner];\n\tconst starterBlockNumber = await getBlockNumber(web3Context, NUMBER_DATA_FORMAT);\n\t// TODO: once https://github.com/web3/web3.js/issues/5521 is implemented, remove checking for `enableExperimentalFeatures.useSubscriptionWhenCheckingBlockTimeout`\n\tif (\n\t\t(provider as Web3BaseProvider).supportsSubscriptions?.() &&\n\t\tweb3Context.enableExperimentalFeatures.useSubscriptionWhenCheckingBlockTimeout\n\t) {\n\t\tcallingRes = await resolveBySubscription(web3Context, starterBlockNumber, transactionHash);\n\t} else {\n\t\tcallingRes = resolveByPolling(web3Context, starterBlockNumber, transactionHash);\n\t}\n\treturn callingRes;\n}\n"]},"metadata":{},"sourceType":"script"}