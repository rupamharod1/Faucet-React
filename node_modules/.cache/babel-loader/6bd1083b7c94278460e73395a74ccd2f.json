{"ast":null,"code":"\"use strict\";\n/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Web3RequestManager = exports.Web3RequestManagerEvent = void 0;\n\nconst web3_errors_1 = require(\"web3-errors\");\n\nconst web3_providers_http_1 = __importDefault(require(\"web3-providers-http\"));\n\nconst web3_providers_ws_1 = __importDefault(require(\"web3-providers-ws\"));\n\nconst web3_utils_1 = require(\"web3-utils\");\n\nconst utils_js_1 = require(\"./utils.js\");\n\nconst web3_event_emitter_js_1 = require(\"./web3_event_emitter.js\");\n\nvar Web3RequestManagerEvent;\n\n(function (Web3RequestManagerEvent) {\n  Web3RequestManagerEvent[\"PROVIDER_CHANGED\"] = \"PROVIDER_CHANGED\";\n  Web3RequestManagerEvent[\"BEFORE_PROVIDER_CHANGE\"] = \"BEFORE_PROVIDER_CHANGE\";\n})(Web3RequestManagerEvent = exports.Web3RequestManagerEvent || (exports.Web3RequestManagerEvent = {}));\n\nconst availableProviders = {\n  HttpProvider: web3_providers_http_1.default,\n  WebsocketProvider: web3_providers_ws_1.default\n};\n\nclass Web3RequestManager extends web3_event_emitter_js_1.Web3EventEmitter {\n  constructor(provider, useRpcCallSpecification) {\n    super();\n\n    if (!(0, web3_utils_1.isNullish)(provider)) {\n      this.setProvider(provider);\n    }\n\n    this.useRpcCallSpecification = useRpcCallSpecification;\n  }\n  /**\n   * Will return all available providers\n   */\n\n\n  static get providers() {\n    return availableProviders;\n  }\n  /**\n   * Will return the current provider.\n   *\n   * @returns Returns the current provider\n   */\n\n\n  get provider() {\n    return this._provider;\n  }\n  /**\n   * Will return all available providers\n   */\n  // eslint-disable-next-line class-methods-use-this\n\n\n  get providers() {\n    return availableProviders;\n  }\n  /**\n   * Use to set provider. Provider can be a provider instance or a string.\n   *\n   * @param provider - The provider to set\n   */\n\n\n  setProvider(provider) {\n    let newProvider; // autodetect provider\n\n    if (provider && typeof provider === 'string' && this.providers) {\n      // HTTP\n      if (/^http(s)?:\\/\\//i.test(provider)) {\n        newProvider = new this.providers.HttpProvider(provider); // WS\n      } else if (/^ws(s)?:\\/\\//i.test(provider)) {\n        newProvider = new this.providers.WebsocketProvider(provider);\n      } else {\n        throw new web3_errors_1.ProviderError(`Can't autodetect provider for \"${provider}\"`);\n      }\n    } else if ((0, web3_utils_1.isNullish)(provider)) {\n      // In case want to unset the provider\n      newProvider = undefined;\n    } else {\n      newProvider = provider;\n    }\n\n    this.emit(Web3RequestManagerEvent.BEFORE_PROVIDER_CHANGE, this._provider);\n    this._provider = newProvider;\n    this.emit(Web3RequestManagerEvent.PROVIDER_CHANGED, this._provider);\n    return true;\n  }\n  /**\n   *\n   * Will execute a request\n   *\n   * @param request - {@link Web3APIRequest} The request to send\n   *\n   * @returns The response of the request {@link ResponseType}. If there is error\n   * in the response, will throw an error\n   */\n\n\n  send(request) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const response = yield this._sendRequest(request);\n\n      if (web3_utils_1.jsonRpc.isResponseWithResult(response)) {\n        return response.result;\n      }\n\n      throw new web3_errors_1.ResponseError(response);\n    });\n  }\n  /**\n   * Same as send, but, will execute a batch of requests\n   *\n   * @param request {@link JsonRpcBatchRequest} The batch request to send\n   */\n\n\n  sendBatch(request) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const response = yield this._sendRequest(request);\n      return response;\n    });\n  }\n\n  _sendRequest(request) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        provider\n      } = this;\n\n      if ((0, web3_utils_1.isNullish)(provider)) {\n        throw new web3_errors_1.ProviderError('Provider not available. Use `.setProvider` or `.provider=` to initialize the provider.');\n      }\n\n      const payload = web3_utils_1.jsonRpc.isBatchRequest(request) ? web3_utils_1.jsonRpc.toBatchPayload(request) : web3_utils_1.jsonRpc.toPayload(request);\n\n      if ((0, utils_js_1.isWeb3Provider)(provider)) {\n        let response;\n\n        try {\n          response = yield provider.request(payload);\n        } catch (error) {\n          // Check if the provider throw an error instead of reject with error\n          response = error;\n        }\n\n        return this._processJsonRpcResponse(payload, response, {\n          legacy: false,\n          error: false\n        });\n      }\n\n      if ((0, utils_js_1.isEIP1193Provider)(provider)) {\n        return provider.request(payload).then(res => this._processJsonRpcResponse(payload, res, {\n          legacy: true,\n          error: false\n        })).catch(error => this._processJsonRpcResponse(payload, error, {\n          legacy: true,\n          error: true\n        }));\n      } // TODO: This could be deprecated and removed.\n\n\n      if ((0, utils_js_1.isLegacyRequestProvider)(provider)) {\n        return new Promise((resolve, reject) => {\n          const rejectWithError = err => reject(this._processJsonRpcResponse(payload, err, {\n            legacy: true,\n            error: true\n          }));\n\n          const resolveWithResponse = response => resolve(this._processJsonRpcResponse(payload, response, {\n            legacy: true,\n            error: false\n          }));\n\n          const result = provider.request(payload, // a callback that is expected to be called after getting the response:\n          (err, response) => {\n            if (err) {\n              return rejectWithError(err);\n            }\n\n            return resolveWithResponse(response);\n          }); // Some providers, that follow a previous drafted version of EIP1193, has a `request` function\n          //\tthat is not defined as `async`, but it returns a promise.\n          // Such providers would not be picked with if(isEIP1193Provider(provider)) above\n          //\tbecause the `request` function was not defined with `async` and so the function definition is not `AsyncFunction`.\n          // Like this provider: https://github.dev/NomicFoundation/hardhat/blob/62bea2600785595ba36f2105564076cf5cdf0fd8/packages/hardhat-core/src/internal/core/providers/backwards-compatibility.ts#L19\n          // So check if the returned result is a Promise, and resolve with it accordingly.\n          // Note: in this case we expect the callback provided above to never be called.\n\n          if ((0, web3_utils_1.isPromise)(result)) {\n            const responsePromise = result;\n            responsePromise.then(resolveWithResponse).catch(rejectWithError);\n          }\n        });\n      } // TODO: This could be deprecated and removed.\n\n\n      if ((0, utils_js_1.isLegacySendProvider)(provider)) {\n        return new Promise((resolve, reject) => {\n          provider.send(payload, (err, response) => {\n            if (err) {\n              return reject(this._processJsonRpcResponse(payload, err, {\n                legacy: true,\n                error: true\n              }));\n            }\n\n            if ((0, web3_utils_1.isNullish)(response)) {\n              throw new web3_errors_1.ResponseError('', 'Got a \"nullish\" response from provider.');\n            }\n\n            return resolve(this._processJsonRpcResponse(payload, response, {\n              legacy: true,\n              error: false\n            }));\n          });\n        });\n      } // TODO: This could be deprecated and removed.\n\n\n      if ((0, utils_js_1.isLegacySendAsyncProvider)(provider)) {\n        return provider.sendAsync(payload).then(response => this._processJsonRpcResponse(payload, response, {\n          legacy: true,\n          error: false\n        })).catch(error => this._processJsonRpcResponse(payload, error, {\n          legacy: true,\n          error: true\n        }));\n      }\n\n      throw new web3_errors_1.ProviderError('Provider does not have a request or send method to use.');\n    });\n  } // eslint-disable-next-line class-methods-use-this\n\n\n  _processJsonRpcResponse(payload, response, _ref) {\n    let {\n      legacy,\n      error\n    } = _ref;\n\n    if ((0, web3_utils_1.isNullish)(response)) {\n      return this._buildResponse(payload, // Some providers uses \"null\" as valid empty response\n      // eslint-disable-next-line no-null/no-null\n      null, error);\n    } // This is the majority of the cases so check these first\n    // A valid JSON-RPC response with error object\n\n\n    if (web3_utils_1.jsonRpc.isResponseWithError(response)) {\n      // check if its an rpc error\n      if (this.useRpcCallSpecification && (0, web3_utils_1.isResponseRpcError)(response)) {\n        const rpcErrorResponse = response; // check if rpc error flag is on and response error code match an EIP-1474 or a standard rpc error code\n\n        if (web3_errors_1.rpcErrorsMap.get(rpcErrorResponse.error.code)) {\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          const Err = web3_errors_1.rpcErrorsMap.get(rpcErrorResponse.error.code).error;\n          throw new Err(rpcErrorResponse);\n        } else {\n          throw new web3_errors_1.RpcError(rpcErrorResponse);\n        }\n      } else if (!Web3RequestManager._isReverted(response)) {\n        throw new web3_errors_1.InvalidResponseError(response, payload);\n      }\n    } // This is the majority of the cases so check these first\n    // A valid JSON-RPC response with result object\n\n\n    if (web3_utils_1.jsonRpc.isResponseWithResult(response)) {\n      return response;\n    }\n\n    if (response instanceof Error) {\n      Web3RequestManager._isReverted(response);\n\n      throw response;\n    }\n\n    if (!legacy && web3_utils_1.jsonRpc.isBatchRequest(payload) && web3_utils_1.jsonRpc.isBatchResponse(response)) {\n      return response;\n    }\n\n    if (legacy && !error && web3_utils_1.jsonRpc.isBatchRequest(payload)) {\n      return response;\n    }\n\n    if (legacy && error && web3_utils_1.jsonRpc.isBatchRequest(payload)) {\n      // In case of error batch response we don't want to throw Invalid response\n      throw response;\n    }\n\n    if (legacy && !web3_utils_1.jsonRpc.isResponseWithError(response) && !web3_utils_1.jsonRpc.isResponseWithResult(response)) {\n      return this._buildResponse(payload, response, error);\n    }\n\n    if (web3_utils_1.jsonRpc.isBatchRequest(payload) && !Array.isArray(response)) {\n      throw new web3_errors_1.ResponseError(response, 'Got normal response for a batch request.');\n    }\n\n    if (!web3_utils_1.jsonRpc.isBatchRequest(payload) && Array.isArray(response)) {\n      throw new web3_errors_1.ResponseError(response, 'Got batch response for a normal request.');\n    }\n\n    if ((web3_utils_1.jsonRpc.isResponseWithError(response) || web3_utils_1.jsonRpc.isResponseWithResult(response)) && !web3_utils_1.jsonRpc.isBatchRequest(payload)) {\n      if (response.id && payload.id !== response.id) {\n        throw new web3_errors_1.InvalidResponseError(response);\n      }\n    }\n\n    throw new web3_errors_1.ResponseError(response, 'Invalid response');\n  }\n\n  static _isReverted(response) {\n    let error;\n\n    if (web3_utils_1.jsonRpc.isResponseWithError(response)) {\n      error = response.error;\n    } else if (response instanceof Error) {\n      error = response;\n    } // This message means that there was an error while executing the code of the smart contract\n    // However, more processing will happen at a higher level to decode the error data,\n    //\taccording to the Error ABI, if it was available as of EIP-838.\n\n\n    if (error === null || error === void 0 ? void 0 : error.message.includes('revert')) throw new web3_errors_1.ContractExecutionError(error);\n    return false;\n  } // Need to use same types as _processJsonRpcResponse so have to declare as instance method\n  // eslint-disable-next-line class-methods-use-this\n\n\n  _buildResponse(payload, response, error) {\n    const res = {\n      jsonrpc: '2.0',\n      // eslint-disable-next-line no-nested-ternary\n      id: web3_utils_1.jsonRpc.isBatchRequest(payload) ? payload[0].id : 'id' in payload ? payload.id : // Have to use the null here explicitly\n      // eslint-disable-next-line no-null/no-null\n      null\n    };\n\n    if (error) {\n      return Object.assign(Object.assign({}, res), {\n        error: response\n      });\n    }\n\n    return Object.assign(Object.assign({}, res), {\n      result: response\n    });\n  }\n\n}\n\nexports.Web3RequestManager = Web3RequestManager;","map":{"version":3,"mappings":"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","names":["Web3RequestManagerEvent","exports","availableProviders","HttpProvider","web3_providers_http_1","WebsocketProvider","web3_providers_ws_1","Web3RequestManager","web3_event_emitter_js_1","constructor","provider","useRpcCallSpecification","setProvider","providers","_provider","newProvider","test","web3_errors_1","undefined","emit","BEFORE_PROVIDER_CHANGE","PROVIDER_CHANGED","send","request","response","_sendRequest","web3_utils_1","isResponseWithResult","result","sendBatch","payload","isBatchRequest","toBatchPayload","toPayload","error","_processJsonRpcResponse","legacy","then","res","catch","Promise","resolve","reject","rejectWithError","err","resolveWithResponse","responsePromise","sendAsync","_buildResponse","isResponseWithError","rpcErrorResponse","get","code","Err","_isReverted","Error","isBatchResponse","Array","isArray","id","message","includes","jsonrpc","Object"],"sources":["/home/rupam/Desktop/Faucet-React/node_modules/web3-core/src/web3_request_manager.ts"],"sourcesContent":["ï»¿/*\nThis file is part of web3.js.\n\nweb3.js is free software: you can redistribute it and/or modify\nit under the terms of the GNU Lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nweb3.js is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU Lesser General Public License for more details.\n\nYou should have received a copy of the GNU Lesser General Public License\nalong with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\nimport {\n\tContractExecutionError,\n\tInvalidResponseError,\n\tProviderError,\n\tResponseError,\n\trpcErrorsMap,\n\tRpcError,\n} from 'web3-errors';\nimport HttpProvider from 'web3-providers-http';\nimport WSProvider from 'web3-providers-ws';\nimport {\n\tEthExecutionAPI,\n\tJsonRpcBatchRequest,\n\tJsonRpcBatchResponse,\n\tJsonRpcPayload,\n\tJsonRpcResponse,\n\tJsonRpcError,\n\tJsonRpcResponseWithResult,\n\tJsonRpcResponseWithError,\n\tSupportedProviders,\n\tWeb3APIMethod,\n\tWeb3APIPayload,\n\tWeb3APIRequest,\n\tWeb3APIReturnType,\n\tWeb3APISpec,\n\tWeb3BaseProvider,\n\tWeb3BaseProviderConstructor,\n} from 'web3-types';\nimport { isNullish, isPromise, jsonRpc, isResponseRpcError } from 'web3-utils';\nimport {\n\tisEIP1193Provider,\n\tisLegacyRequestProvider,\n\tisLegacySendAsyncProvider,\n\tisLegacySendProvider,\n\tisWeb3Provider,\n} from './utils.js';\nimport { Web3EventEmitter } from './web3_event_emitter.js';\n\nexport enum Web3RequestManagerEvent {\n\tPROVIDER_CHANGED = 'PROVIDER_CHANGED',\n\tBEFORE_PROVIDER_CHANGE = 'BEFORE_PROVIDER_CHANGE',\n}\n\nconst availableProviders: {\n\tHttpProvider: Web3BaseProviderConstructor;\n\tWebsocketProvider: Web3BaseProviderConstructor;\n} = {\n\tHttpProvider: HttpProvider as Web3BaseProviderConstructor,\n\tWebsocketProvider: WSProvider as Web3BaseProviderConstructor,\n};\n\nexport class Web3RequestManager<\n\tAPI extends Web3APISpec = EthExecutionAPI,\n> extends Web3EventEmitter<{\n\t[key in Web3RequestManagerEvent]: SupportedProviders<API> | undefined;\n}> {\n\tprivate _provider?: SupportedProviders<API>;\n\tprivate readonly useRpcCallSpecification?: boolean;\n\tpublic constructor(\n\t\tprovider?: SupportedProviders<API> | string,\n\t\tuseRpcCallSpecification?: boolean,\n\t) {\n\t\tsuper();\n\n\t\tif (!isNullish(provider)) {\n\t\t\tthis.setProvider(provider);\n\t\t}\n\t\tthis.useRpcCallSpecification = useRpcCallSpecification;\n\t}\n\n\t/**\n\t * Will return all available providers\n\t */\n\tpublic static get providers() {\n\t\treturn availableProviders;\n\t}\n\n\t/**\n\t * Will return the current provider.\n\t *\n\t * @returns Returns the current provider\n\t */\n\tpublic get provider() {\n\t\treturn this._provider;\n\t}\n\n\t/**\n\t * Will return all available providers\n\t */\n\t// eslint-disable-next-line class-methods-use-this\n\tpublic get providers() {\n\t\treturn availableProviders;\n\t}\n\n\t/**\n\t * Use to set provider. Provider can be a provider instance or a string.\n\t *\n\t * @param provider - The provider to set\n\t */\n\tpublic setProvider(provider?: SupportedProviders<API> | string): boolean {\n\t\tlet newProvider: SupportedProviders<API> | undefined;\n\n\t\t// autodetect provider\n\t\tif (provider && typeof provider === 'string' && this.providers) {\n\t\t\t// HTTP\n\t\t\tif (/^http(s)?:\\/\\//i.test(provider)) {\n\t\t\t\tnewProvider = new this.providers.HttpProvider<API>(provider);\n\n\t\t\t\t// WS\n\t\t\t} else if (/^ws(s)?:\\/\\//i.test(provider)) {\n\t\t\t\tnewProvider = new this.providers.WebsocketProvider<API>(provider);\n\t\t\t} else {\n\t\t\t\tthrow new ProviderError(`Can't autodetect provider for \"${provider}\"`);\n\t\t\t}\n\t\t} else if (isNullish(provider)) {\n\t\t\t// In case want to unset the provider\n\t\t\tnewProvider = undefined;\n\t\t} else {\n\t\t\tnewProvider = provider as SupportedProviders<API>;\n\t\t}\n\n\t\tthis.emit(Web3RequestManagerEvent.BEFORE_PROVIDER_CHANGE, this._provider);\n\t\tthis._provider = newProvider;\n\t\tthis.emit(Web3RequestManagerEvent.PROVIDER_CHANGED, this._provider);\n\t\treturn true;\n\t}\n\n\t/**\n\t *\n\t * Will execute a request\n\t *\n\t * @param request - {@link Web3APIRequest} The request to send\n\t *\n\t * @returns The response of the request {@link ResponseType}. If there is error\n\t * in the response, will throw an error\n\t */\n\tpublic async send<\n\t\tMethod extends Web3APIMethod<API>,\n\t\tResponseType = Web3APIReturnType<API, Method>,\n\t>(request: Web3APIRequest<API, Method>): Promise<ResponseType> {\n\t\tconst response = await this._sendRequest<Method, ResponseType>(request);\n\t\tif (jsonRpc.isResponseWithResult(response)) {\n\t\t\treturn response.result;\n\t\t}\n\n\t\tthrow new ResponseError(response);\n\t}\n\n\t/**\n\t * Same as send, but, will execute a batch of requests\n\t *\n\t * @param request {@link JsonRpcBatchRequest} The batch request to send\n\t */\n\tpublic async sendBatch(request: JsonRpcBatchRequest): Promise<JsonRpcBatchResponse<unknown>> {\n\t\tconst response = await this._sendRequest<never, never>(request);\n\n\t\treturn response as JsonRpcBatchResponse<unknown>;\n\t}\n\n\tprivate async _sendRequest<\n\t\tMethod extends Web3APIMethod<API>,\n\t\tResponseType = Web3APIReturnType<API, Method>,\n\t>(\n\t\trequest: Web3APIRequest<API, Method> | JsonRpcBatchRequest,\n\t): Promise<JsonRpcResponse<ResponseType>> {\n\t\tconst { provider } = this;\n\n\t\tif (isNullish(provider)) {\n\t\t\tthrow new ProviderError(\n\t\t\t\t'Provider not available. Use `.setProvider` or `.provider=` to initialize the provider.',\n\t\t\t);\n\t\t}\n\n\t\tconst payload = jsonRpc.isBatchRequest(request)\n\t\t\t? jsonRpc.toBatchPayload(request)\n\t\t\t: jsonRpc.toPayload(request);\n\n\t\tif (isWeb3Provider(provider)) {\n\t\t\tlet response;\n\n\t\t\ttry {\n\t\t\t\tresponse = await provider.request<Method, ResponseType>(\n\t\t\t\t\tpayload as Web3APIPayload<API, Method>,\n\t\t\t\t);\n\t\t\t} catch (error) {\n\t\t\t\t// Check if the provider throw an error instead of reject with error\n\t\t\t\tresponse = error as JsonRpcResponse<ResponseType>;\n\t\t\t}\n\t\t\treturn this._processJsonRpcResponse(payload, response, { legacy: false, error: false });\n\t\t}\n\n\t\tif (isEIP1193Provider(provider)) {\n\t\t\treturn (provider as Web3BaseProvider<API>)\n\t\t\t\t.request<Method, ResponseType>(payload as Web3APIPayload<API, Method>)\n\t\t\t\t.then(\n\t\t\t\t\tres =>\n\t\t\t\t\t\tthis._processJsonRpcResponse(payload, res, {\n\t\t\t\t\t\t\tlegacy: true,\n\t\t\t\t\t\t\terror: false,\n\t\t\t\t\t\t}) as JsonRpcResponseWithResult<ResponseType>,\n\t\t\t\t)\n\t\t\t\t.catch(error =>\n\t\t\t\t\tthis._processJsonRpcResponse(\n\t\t\t\t\t\tpayload,\n\t\t\t\t\t\terror as JsonRpcResponse<ResponseType, unknown>,\n\t\t\t\t\t\t{ legacy: true, error: true },\n\t\t\t\t\t),\n\t\t\t\t);\n\t\t}\n\n\t\t// TODO: This could be deprecated and removed.\n\t\tif (isLegacyRequestProvider(provider)) {\n\t\t\treturn new Promise<JsonRpcResponse<ResponseType>>((resolve, reject) => {\n\t\t\t\tconst rejectWithError = (err: unknown) =>\n\t\t\t\t\treject(\n\t\t\t\t\t\tthis._processJsonRpcResponse(\n\t\t\t\t\t\t\tpayload,\n\t\t\t\t\t\t\terr as JsonRpcResponse<ResponseType>,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlegacy: true,\n\t\t\t\t\t\t\t\terror: true,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\tconst resolveWithResponse = (response: JsonRpcResponse<ResponseType>) =>\n\t\t\t\t\tresolve(\n\t\t\t\t\t\tthis._processJsonRpcResponse(payload, response, {\n\t\t\t\t\t\t\tlegacy: true,\n\t\t\t\t\t\t\terror: false,\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\tconst result = provider.request<ResponseType>(\n\t\t\t\t\tpayload,\n\t\t\t\t\t// a callback that is expected to be called after getting the response:\n\t\t\t\t\t(err, response) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treturn rejectWithError(err);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn resolveWithResponse(response);\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\t\t// Some providers, that follow a previous drafted version of EIP1193, has a `request` function\n\t\t\t\t//\tthat is not defined as `async`, but it returns a promise.\n\t\t\t\t// Such providers would not be picked with if(isEIP1193Provider(provider)) above\n\t\t\t\t//\tbecause the `request` function was not defined with `async` and so the function definition is not `AsyncFunction`.\n\t\t\t\t// Like this provider: https://github.dev/NomicFoundation/hardhat/blob/62bea2600785595ba36f2105564076cf5cdf0fd8/packages/hardhat-core/src/internal/core/providers/backwards-compatibility.ts#L19\n\t\t\t\t// So check if the returned result is a Promise, and resolve with it accordingly.\n\t\t\t\t// Note: in this case we expect the callback provided above to never be called.\n\t\t\t\tif (isPromise(result)) {\n\t\t\t\t\tconst responsePromise = result as unknown as Promise<\n\t\t\t\t\t\tJsonRpcResponse<ResponseType>\n\t\t\t\t\t>;\n\t\t\t\t\tresponsePromise.then(resolveWithResponse).catch(rejectWithError);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// TODO: This could be deprecated and removed.\n\t\tif (isLegacySendProvider(provider)) {\n\t\t\treturn new Promise<JsonRpcResponse<ResponseType>>((resolve, reject): void => {\n\t\t\t\tprovider.send<ResponseType>(payload, (err, response) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treturn reject(\n\t\t\t\t\t\t\tthis._processJsonRpcResponse(\n\t\t\t\t\t\t\t\tpayload,\n\t\t\t\t\t\t\t\terr as unknown as JsonRpcResponse<ResponseType>,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tlegacy: true,\n\t\t\t\t\t\t\t\t\terror: true,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (isNullish(response)) {\n\t\t\t\t\t\tthrow new ResponseError(\n\t\t\t\t\t\t\t'' as never,\n\t\t\t\t\t\t\t'Got a \"nullish\" response from provider.',\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn resolve(\n\t\t\t\t\t\tthis._processJsonRpcResponse(payload, response, {\n\t\t\t\t\t\t\tlegacy: true,\n\t\t\t\t\t\t\terror: false,\n\t\t\t\t\t\t}),\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t// TODO: This could be deprecated and removed.\n\t\tif (isLegacySendAsyncProvider(provider)) {\n\t\t\treturn provider\n\t\t\t\t.sendAsync<ResponseType>(payload)\n\t\t\t\t.then(response =>\n\t\t\t\t\tthis._processJsonRpcResponse(payload, response, { legacy: true, error: false }),\n\t\t\t\t)\n\t\t\t\t.catch(error =>\n\t\t\t\t\tthis._processJsonRpcResponse(payload, error as JsonRpcResponse<ResponseType>, {\n\t\t\t\t\t\tlegacy: true,\n\t\t\t\t\t\terror: true,\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t}\n\n\t\tthrow new ProviderError('Provider does not have a request or send method to use.');\n\t}\n\n\t// eslint-disable-next-line class-methods-use-this\n\tprivate _processJsonRpcResponse<ResultType, ErrorType, RequestType>(\n\t\tpayload: JsonRpcPayload<RequestType>,\n\t\tresponse: JsonRpcResponse<ResultType, ErrorType>,\n\t\t{ legacy, error }: { legacy: boolean; error: boolean },\n\t): JsonRpcResponse<ResultType> | never {\n\t\tif (isNullish(response)) {\n\t\t\treturn this._buildResponse(\n\t\t\t\tpayload,\n\t\t\t\t// Some providers uses \"null\" as valid empty response\n\t\t\t\t// eslint-disable-next-line no-null/no-null\n\t\t\t\tnull as unknown as JsonRpcResponse<ResultType, ErrorType>,\n\t\t\t\terror,\n\t\t\t);\n\t\t}\n\n\t\t// This is the majority of the cases so check these first\n\t\t// A valid JSON-RPC response with error object\n\t\tif (jsonRpc.isResponseWithError<ErrorType>(response)) {\n\t\t\t// check if its an rpc error\n\t\t\tif (\n\t\t\t\tthis.useRpcCallSpecification &&\n\t\t\t\tisResponseRpcError(response as JsonRpcResponseWithError)\n\t\t\t) {\n\t\t\t\tconst rpcErrorResponse = response as JsonRpcResponseWithError;\n\t\t\t\t// check if rpc error flag is on and response error code match an EIP-1474 or a standard rpc error code\n\t\t\t\tif (rpcErrorsMap.get(rpcErrorResponse.error.code)) {\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t\t\t\t\tconst Err = rpcErrorsMap.get(rpcErrorResponse.error.code)!.error;\n\t\t\t\t\tthrow new Err(rpcErrorResponse);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new RpcError(rpcErrorResponse);\n\t\t\t\t}\n\t\t\t} else if (!Web3RequestManager._isReverted(response)) {\n\t\t\t\tthrow new InvalidResponseError<ErrorType, RequestType>(response, payload);\n\t\t\t}\n\t\t}\n\n\t\t// This is the majority of the cases so check these first\n\t\t// A valid JSON-RPC response with result object\n\t\tif (jsonRpc.isResponseWithResult<ResultType>(response)) {\n\t\t\treturn response;\n\t\t}\n\n\t\tif ((response as unknown) instanceof Error) {\n\t\t\tWeb3RequestManager._isReverted(response);\n\t\t\tthrow response;\n\t\t}\n\n\t\tif (!legacy && jsonRpc.isBatchRequest(payload) && jsonRpc.isBatchResponse(response)) {\n\t\t\treturn response as JsonRpcBatchResponse<ResultType>;\n\t\t}\n\n\t\tif (legacy && !error && jsonRpc.isBatchRequest(payload)) {\n\t\t\treturn response as JsonRpcBatchResponse<ResultType>;\n\t\t}\n\n\t\tif (legacy && error && jsonRpc.isBatchRequest(payload)) {\n\t\t\t// In case of error batch response we don't want to throw Invalid response\n\t\t\tthrow response;\n\t\t}\n\n\t\tif (\n\t\t\tlegacy &&\n\t\t\t!jsonRpc.isResponseWithError(response) &&\n\t\t\t!jsonRpc.isResponseWithResult(response)\n\t\t) {\n\t\t\treturn this._buildResponse(payload, response, error);\n\t\t}\n\n\t\tif (jsonRpc.isBatchRequest(payload) && !Array.isArray(response)) {\n\t\t\tthrow new ResponseError(response, 'Got normal response for a batch request.');\n\t\t}\n\n\t\tif (!jsonRpc.isBatchRequest(payload) && Array.isArray(response)) {\n\t\t\tthrow new ResponseError(response, 'Got batch response for a normal request.');\n\t\t}\n\n\t\tif (\n\t\t\t(jsonRpc.isResponseWithError(response) || jsonRpc.isResponseWithResult(response)) &&\n\t\t\t!jsonRpc.isBatchRequest(payload)\n\t\t) {\n\t\t\tif (response.id && payload.id !== response.id) {\n\t\t\t\tthrow new InvalidResponseError<ErrorType>(response);\n\t\t\t}\n\t\t}\n\n\t\tthrow new ResponseError(response, 'Invalid response');\n\t}\n\n\tprivate static _isReverted<ResultType, ErrorType>(\n\t\tresponse: JsonRpcResponse<ResultType, ErrorType>,\n\t): boolean {\n\t\tlet error: JsonRpcError | undefined;\n\n\t\tif (jsonRpc.isResponseWithError<ErrorType>(response)) {\n\t\t\terror = (response as JsonRpcResponseWithError).error;\n\t\t} else if ((response as unknown) instanceof Error) {\n\t\t\terror = response as unknown as JsonRpcError;\n\t\t}\n\n\t\t// This message means that there was an error while executing the code of the smart contract\n\t\t// However, more processing will happen at a higher level to decode the error data,\n\t\t//\taccording to the Error ABI, if it was available as of EIP-838.\n\t\tif (error?.message.includes('revert')) throw new ContractExecutionError(error);\n\n\t\treturn false;\n\t}\n\t// Need to use same types as _processJsonRpcResponse so have to declare as instance method\n\t// eslint-disable-next-line class-methods-use-this\n\tprivate _buildResponse<ResultType, ErrorType, RequestType>(\n\t\tpayload: JsonRpcPayload<RequestType>,\n\t\tresponse: JsonRpcResponse<ResultType, ErrorType>,\n\t\terror: boolean,\n\t): JsonRpcResponse<ResultType> {\n\t\tconst res = {\n\t\t\tjsonrpc: '2.0',\n\t\t\t// eslint-disable-next-line no-nested-ternary\n\t\t\tid: jsonRpc.isBatchRequest(payload)\n\t\t\t\t? payload[0].id\n\t\t\t\t: 'id' in payload\n\t\t\t\t? payload.id\n\t\t\t\t: // Have to use the null here explicitly\n\t\t\t\t  // eslint-disable-next-line no-null/no-null\n\t\t\t\t  null,\n\t\t};\n\n\t\tif (error) {\n\t\t\treturn {\n\t\t\t\t...res,\n\t\t\t\terror: response as unknown,\n\t\t\t} as JsonRpcResponse<ResultType>;\n\t\t}\n\n\t\treturn {\n\t\t\t...res,\n\t\t\tresult: response as unknown,\n\t\t} as JsonRpcResponse<ResultType>;\n\t}\n}\n"]},"metadata":{},"sourceType":"script"}